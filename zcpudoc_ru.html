<!-- Custom Markup, not generated by TeX -->
<!DOCTYPE html>
<html>

	<head>
		<link href="zcpudoc.css" rel="stylesheet" type="text/css">
		<meta charset="utf-8">
		<title>ZCPU Documentation</title>
	</head>
<body>
<!-- End Custom Markup -->

<!--HEVEA command line is: C:\hevea\hevea zcpudoc.tex -o zcpudoc_ru.html -->
<!--CUT DEF chapter 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Документация Zyelios CPU 10</H1><H3 CLASS="titlerest">Black Phoenix</H3></TD></TR>
</TABLE><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">Chapter 1  Функции процессора</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc2">1.1  Вступление</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc3">1.2  Теория</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">1.3  Регистры общего назначения</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">1.4  Выполнение инструкций</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">1.5  Прерывания</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">1.6  Сегментация памяти и сегментные регистры</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">1.7  Модели памяти</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">1.8  Стек</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">1.9  Подпрограммы</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">1.10  Коды ошибок процессора</A>
</LI></UL>
</LI></UL><!--TOC chapter Функции процессора-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter 1</A>  Функции процессора</H1><!--SEC END --><!--TOC section Вступление-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>  Вступление</H2><!--SEC END --><P>Zyelios CPU - виртуальный процессор. Он был создан для для автоматизации устройств и машин, созданных с помощью Wiremod, а также для обучения основам низкоуровневого программирования, программирования на языке С (с выходом компилятора HL-ZASM).</P><P>Этот процессор по своей архитектуре и внутренней структуре очень сильно напоминает современные микроконтроллеры и процессоры общего назначения, которые используются в современных компьютерах. Он был первоначально основан на базе архитектуры <TT>x86</TT>, но имеет значительные отличия, например, ZCPU использует числа с плавающей точкой вместо целочисленной арифметики.</P><P>Процессор - сложная машина, и, подобно управлению настоящей машиной, требует навыков. Надо понимать, что, несмотря на большие возможности по использованию процессора, он работает по весьма простым логическим правилам. Все функции процессора созданы взаимодействием этих правил.</P><P>Данная книга служит краткой документацией по всем функциям и возможностям ZCPU, включая любые не очевидные особенности работы. Но здесь указаны лишь возможности по управлению процессором, эта книга не предназначена для вводного ознакомления с ним.</P><!--TOC section Теория-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">1.2</A>  Теория</H2><!--SEC END --><P>
Процессоры были изобретены как следующий шаг развития аналоговых компьютеров. Первые процессоры были использованы для решения математических уравнений, расчёта физических моделей и обработки большого количества статистических данных.</P><P>Программа, которую выполняет процессор, разделена на инструкции. Каждая инструкция это простая операция, которая некоторым образом меняет состояние процессора, или любого из внешних устройств. Например:
</P><PRE CLASS="verbatim">MOV R0,100 //Занести 100 в регистр R0
ADD R0,R1 //Добавить R1 к R0
</PRE><P>Дополнительные параметры, которые передаются в инструкцию и некоторым образом задают её поведение, называются <EM>операндами</EM>. У каждой инструкции может быть 0, 1 или 2 операнда. Первый операнд называется <EM>целевым</EM> операндом, а второй - <EM>исходным</EM>.</P><P>В результате выполнения инструкции результат может быть записан в первый операнд:
</P><PRE CLASS="verbatim">ADD R0,200; //R0 = R0 + 200
</PRE><P><EM>Регистром</EM> называется ячейка со значением, которая находится внутри процессора. Регистры могут быть регистрами <EM>общего назначения</EM> и <EM>управляющими</EM> (внутренними). Программист может любым образом использовать регистры общего назначения, например, для сохранения промежуточных результатов:
</P><PRE CLASS="verbatim">MOV R6,100;
MOV R7,R6;
</PRE><P>Управляющие регистры меняют состояние и режим работы процессора.</P><P>Внешние устройства и дополнительная память подключаются к процессору через шину данных/адресов. <EM>Шина данных/адресов</EM> - это особое устройство, которое позволяет связывать несколько других устройств вместе и производить обмен данными между ними. В процессоре ZCPU есть две шины: <TT>MemBus</TT> (шина внешней памяти), и <TT>IOBus</TT> (шина ввода/вывода по портам). Каждая ячейка памяти на этих шинах адресуется целым числом - <EM>адресом</EM>. Нету никакой принципиальной разницы между двумя вышеуказанными шинами процессора, но ячейки шины портов можно использовать как регистры процессора:
</P><PRE CLASS="verbatim">MOV R0,PORT0 //Считать ячейку 0 через шину портов
MOV [500],R0 //Записать в ячейку 500 через шину памяти
</PRE><P>Шина памяти расположена на положительных адресах, а шина портов расположена в отрицательных адресах процессора, и как-бы зеркально отражена относительно шины памяти. Например:
</P><PRE CLASS="verbatim">MOV R0,PORT0 //Считать ячейку 0 через шину портов
MOV R0,[-1] //Тоже самое
</PRE><P>В процессоре ZCPU есть поддержка нескольких моделей памяти, которые задают размер встроенной оперативной памяти, размер постоянной памяти, и тому подобное.</P><!--TOC section Регистры общего назначения-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">1.3</A>  Регистры общего назначения</H2><!--SEC END --><P>
В процессоре есть 40 регистров общего назначения. Они разделяются на <EM>основные</EM> и <EM>дополнительные</EM>. Регистры основного набора - <TT>EAX</TT>, <TT>EBX</TT>, <TT>ECX</TT>, <TT>EDX</TT>, <TT>ESI</TT>, <TT>EDI</TT>, <TT>ESP</TT> и <TT>EBP</TT>. Регистры дополнительного набора нумеруются таким образом: <TT>R0</TT>, <TT>R1</TT>, ..., <TT>R31</TT>.</P><P>Каждый регистр может хранить некоторое число, и его можно использовать для проведения арифметических операций. Но при этом регистр <TT>ESP</TT> используется для работы стека процессора, и изменение его значения может привести к некорректной работе программы. Если используются возможности C, то <TT>EBP</TT> также используется для сохранения указателя на стековый кадр функции, и его изменение вызовет ошибку программы.</P><P>Каждый регистр хранит одно 64-битное значение с плавающей точкой. Его значение может находиться в пределах от &#X2212;10<SUP>1022</SUP> до 10<SUP>1023</SUP>, но при этом точность самих чисел ограничена 48 битами. Это упрощение отличает процессор ZCPU от реальных процессоров.</P><P>Использование регистров <EM>намного</EM> быстрее использования памяти. В 10 версии процессора были добавлены 32 регистра общего назначения, сформировав дополнительный набор регистров для ускорения работы программ.</P><P>При сбросе состояния процессора все регистры, кроме <TT>ESP</TT>, будут выставлены в 0. Если в текущей модели памяти процессора есть внутренняя встроенная память, то регистр указателя стека будет указывать на последнюю ячейку внутренней памяти процессора.</P><!--TOC section Выполнение инструкций-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.4</A>  Выполнение инструкций</H2><!--SEC END --><P>
В процессоре ZCPU есть специальный регистр который называется указателем на инструкцию (<TT>IP</TT>). Регистр <TT>IP</TT> указывает на текущую выполняемую процессором инструкцию, и увеличивается по мере выполнения последующих инструкций.</P><P>Инструкции процессора могут быть либо переменной длины, либо постоянной длины, в зависимости от режима исполнения (см. стр <A HREF="#localexec">??</A>), поэтому указатель на инструкцию <TT>IP</TT> может меняться с разным шагом. Можно напрямую задавать значение регистра <TT>IP</TT> используя операции условного и безусловного перехода (см. стр <A HREF="#branching">??</A>).</P><P>Выполнение инструкций происходит следующим образом:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	Процессор считывает номер инструкции
	</LI><LI CLASS="li-enumerate">Если у инструкции есть операнды, то процессор считывает байт селектора регистр-память (см. <TT>rmbyte</TT>). Если у инструкции нету операндов, и следующий байт нулевой, то он будет пропущен (это выполняется для совместимости со старыми версиями процессора).
	</LI><LI CLASS="li-enumerate">Номер инструкции декодируется, и считываются дополнительные байты сегментных префиксов (если они нужны, см. стр <A HREF="#instructionformat">??</A> для более детальной информации о их работе).
	</LI><LI CLASS="li-enumerate">Если нужно, то будут считаны дополнительные байты констант нужных для операнда.
	</LI><LI CLASS="li-enumerate">Процессор выполняет микрокод инструкции, который некоторым образом меняет состояние процессора (но при этом эти изменения кешируются, и не сразу записываются в регистры).
	</LI><LI CLASS="li-enumerate">Внутреннее состояние обновляется, и все записанные в кеш регистры переносяться в их реальные ячейки.
</LI></OL><P>Кеширование используется для оптимизации скорости работы процессора. На странице <A HREF="#caching">??</A> указан более детальный механизм кеширования.</P><P>Процессор выполняет постоянное количество циклов за секунду. Количество циклов необходимое для выполнения каждой отдельной инструкции может меняться. Полное количество циклов считается регистром <TT>TMR</TT>. Почти все инструкции всего 1 цикл в длину, но из-за кеширования и доступа к памяти это число может меняться в значительных пределах.</P><P>См. стр <A HREF="#advexecution">??</A> для более детальной информации о процессе выполнения.</P><!--TOC section Прерывания-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">1.5</A>  Прерывания</H2><!--SEC END --><P>
При возникновении некоторых особых событий в процессоре (например внешний сигнал, возникновение ошибки в арифметических операциях, и т.п.) процессор ZCPU сгенерирует прерывание. Прерывания - это особая функция процессора, которая временно "прерывает" его работу, изменяя выполнение программы что-бы выполнить обработчик события. При возникновении прерывания процессор заносит на свой стек адрес возврата в программу, и переходит к выполнению обработчика прерывания (см. стр <A HREF="#stack">??</A> для более подробной информации о стеке процессора).</P><P>В расширеном режиме процессор использует таблицу прерываний, в которой хранятся указатели на все функции-обработчики событий. Если расширенный режим не включён, то любое прерывание будет полностью останавливать процессор.</P><P>Каждое прерывание задаётся его номером, а также параметром прерывания - некоторым числом, которое несёт дополнительную информацию о прерывании.</P><P>После окончания выполнения обработчика прерывания состояние процессора будет восстановлено, и программа продолжит выполнение с места где возникло прерывание.</P><P>При возникновении прерывания процессор заносит на стек адрес возврата. Например если текущее значение указателя на инструкцию <TT>IP</TT> есть 157, а состояние стека:
</P><PRE CLASS="verbatim">..........
65304: ...
65306: 181
65305: -94

ESP = 65304
</PRE><P>то после возникновения прерывания стек примет вид:
</P><PRE CLASS="verbatim">..........
65304: ...
65306: 181
65305: -94
65304: 0   CS
65303: 157 IP

ESP = 65302
</PRE><P>и указатель на инструкцию будет равен точке входа в обработчик прерываний.</P><P>Прерывания очень похожи на обычные вызовы подпрограмм (см. стр <A HREF="#branching">??</A>), но вместо использования прямого указателя процессору передаётся номер прерывания. Для возврата из обработчика нужно использовать специальную команду возврата <TT>IRET</TT> (вместо обычной <TT>RET</TT>). Любое прерывание можно вызвать вручную используя инструкцию <TT>INT</TT>. Пример обработчика прерываний:
</P><PRE CLASS="verbatim">interrupt_handler:
  ....
iret;
</PRE><P>Существует два вида прерываний: внутренние прерывания (ошибки), и внешние прерывания. Внешние прерывания сохраняют состояние всех основных регистров процессора (вместе с данными для возврата из прерывания) перед выполнением обработчика. Они могут быть вызваны только через внешний вход для прерываний, или используя инструкцию <TT>EXTINT</TT>. Внешние прерывания требуют использования инструкции <TT>EXTRET</TT> для выхода из обработчика вместо <TT>IRET</TT> как для обычных прерываний.</P><P>Есть несколько стандартных прерываний. Они будут вызваны если происходит некоторое внутреннее исключение. Все прерывания с номером ниже 32 зарезервированы для обработки ошибок процессора. Также прерывания 0 и 1 имеют специальное значение, и используются для перезапуска/выключения процессора. Прерывания 32..255 доступны для использования пользовательской программы. См. стр <A HREF="#errorcodes">??</A> для более детальной информации о кодах ошибок (номерах прерываний ошибок).</P><P>Эта таблица содержит все коды ошибок процессора:</P><P>


</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Номер</TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>0</TD><TD VALIGN=top ALIGN=left><EM>Сброс</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>1</TD><TD VALIGN=top ALIGN=left><EM>Отключение</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>2</TD><TD VALIGN=top ALIGN=left>Конец выполнения программы</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>3</TD><TD VALIGN=top ALIGN=left>Деление на ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>4</TD><TD VALIGN=top ALIGN=left>Неизвестная инструкция</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>5</TD><TD VALIGN=top ALIGN=left>Внутренняя ошибка процессора</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>6</TD><TD VALIGN=top ALIGN=left>Ошибка стека (переполнение/недополнение)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>7</TD><TD VALIGN=top ALIGN=left>Ошибка записи/чтения памяти</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>8</TD><TD VALIGN=top ALIGN=left>Ошибка шины памяти</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>9</TD><TD VALIGN=top ALIGN=left>Ошибка доступа записи (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>10</TD><TD VALIGN=top ALIGN=left>Ошибка записи/чтения порта</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>11</TD><TD VALIGN=top ALIGN=left>Ошибка доступа к странице (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>12</TD><TD VALIGN=top ALIGN=left>Ошибка доступа чтения (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>13</TD><TD VALIGN=top ALIGN=left>Общая ошибка процессора</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>14</TD><TD VALIGN=top ALIGN=left>Ошибка исполнения (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>15</TD><TD VALIGN=top ALIGN=left>Выход за пределы адресного пространства</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>17</TD><TD VALIGN=top ALIGN=left>Ограничение количества инструкций (<EM>только GPU</EM>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>23</TD><TD VALIGN=top ALIGN=left>Ошибка чтения строки (<EM>только GPU</EM>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>28</TD><TD VALIGN=top ALIGN=left><EM>Обработчик доступа чтения страницы</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>29</TD><TD VALIGN=top ALIGN=left><EM>Обработчик доступа записи страницы</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>30</TD><TD VALIGN=top ALIGN=left><EM>Обработчик доступа к странице</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>31</TD><TD VALIGN=top ALIGN=left><EM>Обработчик шага отладки</EM></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Прерывание сброса (0) сбросит состояние процессора, и перезапустит выполнение кода с начала. Прерывание отключения (1) остановит выполнение кода пока процессор не будет перезапущен извне. Инструкции <TT>int 1</TT> и <TT>int 0</TT> будут правильно работать если они не обрабатываются процессором (т.е. если они отключены в таблице прерываний, или если таблицы прерываний отключена):
</P><PRE CLASS="verbatim"> INT 1; //Остановить выполнение

 INT 0; //Перезапустить процессора
</PRE><P>Если расширенный режим не включен, <EM>все прерывания</EM> работают так-же как и прерывание остановки (<TT>int 1</TT>). Код ошибки будет послан на внешний выход кода ошибки.</P><P>Обработка прерываний может быть отключена флагом прерываний <TT>IF</TT>. Этот регистр напрямую изменить нельзя, но его можно менять специальными инструкциями. <EM>При выставлении флага он будет выставлен только после следующей инструкции</EM>. Например:</P><PRE CLASS="verbatim">STI;         //Установить флаг прерываний
MOV EAX,123; //IF = 0
ADD EAX,123; //IF = 1 (флаг обновлён)
CLI;         //Убрать флаг прерываний
SUB EAX,123; //IF = 0 (флаг убран)
RET;         //IF = 0
</PRE><P>Это даёт возможность предотвратить ситуацию когда прерывание возникнет между инструкцией возврата и <TT>STI</TT>:</P><PRE CLASS="verbatim">ContextSwitch:
  CLI;

  ... код ...

  STI;  //Прерывание никогда не возникнет между STI
EXTRET; //и NMIRET
</PRE><P>Для более детальной информации по работе таблицы прерываний см. страницу <A HREF="#advancedinterrupts">??</A>.</P><!--TOC section Сегментация памяти и сегментные регистры-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc7">1.6</A>  Сегментация памяти и сегментные регистры</H2><!--SEC END --><P> <A NAME="segments"></A>
В ZCPU есть 8 сегментных регистров. Это <TT>CS</TT>, <TT>SS</TT>, <TT>DS</TT>, <TT>ES</TT>, <TT>GS</TT>, <TT>FS</TT>, <TT>KS</TT> и <TT>LS</TT>. Они используются процессором для работы с разными моделями памяти. Также любые из 40 регистров общего назначения могут быть использованы как сегментные регистры.</P><P>Каждый сегментный регистр может хранить 48-битное целое число. Это значение может быть использовано для задание смещения для указателей при чтении/записи в память. Процессор всегда использует сегменты при обращении к памяти: он транслирует локальный адрес (который прямо задан пользователем) в абсолютный адрес (физический адрес ячейки в памяти).</P><P>Формула для трансляции адреса?
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell"><I>AbsoluteAddress</I> = <I>LocalAddress</I> + <I>SegmentOffset</I></TD></TR>
</TABLE><P>Пользователь может задать регистр, который должен быть использован как сегментный, задавая его как префикс к инструкции. Если сегмент не указан, то по умолчанию используется сегмент <TT>DS</TT>.</P><P>Как префикс можно использовать регистры общего назначения и сегментные регистры. Невозможно использовать число как сегментный префикс. Вот несколько разных примеров синтаксиса для чтения из памяти:
</P><PRE CLASS="verbatim">MOV EAX,#EBX      //Адрес: DS+EBX
MOV EAX,ES:#EBX   //Адрес: ES+EBX
MOV EAX,[EBX]     //Адрес: DS+EBX
MOV EAX,[ES:EBX]  //Адрес: ES+EBX
MOV EAX,[ES+EBX]  //Адрес: ES+EBX

MOV EAX,EBX:ECX   //Адрес: EBX+ECX
MOV EAX,[EBX+ECX] //Адрес: EBX+ECX
MOV EAX,[EBX:100] //Адрес: EBX+100
MOV EAX,[100:EBX] //Неправильный синтаксис
</PRE><P>Можно использовать сегментные префиксы для быстрого доступа к массивам данных, если использовать префикс как указатель на массив:
</P><PRE CLASS="verbatim">MOV ES,ArrayStart
MOV EAX,ES:#0 //EAX = 10
MOV EBX,ES:#2 //EBX = 30
MOV ECX,ES:#1 //ECX = 50

MOV EAX,0
MOV EBX,EAX:#ArrayStart //EBX = 10
INC EAX
MOV EBX,EAX:#ArrayStart //EBX = 50
INC EAX
MOV EBX,EAX:#ArrayStart //EBX = 30

ArrayStart: db 10,50,30
</PRE><P>Некоторые сегментные регистры используются процессором для особых целей, см. таблицу:</P><P>


</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Регистр</TD><TD VALIGN=top ALIGN=center NOWRAP>Название</TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>Сегмент кода</TD><TD VALIGN=top ALIGN=left>Код запускаеться из этого сегмента</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>SS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>Сегмент данных</TD><TD VALIGN=top ALIGN=left>Сегмент данных по умолчанию</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>DS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>Сегмент стека</TD><TD VALIGN=top ALIGN=left>Сегмент в котором хранится стек</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>ES</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>Доп. сегмент</TD><TD VALIGN=top ALIGN=left>Пользовательский сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>GS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>G-сегмент</TD><TD VALIGN=top ALIGN=left>Пользовательский сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>FS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>F-сегмент</TD><TD VALIGN=top ALIGN=left>Пользовательский сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>KS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>Ключевой сегмент</TD><TD VALIGN=top ALIGN=left>Пользовательский сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>LS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>L-сегмент</TD><TD VALIGN=top ALIGN=left>Пользовательский сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Все сегментные регистры кроме <TT>CS</TT> можно задавать напрямую инструкцией <TT>MOV</TT>. Единственный способ изменить регистр <TT>CS</TT> это выполнить инструкцию <TT>CALLF</TT> или <TT>JMPF</TT> (см. стр <A HREF="#branching">??</A>):
</P><PRE CLASS="verbatim">//CS = 0
//IP = 928

JMPF 500,100;

//CS = 100
//IP = 500
</PRE><P>Если попытаться напрямую задать регистр <TT>CS</TT> то будет вызвана ошибка <TT>13:1</TT> (общая ошибка процессора). Например:
</P><PRE CLASS="verbatim">MOV DS,100
MOV ES,KS
MOV CS,1000 //Вызовет прерывание 13:1
</PRE><P>После сброса процессора все сегментные регистры будут сброшены в <TT>0</TT>.</P><!--TOC section Модели памяти-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">1.7</A>  Модели памяти</H2><!--SEC END --><P>
Процессор ZCPU поддерживает несколько разных моделей памяти. По умолчанию используется режим линейной адресации памяти, и в этом режиме находиться процессор при его старте.</P><P>Разные модели памяти требуют разного использования регистров, и дают разные возможности по выполнению кода. Большинство режимов требует включенного расширенного режима процессора для получения функций расширенной защиты памяти, задания прав доступа к страницам, отображения памяти.</P><P>Важно знать как именно происходит доступ к памяти. При обращении к памяти процессора происходят такие операции:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	Проверка регистра <TT>BusLock</TT> (отключение шины)
	</LI><LI CLASS="li-enumerate">Проверка адреса - адрес должен быть 48-битным целым числом.
	</LI><LI CLASS="li-enumerate">Прочитать страницу, которая соответствует данному адресу.
	</LI><LI CLASS="li-enumerate">Если включен флаг <TT>EF</TT> (расширенный режим), то проверить что-бы текущий уровень доступа был меньше или равен уровня доступа страницы, к которой идёт обращение, и проверить флаги прав доступа страницы.
	</LI><LI CLASS="li-enumerate">Если у страницы выставлен флаг <TT>Override</TT> то войти в соответствующий режим перехвата обращения к памяти.
	</LI><LI CLASS="li-enumerate">Если у страницы выставлен флаг <TT>Remapped</TT> то правильно обработать отображение страницы в памяти.
	</LI><LI CLASS="li-enumerate">Выполнить операцию ввода/вывода.
</LI></OL><!--TOC subsection Режим линейной адресации-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.7.1  Режим линейной адресации</H3><!--SEC END --><P>
Это модель памяти по умолчанию, когда все сегментные регистры равны <TT>0</TT>. Этот режим доступен сразу после запуска процессора. Поскольку все сегментные регистры равны нулю, то стек, данные, и код будут находиться в одном и том-же адресном пространстве.</P><P>В этом режиме не нужны сегментные префиксы. Например, можно напрямую обращаться к стеку:</P><PRE CLASS="verbatim">MOV EAX,#0  //EAX будет равен 14 (номер инструкции MOV)
MOV #ESP,100 //Тоже PUSH 100
DEC ESP
POP EAX     //EAX будет равен 100
</PRE><!--TOC subsection Режим сегментированой адресации-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.7.2  Режим сегментированой адресации</H3><!--SEC END --><P>
В этом режиме адресации сегментные регистры используются для указания отдельных блоков для стека, данных, и кода. У такого подхода есть некоторые преимущества:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Позволяет предотвратить случайное повреждение данных/кода
</LI><LI CLASS="li-itemize">Один и тот-же код может использоваться для разных блоков данных
</LI><LI CLASS="li-itemize">Программы могут запускаться в локальном адресном пространстве
</LI></UL><P>Example:
</P><PRE CLASS="verbatim">MOV DS,1000 //Установить первый блок данных
MOV SS,2000 //Установить первый блок стека
CALLF 0,500 //Вызвать подпрограмму (CS установлен в 500, IP в 0)

MOV DS,3000 //Установить второй блок данных
MOV SS,4000 //Установить второй блок стека
CALLF 0,500 //Вызвать ту-же подпрограмму, но с другим блоком данных
</PRE><P>Это запустит туже подпрограмму (по физическому адресу <TT>500</TT>) используя два разных набора данных, то есть одна и та же подпрограмма может быть использована дважды для разных наборов переменных.</P><!--TOC subsection Режим отображённой памяти-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.7.3  Режим отображённой памяти</H3><!--SEC END --><P>
Режим отображённой памяти использует возможности отображения памяти процессором для переназначения физических адресов которым соответствуют страницы. Это даёт возможность создать видимость одного целостного адресного пространства у каждого приложения. Это даёт возможность приложениям выделять блоки памяти, которые будут дополнены к адресному пространству.</P><P>См. стр <A HREF="#paging">??</A> для более детальной информации о возможностях процессора по отображению памяти.</P><!--TOC section Стек-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">1.8</A>  Стек</H2><!--SEC END --><P> <A NAME="stack"></A>
В процессор Zyelios CPU встроен аппаратный стек для значений, который физически находится в памяти процессора. Состояние стека описывается состоянием стекового указателя <TT>ESP</TT>, который указывает на следующую свободную ячейку памяти в стеке, регистра указывающего размер стеке (<TT>ESZ</TT>) и стекового сегментного регистра (<TT>SS</TT>).</P><P><TT>ESP</TT> указывает на <EM>следующую свободную ячейку стека</EM>. Значения на стеке располагаются в последовательности уменьшения их адресов в памяти.</P><P>Для занесения и получения значений со стека используются инструкции <TT>PUSH</TT> и <TT>POP</TT> соответственно. При возникновении переполнения или недостатка стека будет вызвано прерывание <TT>6:ESP</TT> (ошибка стека). Параметром прерывания будет <TT>ESP</TT>. Например:</P><PRE CLASS="verbatim">MOV SS,5000   //Стек начинается по адресу 5000
MOV ESP,2999  //И будет 3000 байт в размере
              //Следующим свободным адресом на стеке будет 2999
CPUSET 9,3000 //Установить регистр ESZ (размер стека)

PUSH 200
PUSH 100
POP EAX //EAX = 100
POP EBX //EBX = 200

//Инструкция PUSH X это тоже самое что:
MOV SS:#ESP,X
DEC ESP

//Инструкция POP Y это тоже самое что:
INC ESP
MOV Y,SS:#ESP
</PRE><P>Также можно использовать инструкции <TT>RSTACK</TT> и <TT>SSTACK</TT> для записи/чтения в произвольное место на стеке. Эти инструкции могут вызвать прерывания, которые сигнализируют ошибку стека. Вот пример использования этих инструкций:</P><PRE CLASS="verbatim">RSTACK X,Y //X = MEMORY[SS+Y]
SSTACK X,Y //MEMORY[SS+X] = Y

RSTACK EAX,ESP:1 //Прочитать значение на вершине стека
RSTACK EAX,ESP:2 //Прочитать значение под вершиной

PUSH 100 //
PUSH 200 //Значение под вершиной
PUSH 300 //Значение на вершине

SSTACK ESP:2,123 //Установить значение под вершиной стека
POP EAX //EAX = 300
POP EBX //EBX = 123
POP ECX //ECX = 100
</PRE><!--TOC section Подпрограммы-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">1.9</A>  Подпрограммы</H2><!--SEC END --><P> <A NAME="branching"></A>
Zyelios CPU поддерживает несколько способов изменения течения программы: условные и безусловные переходы, абсолютные и относительные. Указатель на инструкцию (<TT>IP</TT>) указывает на инструкцию, которая сейчас выполняется. Все инструкции перехода меняют значение <TT>IP</TT>; некоторые также меняют значение сегмента <TT>CS</TT> (см. стр <A HREF="#segments">??</A>).</P><P>Самый простой тип переходов это абсолютный безусловный переход. Для того, что-бы его выполнить необходимо использовать инструкции <TT>JMP</TT> или <TT>JMPF</TT> (последняя также меняет <TT>CS</TT>).</P><P>Подпрограммы могут быть вызваны используя инструкции <TT>CALL</TT> или <TT>CALLF</TT>. Это сохранит текущий указатель инструкции (и также <TT>CS</TT> если используется <TT>CALLF</TT>) на стек процессора. Указатель инструкции (и сегмент кода) могут быть восстановлены со стека используя инструкции <TT>RET</TT> и <TT>RETF</TT> соответственно.</P><P>Вот пример для иллюстрации переходов и подпрограмм:</P><PRE CLASS="verbatim">JMPF MAIN,CODE_SEGMENT //Синтаксис JMPF IP,CS

......

MAIN: //Метка
  CALL SUBROUTINE
  JMP EXIT

SUBROUTINE:
  CALL SUBROUTINE2
RET //Выход из подпрограммы

SUBROUTINE2: //Вызвано внутри подпрограммы SUBROUTINE
  ... код ...
RET
......

EXIT:
</PRE><P>Также возможно совершать относительные переходы. Для этого используется инструкция <TT>JMPR</TT> (jump relative). Эта инструкция прибавляет или отнимает от значения <TT>IP</TT> некоторое число. Например:</P><PRE CLASS="verbatim">JMPR +10 //Перейти на 10 байт вперёд
JMPR -10 //Перейти на 10 байт назад

JMPR LABEL-__PTR__ //Перейти к метке
                   //Метка __PTR__ указывает на текущий адрес инструкции

......

LABEL:
</PRE><P>Условные переходы позволяют менять течение программы в зависимости от выполнения разных условий. Инструкция <TT>CMP</TT> используется для сравнения двух значений, и затем можно вызвать одну из указанных инструкций:</P><P>


</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Инструкция</TD><TD VALIGN=top ALIGN=center NOWRAP>Операция</TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt;&gt; Y</TD><TD VALIGN=top ALIGN=left>Переход если не равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNZ</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X - Y &lt;&gt; 0</TD><TD VALIGN=top ALIGN=left>Переход если не ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JG</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &gt; Y</TD><TD VALIGN=top ALIGN=left>Переход если больше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNLE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &lt;= Y</TD><TD VALIGN=top ALIGN=left>Переход если не меньше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JGE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &gt;= Y</TD><TD VALIGN=top ALIGN=left>Переход если больше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNL</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &lt; Y</TD><TD VALIGN=top ALIGN=left>Переход если не меньше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JL</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt; Y</TD><TD VALIGN=top ALIGN=left>Переход если меньше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNGE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &gt;= Y</TD><TD VALIGN=top ALIGN=left>Переход если не больше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JLE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt;= Y</TD><TD VALIGN=top ALIGN=left>Переход если меньше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNG</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &gt; Y</TD><TD VALIGN=top ALIGN=left>Переход если не больше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X = Y</TD><TD VALIGN=top ALIGN=left>Переход если равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JZ</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X - Y = 0</TD><TD VALIGN=top ALIGN=left>Переход если ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>CNE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt;&gt; Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если не равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CNZ</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X - Y &lt;&gt; 0</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если не ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CG</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &gt; Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если больше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CNLE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &lt;= Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если не меньше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CGE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &gt;= Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если больше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CNL</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &lt; Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если не меньше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CL</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt; Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если меньше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CNGE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &gt;= Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если не больше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CLE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt;= Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если меньше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CNG</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &gt; Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если не больше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X = Y</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CZ</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X - Y = 0</TD><TD VALIGN=top ALIGN=left>Вызов подпрограммы если ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>JNER</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt;&gt; Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если не равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNZR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X - Y &lt;&gt; 0</TD><TD VALIGN=top ALIGN=left>Относительный переход если не ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JGR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &gt; Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если больше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNLER</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &lt;= Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если не меньше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JGER</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &gt;= Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если больше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNLR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &lt; Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если не меньше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JLR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt; Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если меньше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNGER</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &gt;= Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если не больше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JLER</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X &lt;= Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если меньше or равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JNGR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>NOT X &gt; Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если не больше чем</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JER</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X = Y</TD><TD VALIGN=top ALIGN=left>Относительный переход если равно</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>JZR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>X - Y = 0</TD><TD VALIGN=top ALIGN=left>Относительный переход если ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Существуют и другие инструкции, которые производят проверку условий, например <TT>BIT</TT>, которая тестирует состояние битов числа. Например:</P><PRE CLASS="verbatim">CMP EAX,EBX
JG  LABEL1 //Переход если EAX &gt;  EBX
JLE LABEL2 //Переход если EAX &lt;= EBX
JE  LABEL3 //Переход если EAX  = EBX
CL  LABEL4 //Вызов подпрограммы если EAX &lt;  EBX
CGE LABEL5 //Вызов подпрограммы если EAX &gt;= EBX

BIT EAX,4 //Test 5th bit of EAX
JZ  LABEL1 //Переход если 5th bit is 0
JNZ LABEL1 //Переход если 5th bit is 1
</PRE><!--TOC section Коды ошибок процессора-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">1.10</A>  Коды ошибок процессора</H2><!--SEC END --><P><A NAME="errorcodes"></A>
Есть несколько разных кодов ошибок, которые может сгенерировать процессор во время исполнения. При возникновении происходит прерывание по номеру ошибки.</P><P>Если процессор не в расширенном режиме, то выполнение кода прекращается когда возникает ошибка. При этом он выдаст код об ошибке на вывод <TT>ERROR</TT>. В расширенном режиме процессор попытается вызвать обработчик прерывания, который соответствует этой ошибке.</P><P>Например, для обычной ошибки памяти код на выходе может быть <TT>7.65536</TT> (ошибка по адресу 65536).</P><P>Вывод кода ошибки будет сброшен в ноль при сбросе состояния процессора.</P><P>В процессоре есть такие коды ошибок:</P><P>


</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Номер</TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>2</TD><TD VALIGN=top ALIGN=left>Конец выполнения программы</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>3</TD><TD VALIGN=top ALIGN=left>Деление на ноль</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>4</TD><TD VALIGN=top ALIGN=left>Неизвестная инструкция</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>5</TD><TD VALIGN=top ALIGN=left>Внутренняя ошибка процессора</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>6</TD><TD VALIGN=top ALIGN=left>Ошибка стека (переполнение/недополнение)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>7</TD><TD VALIGN=top ALIGN=left>Ошибка записи/чтения памяти</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>8</TD><TD VALIGN=top ALIGN=left>Ошибка шины памяти</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>9</TD><TD VALIGN=top ALIGN=left>Ошибка доступа записи (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>10</TD><TD VALIGN=top ALIGN=left>Ошибка записи/чтения порта</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>11</TD><TD VALIGN=top ALIGN=left>Ошибка доступа к странице (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>12</TD><TD VALIGN=top ALIGN=left>Ошибка доступа чтения (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>13</TD><TD VALIGN=top ALIGN=left>Общая ошибка процессора</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>14</TD><TD VALIGN=top ALIGN=left>Ошибка исполнения (защита страницы памяти)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>15</TD><TD VALIGN=top ALIGN=left>Выход за пределы адресного пространства</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>17</TD><TD VALIGN=top ALIGN=left>Ограничение количества инструкций (<EM>только GPU</EM>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>23</TD><TD VALIGN=top ALIGN=left>Ошибка чтения строки (<EM>только GPU</EM>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Окончание выполнения программы (02)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.1  Окончание выполнения программы (02)</H3><!--SEC END --><P>
<B>Сообщение</B>: Обнаружена инструкция STOP<BR>
<B>Возникает когда</B>: Выполнена операция <TT>STOP</TT><BR>
<B>Причина</B>: Ненормальное завершение работы программы<BR>
<B>Следствие</B>: Отключение процессора<BR><BR>
<B>Сообщение</B>: Неизвестная инструкция<BR>
<B>Возникает когда</B>: Выполняется любая из инструкций перехода (<TT>JMP</TT>, <TT>CALL</TT>, и т.п.)<BR>
<B>Причина</B>: Переход по адресу, который не указывает на корректную инструкцию процессора<BR>
<B>Следствие</B>: Отключение процессора<BR><BR>
</P><!--TOC subsection Деление на ноль (03)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.2  Деление на ноль (03)</H3><!--SEC END --><P>
<B>Сообщение</B>: Невозможно поделить на ноль<BR>
<B>Возникает когда</B>: Второй операнд в инструкции <TT>DIV</TT> нулевой<BR>
<B>Причина</B>: Ошибка в коде<BR>
<B>Следствие</B>: <TT>LADD = 0</TT><BR><BR>
<B>Сообщение</B>: Невозможно найти инверсию нуля<BR>
<B>Возникает когда</B>: Инструкция <TT>FINV</TT> вызвана с нулевым операндом<BR>
<B>Причина</B>: Ошибка в коде<BR>
<B>Следствие</B>: <TT>LADD = 1</TT><BR><BR>
</P><!--TOC subsection Неизвестная инструкция (04)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.3  Неизвестная инструкция (04)</H3><!--SEC END --><P>
<B>Сообщение</B>: Обнаружена неизвестная инструкция в потоке выполнения<BR>
<B>Возникает когда</B>: Инструкция, которая выполняется процессором не есть известной инструкцией<BR>
<B>Причина</B>: Неверное использование инструкций перехода (попытка выполнить данные как код)0<BR>
<B>Следствие</B>: <TT>LADD = номер инструкции</TT><BR><BR>
</P><!--TOC subsection Внутренняя ошибка процессора (05)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.4  Внутренняя ошибка процессора (05)</H3><!--SEC END --><P>
<B>Сообщение</B>: Невозможно выполнить инструкцию (ошибка в микрокоде)<BR>
<B>Возникает когда</B>: Произошла внутренняя ошибка при выполнении микрокода инструкции<BR>
<B>Причина</B>: Ошибка в логике процессора<BR>
<B>Следствие</B>: <TT>LADD = 01</TT><BR><BR>
<B>Сообщение</B>: Неизвестная внутренняя ошибка<BR>
<B>Возникает когда</B>: Никогда<BR>
<B>Причина</B>: Нету<BR>
<B>Следствие</B>: <TT>LADD = 02</TT><BR><BR>
<B>Сообщение</B>: Ошибка чтения при декодировании инструкции<BR>
<B>Возникает когда</B>: Декодер инструкций не смог получить все нужные байты<BR>
<B>Причина</B>: Переход за пределы физической/логической памяти<BR>
<B>Следствие</B>: <TT>LADD = 12</TT><BR><BR>
<B>Сообщение</B>: Ошибка чтения байта первого операнда<BR>
<B>Возникает когда</B>: Декодер инструкций не смог получить все нужные байты<BR>
<B>Причина</B>: Переход за пределы физической/логической памяти<BR>
<B>Следствие</B>: <TT>LADD = 22</TT><BR><BR>
<B>Сообщение</B>: Ошибка чтения байта второго операнда<BR>
<B>Возникает когда</B>: Декодер инструкций не смог получить все нужные байты<BR>
<B>Причина</B>: Переход за пределы физической/логической памяти<BR>
<B>Следствие</B>: <TT>LADD = 32</TT><BR><BR>
<B>Сообщение</B>: Неправильный селектор RM для первого операнда<BR>
<B>Возникает когда</B>: Никогда<BR>
<B>Причина</B>: Нету<BR>
<B>Следствие</B>: <TT>LADD = 42</TT><BR><BR>
<B>Сообщение</B>: Неправильный селектор RM для второго операнда<BR>
<B>Возникает когда</B>: Никогда<BR>
<B>Причина</B>: Нету<BR>
<B>Следствие</B>: <TT>LADD = 52</TT><BR><BR>
<B>Сообщение</B>: Невозможно записать в первый операнд<BR>
<B>Возникает когда</B>: Никогда<BR>
<B>Причина</B>: Нету<BR>
<B>Следствие</B>: <TT>LADD = 62</TT><BR><BR>
<B>Сообщение</B>: Невозможно записать во второй операнд (только для <TT>XCHG</TT>)<BR>
<B>Возникает когда</B>: Никогда<BR>
<B>Причина</B>: Нету<BR>
<B>Следствие</B>: <TT>LADD = 72</TT><BR><BR>
<B>Сообщение</B>: Неизвестная инструкция<BR>
<B>Возникает когда</B>: Никогда<BR>
<B>Причина</B>: Нету<BR>
<B>Следствие</B>: <TT>LADD = 82</TT><BR><BR>
</P><!--TOC subsection Ошибка стека (06)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.5  Ошибка стека (06)</H3><!--SEC END --><P>
<B>Сообщение</B>: Ошибка переполнения стека<BR>
<B>Возникает когда</B>: Выполнена инструкция <TT>PUSH</TT><BR>
<B>Причина</B>: Значение регистра <TT>ESP</TT> становиться отрицательным<BR>
<B>Следствие</B>: <TT>LADD = 0</TT><BR><BR>
<B>Сообщение</B>: Ошибка недополнения стека<BR>
<B>Возникает когда</B>: Выполнена инструкция <TT>POP</TT><BR>
<B>Причина</B>: Регистр <TT>ESP</TT> становиться больше чем <TT>ESZ</TT><BR>
<B>Следствие</B>: <TT>LADD = ESZ</TT><BR><BR>
<B>Сообщение</B>: Ошибка чтения стека<BR>
<B>Возникает когда</B>: Выполнена инструкция <TT>POP</TT><BR>
<B>Причина</B>: Невозможно прочитать значение из памяти<BR>
<B>Следствие</B>: <TT>LADD = ESP</TT><BR><BR>
<B>Сообщение</B>: Выход за пределы стека<BR>
<B>Возникает когда</B>: Выполнена инструкция <TT>RSTACK</TT> или <TT>SSTACK</TT><BR>
<B>Причина</B>: Указанное значение выходит за границы стека<BR>
<B>Следствие</B>: <TT>LADD</TT> хранит ошибочный индекс<BR><BR>
</P><!--TOC subsection Ошибка записи/чтения памяти (07)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.6  Ошибка записи/чтения памяти (07)</H3><!--SEC END --><P>
<B>Сообщение</B>: Ошибка чтения: адрес не существует<BR>
<B>Возникает когда</B>: Процессор попытался прочитать значение из внешней памяти<BR>
<B>Причина</B>: К шине MemBus не подключено никакое устройство<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
<B>Сообщение</B>: Ошибка чтения: невозможно прочитать адрес из памяти<BR>
<B>Возникает когда</B>: Процессор попытался прочитать значение из внешней памяти<BR>
<B>Причина</B>: Произошла ошибка при чтении значения из памяти внешнего устройства (или страница не доступна для чтения)<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
<B>Сообщение</B>: Ошибка записи: адрес не существует<BR>
<B>Возникает когда</B>: Процессор попытался записать значение в внешнюю память<BR>
<B>Причина</B>: К шине MemBus не подключено никакое устройство<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
<B>Сообщение</B>: Ошибка записи: невозможно записать в память по адресу<BR>
<B>Возникает когда</B>: Процессор попытался записать значение в внешнюю память<BR>
<B>Причина</B>: Произошла ошибка при записи значения в памяти внешнего устройства (или страница не доступна для чтения)<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
</P><!--TOC subsection Ошибка шины памяти (08)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.7  Ошибка шины памяти (08)</H3><!--SEC END --><P>
<B>Сообщение</B>: Ошибка устройства<BR>
<B>Возникает когда</B>: Процессор попытался прочитать значение из внешней памяти<BR>
<B>Причина</B>: Автобус сломался (bus fail): устройство подключенное к шине MemBus не поддерживает высокоскоростной интерфейс<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
<B>Сообщение</B>: Ошибка устройства<BR>
<B>Возникает когда</B>: Процессор пытается прочитать значение из порта<BR>
<B>Причина</B>: Автобус сломался (bus fail): устройство подключенное к шине IOBus не поддерживает высокоскоростной интерфейс<BR>
<B>Следствие</B>: <TT>LADD = -PORT_NUMBER</TT><BR><BR>
</P><!--TOC subsection Ошибка доступа записи (09)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.8  Ошибка доступа записи (09)</H3><!--SEC END --><P>
<B>Сообщение</B>: Ошибка доступа<BR>
<B>Возникает когда</B>: Попытка записать значение в память<BR>
<B>Причина</B>: Флаг <TT>EF</TT> установлен в 1, страница к которой происходит доступ не имеет разрешения на запись, и уровень доступа текущей страницы выше или равен уровню доступа запрашиваемой страницы<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
</P><!--TOC subsection Ошибка записи/чтения порта (10)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.9  Ошибка записи/чтения порта (10)</H3><!--SEC END --><P>
<B>Сообщение</B>: Ошибка чтения: невозможно прочитать с порта<BR>
<B>Возникает когда</B>: Процессор попытался прочитать значение с порта<BR>
<B>Причина</B>: Возникла ошибка при чтении с порта (адресу не назначено устройство)<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
<B>Сообщение</B>: Ошибка записи: невозможно записать в порт<BR>
<B>Возникает когда</B>: Процессор попытался записать значение в порт<BR>
<B>Причина</B>: Возникла ошибка при записи в порт (адресу не назначено устройство)<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
</P><!--TOC subsection Ошибка доступа к странице (11)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.10  Ошибка доступа к странице (11)</H3><!--SEC END --><P>
<B>Сообщение</B>: Невозможно сделать страницу только для чтения<BR>
<B>Возникает когда</B>: Выполнена инструкций <TT>SPG</TT><BR>
<B>Причина</B>: Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение<BR>
<B>Следствие</B>: <TT>LADD</TT> указывает на страницу, к которой идёт обращение<BR><BR>
<B>Сообщение</B>: Невозможно сделать страницу читаемой и записываемой<BR>
<B>Возникает когда</B>: Выполнена инструкций <TT>CPG</TT><BR>
<B>Причина</B>: Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение<BR>
<B>Следствие</B>: <TT>LADD</TT> указывает на страницу, к которой идёт обращение<BR><BR>
<B>Сообщение</B>: Невозможно установить флаг страницы<BR>
<B>Возникает когда</B>: Выполнена инструкций <TT>SPP</TT><BR>
<B>Причина</B>: Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение<BR>
<B>Следствие</B>: <TT>LADD</TT> указывает на страницу, к которой идёт обращение<BR><BR>
<B>Сообщение</B>: Невозможно убрать флаг страницы<BR>
<B>Возникает когда</B>: Выполнена инструкций <TT>CPP</TT><BR>
<B>Причина</B>: Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение<BR>
<B>Следствие</B>: <TT>LADD</TT> указывает на страницу, к которой идёт обращение<BR><BR>
<B>Сообщение</B>: Невозможно изменить уровень доступа страницы<BR>
<B>Возникает когда</B>: Выполнена инструкций <TT>SRL</TT><BR>
<B>Причина</B>: Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение<BR>
<B>Следствие</B>: <TT>LADD</TT> указывает на страницу, к которой идёт обращение<BR><BR>
<B>Сообщение</B>: Невозможно сменить настройки отображения страницы<BR>
<B>Возникает когда</B>: Выполнена инструкций <TT>SMAP</TT><BR>
<B>Причина</B>: Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение<BR>
<B>Следствие</B>: <TT>LADD</TT> указывает на страницу, к которой идёт обращение<BR><BR>
</P><!--TOC subsection Ошибка доступа чтения (12)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.11  Ошибка доступа чтения (12)</H3><!--SEC END --><P>
<B>Сообщение</B>: Ошибка доступа<BR>
<B>Возникает когда</B>: Попытка прочитать значение<BR>
<B>Причина</B>: Флаг <TT>EF</TT> установлен в 1, у страницы к которой идёт обращение нету прав на чтение, и уровень доступа текущей страницы превышает или равен уровню доступа страницы, с которой происходит чтение<BR>
<B>Следствие</B>: <TT>LADD</TT> равен адресу к которому произошло обращение<BR><BR>
<B>Сообщение</B>: Страница за пределами постоянной памяти<BR>
<B>Возникает когда</B>: Использование инструкции <TT>ERPG</TT><BR>
<B>Причина</B>: Страница не могла быть стёрта, поскольку она не находиться в постоянной памяти процессора<BR>
<B>Следствие</B>: <TT>LADD = 0</TT><BR><BR>
<B>Сообщение</B>: Страница за пределами постоянной памяти<BR>
<B>Возникает когда</B>: Использование инструкции <TT>WRPG</TT><BR>
<B>Причина</B>: Страница не могла быть записана, поскольку она не находиться в постоянной памяти процессора<BR>
<B>Следствие</B>: <TT>LADD = 0</TT><BR><BR>
<B>Сообщение</B>: Страница за пределами постоянной памяти<BR>
<B>Возникает когда</B>: Использование инструкции <TT>RDPG</TT><BR>
<B>Причина</B>: Страница не могла быть прочитана, поскольку она не находиться в постоянной памяти процессора<BR>
<B>Следствие</B>: <TT>LADD = 0</TT><BR><BR>
</P><!--TOC subsection Общая ошибка процессора (13)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.12  Общая ошибка процессора (13)</H3><!--SEC END --><P>
<B>Сообщение</B>: Невозможно записать сегмент кода<BR>
<B>Возникает когда</B>: Регистр <TT>CS</TT> выступает в роли операнда, в который идёт запись результата<BR>
<B>Причина</B>: Невозможно изменить сегментный регистр напрямую. Надо использовать инструкции <TT>CALLF</TT> ил <TT>JMPF</TT><BR>
<B>Следствие</B>: <TT>LADD = 1</TT><BR><BR>
<B>Сообщение</B>: Невозможно прочитать таблицу прерываний<BR>
<B>Возникает когда</B>: Не удалось получить запись из таблицы прерываний<BR>
<B>Причина</B>: Адрес таблицы, установленный инструкцией <TT>LIDTR</TT>, не указывает на корректное место в памяти<BR>
<B>Следствие</B>: <TT>LADD = 2</TT><BR><BR>
<B>Сообщение</B>: Неправильный номер прерывания<BR>
<B>Возникает когда</B>: Номер прерывания находиться за пределами границ (0..255)<BR>
<B>Причина</B>: Неправильное использование инструкций <TT>INT</TT> или <TT>EXTINT</TT><BR>
<B>Следствие</B>: <TT>LADD = 3</TT><BR><BR>
<B>Сообщение</B>: Неразрешённый вызов внешнего прерывания<BR>
<B>Возникает когда</B>: У прерывания, которое вызывается извне, нету флага который разрешает вызов этого прерывания как внешнего<BR>
<B>Причина</B>: <TT>6ой</TT> бит не выставлен в флагах прерывания при вызове его как внешнего<BR>
<B>Следствие</B>: <TT>LADD = 4</TT><BR><BR>
<B>Сообщение</B>: Несовместимый режим<BR>
<B>Возникает когда</B>: Вызов прерывания в защищённом (совместимом) режиме с менее чем 512 байт памяти<BR>
<B>Причина</B>: Недостаточно памяти для хранения таблицы прерываний<BR>
<B>Следствие</B>: <TT>LADD = 5</TT><BR><BR>
<B>Сообщение</B>: Невозможно записать данные о возврате прерывания<BR>
<B>Возникает когда</B>: Обработчик прерывания не смог записать данные о возврате на стек процессора<BR>
<B>Причина</B>: Прерывание было вызвано при недостаточном месте на стеке<BR>
<B>Следствие</B>: <TT>LADD = 6</TT><BR><BR>
<B>Сообщение</B>: Невозможно вызвать прерывание<BR>
<B>Возникает когда</B>: Прерывание вызвано с недостаточными правами<BR>
<B>Причина</B>: У обработчика прерывания недостаточно прав что-бы совершить переход<BR>
<B>Следствие</B>: <TT>LADD = 7</TT><BR><BR>
<B>Сообщение</B>: Невозможно прочитать таблицу страниц<BR>
<B>Возникает когда</B>: Таблица страниц не находиться в доступном адресном пространстве<BR>
<B>Причина</B>: Таблица страниц не находиться в доступном адресном пространстве<BR>
<B>Следствие</B>: <TT>LADD = 8</TT><BR><BR>
<B>Сообщение</B>: Выполнение привилегированной инструкции<BR>
<B>Возникает когда</B>: Невозможно выполнить инструкцию из-за прав доступа<BR>
<B>Причина</B>: Вызов одной из указанных инструкций без достаточных прав: <TT>RD</TT>, <TT>WD</TT>, <TT>SPG</TT>, <TT>CPG</TT>, <TT>STI</TT>, <TT>CLI</TT>, <TT>STP</TT>, <TT>CLP</TT>, <TT>STEF</TT>, <TT>CLEF</TT>, <TT>EXTINT</TT>, <TT>ERPG</TT>, <TT>WRPG</TT>, <TT>RDPG</TT>, <TT>LIDTR</TT>, <TT>EXTRET</TT>, <TT>IDLE</TT>, <TT>STD2</TT>, <TT>STM</TT>, <TT>CLM</TT>, <TT>CPUGET</TT>, <TT>CPUSET</TT>, <TT>CPP</TT>, <TT>SPP</TT>, <TT>SRL</TT>, <TT>GRL</TT>, <TT>SMAP</TT>, <TT>GMAP</TT><BR>
<B>Следствие</B>: <TT>LADD = Номер инструкции</TT><BR><BR>
</P><!--TOC subsection Ошибка исполнения (14)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.13  Ошибка исполнения (14)</H3><!--SEC END --><P>
<B>Сообщение</B>: Ошибка доступа<BR>
<B>Возникает когда</B>: Попытка выполнить код на странице, в которой запрещено выполнять код<BR>
<B>Причина</B>: Неправильная инструкция перехода<BR>
<B>Следствие</B>: <TT>LADD = номер страницы</TT><BR><BR>
<B>Сообщение</B>: Ошибка доступа<BR>
<B>Возникает когда</B>: Попытка выполнить код на странице, в которой запрещено выполнять код<BR>
<B>Причина</B>: Выполнение кода пересекло границу между страницами<BR>
<B>Следствие</B>: <TT>LADD = номер страницы</TT><BR><BR>
</P><!--TOC subsection Выход за пределы адресного пространства (15)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->1.10.14  Выход за пределы адресного пространства (15)</H3><!--SEC END --><P>
<B>Сообщение</B>: Выход за пределы адресного пространства<BR>
<B>Возникает когда</B>: Доступ к памяти по неправильному адресу<BR>
<B>Причина</B>: Адрес не есть 48-битным целым знаковым числом<BR>
<B>Следствие</B>: <TT>LADD = неправильный адрес</TT><BR><BR>

</P><!--TOC chapter Расширенные функции процессора-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc12">Chapter 2</A>  Расширенные функции процессора</H1><!--SEC END --><P> <A NAME="advfeatures"></A></P><!--TOC section Расширенное управление выполнением кода-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc13">2.1</A>  Расширенное управление выполнением кода</H2><!--SEC END --><P> <A NAME="advexecution"></A>
В этой секции детально описано выполнение инструкций процессором. Процессор выполняет функции последовательно, декодирует их, а затем записывает результат по нужным направлениям.</P><P>При выполнении инструкции регистр <TT>XEIP</TT> указывает на начало инструкции, и является абсолютным адресом, в то время как регистр <TT>IP</TT> увеличивается на единицу при чтении каждого следующего байта, и является относительным вокруг сегмента кода.</P><P>Процесс выполнения также увеличивает регистр <TT>TMR</TT> на количество циклов, которые заняла данная инструкция. Регистр <TT>CODEBYTES</TT> хранит полное количество байт кода которые уже были прочитаны.</P><PRE CLASS="verbatim">//TMR = 170

MOV EAX,10; //Инструкции длиной в 1 цикл
ADD EAX,EBX;

//TMR = 172
</PRE><P>Декодер инструкций устанавливает регистр <TT>CPAGE</TT> в номер текущей страницы (страница, с которой была прочитана инструкция), и регистр <TT>PPAGE</TT> в номер страницы, на которой находилась предыдущая инструкция. <EM>Текущая страница определяется положением первого байта инструкции, которая сейчас выполняется</EM>.</P><P>Когда значения <TT>CPAGE</TT> и <TT>PPAGE</TT> не равны друг-другу производиться проверка прав доступа. Выполнение перехода любого рода также вызовет подобную проверку, и сбросит значения обоих регистров <TT>CPAGE</TT> и <TT>PPAGE</TT> в номер страницы, на которую осуществлён переход.</P><P>Инструкции могут быть фиксированного, или разного размера, см. стр <A HREF="#localexec">??</A>.</P><P>Вот псевдокод декодера инструкций:</P><PRE CLASS="verbatim">// Вычислить абсолютный адрес выполняемой инструкции, установить текущую страницу
XEIP = IP + CS
SetCurrentPage(floor(XEIP/128))

// Не позволять выполнения если не внутри страницы ядра, или если
// вызов происходит не из страницы ядра
if (PCAP == 1) and (CurrentPage.Execute == 0) and 
   (PreviousPage.RunLevel &lt;&gt; 0) then
  Interrupt(14,CPAGE)
end

// Сброс флагов прерываний
INTR = 0
if NIF &lt;&gt; undefined then
  IF = NIF
  NIF = undefined
end

// Чтение инструкции и селектора RM
Opcode = Fetch()
RM = 0
isFixedSize = false

// Проверка, является ли инструкция фиксированного размера
if ((Opcode &gt;= 2000) and (Opcode &lt; 4000)) or
   ((Opcode &gt;= 12000) and (Opcode &lt; 14000)) then
  Opcode = Opcode - 2000
  isFixedSize = true
end

// Чтение селектора RM
if (OperandCount &gt; 0) or
   (Precompile_Peek() == 0) or 
   (isFixedSize) then
  RM = Fetch()
end

// Если не удалось прочитать опкод/селектор RM то сообщить об ошибке
if INTR == 1 then
  IF = 1
  Interrupt(5,12)
end

// Проверка на возможность выполнения инструкции
if (PCAP == 1) and (CurrentPage.Runlevel &gt; RunLevel[Opcode]) then
  Interrupt(13,Opcode)
end

// Декодирование селектора RM
dRM2 = floor(RM / 10000)
dRM1 = RM - dRM2*10000

// Сегментные префиксы по умолчанию (DS)
Segment1 = -4
Segment2 = -4

// Декодирование сегментных префиксов
if Opcode &gt; 1000 then
  if Opcode &gt; 10000 then
    Segment2 = Fetch()

    Opcode = Opcode-10000
    if Opcode &gt; 1000 then
      Segment1 = Fetch()
      
      Opcode = Opcode-1000
      Segment1 &lt;&gt; Segment 2
    else
      if isFixedSize then
        Fetch()
      end
    end
  else
    Segment1 = Fetch()
    Opcode = Opcode-1000
    if isFixedSize then
      Fetch()
    end
  end
elseif isFixedSize then
  Fetch()
  Fetch()
end

// Если не удалось прочитать сегментные префиксы, сообщить об ошибке
if INTR == 1 then
  Interrupt(5,12)
end

// Проверка на правильность номера инструкции
if opcode is not valid then
  Interrupt(4,Opcode)
else
  // Прочитать дополнительные байты, если нужно
  if isFixedSize then
    OperandByte1 = Fetch()
    if INTR == 1 then 
      Interrupt(5,22)
    end
    OperandByte2 = Fetch()
    if INTR == 1 then 
      Interrupt(5,32)
    end
  else
    if OperandCount &gt; 0 then
      if NeedFetchByte1 then
        OperandByte1 = Fetch()
        if INTR == 1 then 
          Interrupt(5,22)
        end
      end
      if OperandCount &gt; 1 then
        if NeedFetchByte2 then
          OperandByte2 = Precompile_Fetch() or 0
          if INTR == 1 then
            Interrupt(5,32)
          end
        end
      end
    end
  end
  
  // Выполнить инструкцию
  Execute()

  // Записать результат назад, если нужно
  if OperandCount &gt; 0 then
    WriteBack(1)
    if OperandCount &gt; 1 then
      WriteBack(2)
    end
  end
end

// Обновить таймера и счётчики
CODEBYTES = CODEBYTES + Instruction_Size
TMR = TMR + Instrucion_Cycles
TIMER = TIMER + TimerDT

// Установить страницу как предыдущую
XEIP = IP + CS
SetPreviousPage(floor(XEIP/128))  
</PRE><!--TOC section Система страниц-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc14">2.2</A>  Система страниц</H2><!--SEC END --><P> <A NAME="paging"></A>
Процессор Zyelios CPU разделяет всю доступною память в страницы. Каждая страница имеет 128 байт в размере. Страницы нумеруются последовательно начиная с нуля, тоесть адреса 0 .. 127 принадлежат первой странице, 128 .. 255 второй, и так далее.</P><P>Каждая страница имеет собственную маску прав (т.е. возможность разрешения/запрета записи, чтения, выполнения) и уровень доступа.</P><P>Уровень доступа это число, которое используется для присвоения коду разных уровней доступа. Высокий уровень доступа соответствует коду уровня ядра, а нижние уровни доступа соответствуют коду пользователя. Уровень доступа - число между 0 и 255 включительно, и более высоким уровнем доступа есть тот, у которого меньшее число, ему присвоенное. Например уровень доступа 3 имеет больше прав чем уровень доступа 6.</P><P>Код, запускаемый из страницы с более низким уровнем доступа (т.е. большими правами) может читать и писать страницы более высокого уровня, но не наоборот.</P><PRE CLASS="verbatim">SRL 1,12 //Установить уровень доступа страницы 1 в 12
//Страница 1 соответствует адресам 128..255

SPP 5,0 //Сделать страницу 5 читаемой
CPP 6,1 //Сделать страницу 6 не записываемой
CPP 7,2 //Предотвратить выполнение кода на странице 7
</PRE><P>Уровень доступа 0 - особый уровень, который обходит все проверки прав доступа. На этом уровне также допустимо использование некоторых привилегированных инструкций, например <TT>CPUSET</TT>. Все остальные уровни доступа подчиняются проверкам прав.</P><P>Если страница помечена как не читаемая, то её можно прочитать только со страницы с более низким уровнем (более высокими правами), аналогично для записи. Если страница помечена как запрещённая к выполнению, то на неё можно перейти только с уровня доступа 0.</P><P>Каждую страницу можно отобразить в другую страницу памяти. Это значит, что каждый раз как процессор будет пытаться писать или читать в эту страницу, данные на самом деле будут прочитаны с отображённой страницы. Любая страница может быть отображена.</P><PRE CLASS="verbatim">MOV #130,1234 //Установить ячейку 2 страницы 1 в 1234
SMAP 0,1 //Отобразить страницу 0 в страницу 1
MOV EAX,#2 //Прочитать ячейку 2 страницы 0 (но на самом деле прочитать со страницы 1)
//EAX теперь равен 1234
</PRE><P>Настройки отображения и прав доступа хранятся в <EM>таблице страниц</EM>. Таблица страниц активна когда процессор находиться в режиме расширенной работы с памятью (флаг <TT>MF</TT> установлен в 1). Если флаг обнулён, то таблица страниц будет храниться внутри процессора. При этом проверки доступа производятся лишь кода процессор находиться в расширеном режиме (флаг <TT>EF</TT>).</P><P>Внутренний регистр <TT>PTBL</TT> хранит <EM>абсолютный</EM> указатель на начало таблицы страниц, а в регистре <TT>PTBE</TT> записано количество записей в таблице. Есть возможность менять таблицу прямо во время выполнения программы.</P><P>Каждая запись в таблице имеет 2 байта в размере. Первая запись (запись номер 0) это страница по умолчанию. Все остальные записи в таблице соответствуют страницам памяти.</P><P>Если адрес, к которому идёт обращение, не имеет соответствующей записи для страницы, на которой он находиться, то он будет использовать права и флаги, которые заданы страницей по умолчанию (нулевой записью в таблице страниц). При этом будет не доступно отображение в память.</P><P>Первый байт записи хранит флаги страницы и её уровень доступа. Второй байт хранит номер страницы, в которую эта страница должна быть отображена. Флаги доступа в записи страницы <EM>инвертированы</EM>, то есть 1 значит запрет, а 0 значит разрешение.</P><P>Вот пример настройки таблицы страниц:
</P><PRE CLASS="verbatim">PageTable:
  alloc 513*2 //512 записей страниц + страница по умолчанию (64КБ памяти)
  
  .....
  
//Установить таблицу страниц
CPUSET 37,PageTable //PTBL
CPUSET 38,512 //PTBE

//Включить режим расширенной памяти
STM

//Непрямая работа с таблицей
SMAP 0,1 //Отобразить страницу 0 в 1
SPP 5,0 //Установить флаг страницы 5

//Прямое обращение к таблицу
MOV ESI,PageTable; //Сдвиг таблицы
MOV ESI:#0,0xE0; //Установить разрешения для страницы по умолчанию
MOV ESI:#2,1; //Отключить страницу 0
MOV ESI:#5,10; //Отобразить страницу 1 в 10
</PRE><P>Первый байт записи в таблице:</P><P>


</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Бит</TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>00</TT></TD><TD VALIGN=top ALIGN=left>Отключена ли страница? 1 если это так</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>01</TT></TD><TD VALIGN=top ALIGN=left>Отображена ли страница? 1 если это так</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>02</TT></TD><TD VALIGN=top ALIGN=left>Страница генерирует внешнее прерывание 30 при обращении</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>03</TT></TD><TD VALIGN=top ALIGN=left>Страница генерирует внешние прерывания 28, 29</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>04</TT></TD><TD VALIGN=top ALIGN=left>Зарезервированный бит</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>05</TT></TD><TD VALIGN=top ALIGN=left>Доступ на чтение (0: разрешено, 1: запрещено)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>06</TT></TD><TD VALIGN=top ALIGN=left>Доступ на запись (0: разрешено, 1: запрещено)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>07</TT></TD><TD VALIGN=top ALIGN=left>Доступ на выполнение (0: разрешено, 1: запрещено)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>08..15</TT></TD><TD VALIGN=top ALIGN=left>Уровень доступа</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Отключенные страницы будут вызывать ошибку памяти при попытке чтения любого адреса в них находящегося (так будто бы эта страница не находилась в адресном пространстве процессора). Отображённые страницы используют второй байт как номер <EM>физической</EM> страницы, в которую происходит отображение.</P><P>Возможно отлавливать доступ к странице используя биты 2 и/или 3. Это будет вызывать внешние прерывания 28 (чтение), 29 (запись), 30 (доступ) каждый раз, когда идёт обращение к странице. Номер страницы, к которой идёт доступ будет передан как параметр (для прерывания 30), и сохранён адрес обращения. Это можно использовать для переопределения операций чтения/записи (см. стр <A HREF="#memoverride">??</A> для более подробной информации).</P><P>При обработке прерываний используется специальное правило. Права на вызов прерываний определяются уровнем доступа таблицы прерываний. Это значит что можно ограничить пользовательскую программу от вызова конкретных прерываний. Это работает будто-бы вызов происходил с помощью инструкции <TT>CALL</TT> с адреса, на котором находиться прерывание. Это даёт возможность использовать прерывания для интерфейса между двумя частями кода с разными правами доступа.</P><PRE CLASS="verbatim">STEF //Включить расширенный режим
LIDTR 2048 //Таблица прерываний на страницах 16-23

SRL 16,0 //Установить уровень доступа прерываний 0..31 в 0
SRL 17,1 //Установить уровень доступа прерываний 32..63 в 1
SRL 18,2 //Установить уровень доступа прерываний 64..95 в 2
SRL 19,3 //Установить уровень доступа прерываний 96..127 в 3
</PRE><P>Текущая страница при выполнении инструкций определяется регистром <TT>CPAGE</TT>. <EM>Вообще текущая страница определяется только положением первого байта инструкции, которая сейчас выполняется</EM>. Система страниц производит проверки когда регистр <TT>PPAGE</TT> (значение <TT>CPAGE</TT> для предыдущей инструкции) не совпадает по значению с <TT>CPAGE</TT> (т.е. происходит переход через границу страниц).</P><P>Любой переход также вызовет подобную проверку, и сбросит значения регистров <TT>CPAGE</TT> и <TT>PPAGE</TT> в номер новой страницы.</P><P>Пересечь границу между страницами, или совершить прямой переход, возможно лишь если флаги следующей страницы (целевой страницы перехода) позволяют выполнение кода на той странице, либо если предыдущая страница имеет нулевой уровень доступа.</P><P>Весь внешний доступ к памяти процессора через его шину будет производить проверки чтения/записи. Уровень доступа для внешних операций ввода/вывода определяется регистром <TT>XTRL</TT> (внешний уровень доступа). По умолчанию все внешние операции имеют уровень доступа 0.</P><P>Что-бы подытожить, вот те проверки, которые производятся системой страниц (но только в расширенном режиме):
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
	Проверка перехода границ страницы
	</LI><LI CLASS="li-itemize">Проверка при прямом переходе по адресу
</LI><LI CLASS="li-itemize">Проверки на права доступа к таблице прерываний
	</LI><LI CLASS="li-itemize">Доступ к памяти на чтение/запись
	</LI><LI CLASS="li-itemize">Внешний доступ к памяти/шине процессора
	</LI><LI CLASS="li-itemize">Логика отображения страниц при записи/чтении
	</LI><LI CLASS="li-itemize">Перехват доступа к странице
</LI></UL><!--TOC section Внутренняя память-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">2.3</A>  Внутренняя память</H2><!--SEC END --><P>
Для процессора Zyelios CPU можно настроить внутреннюю оперативную и постоянную память. Это позволяет сохранять программу прямо внутри процессора. Содержимое постоянной памяти будет скопировано в оперативную память при каждом сбросе состояния процессора. В постоянную память также можно программно писать, и стирать данные.</P><P>Всего есть три инструкции для работы с внутренней памятью: <TT>ERPG</TT> (стереть страницу постоянной памяти), <TT>WRPG</TT> (записать страницу постоянной памяти), <TT>RDPG</TT> (прочитать страницу постоянной памяти).</P><P>Примеры использования:
</P><PRE CLASS="verbatim">ERPG 4 //Стирает данные из постоянной памяти
WRPG 4 //Записывает страницу 4 в постоянную память
       //После сброса процессора она будет восстановлена
RDPG 4 //Восстановить страницу 4 из постоянной памяти

ORG 512 //Разместить переменные на странице 4
SOME_AREA:
 ... данные ...
</PRE><!--TOC section Побитовые операции-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc16">2.4</A>  Побитовые операции</H2><!--SEC END --><P>
ZCPU может работать с целыми числами разной ширины. Он поддерживает 8, 16, 32, и 48 битные целые числа, и имеет дополнительный набор инструкций для работы с ними: <TT>BAND</TT>, <TT>BOR</TT>, <TT>BXOR</TT>, <TT>BSHL</TT>, <TT>BSHR</TT>, <TT>BNOT</TT>. Например:
</P><PRE CLASS="verbatim">MOV  EAX,105 //1101001
BAND EAX,24  //0011000
//EAX = 8      0001000

BOR EAX,67   //1000011
//EAX = 75   //1001011

BXOR EAX,15  //0001111
//EAX = 68   //1000100

BSHL EAX,2
//EAX = 272  //100010000

BSHR EAX,4
//EAX = 17   //0010001

BNOT EAX
//EAX = -18  //111111111111111111101110
</PRE><P>Также есть дополнительные операции, которые работают с отдельными битами числа: <TT>BIT</TT>, <TT>SBIT</TT>, <TT>TBIT</TT>, <TT>CBIT</TT>.</P><P>Инструкция <TT>BIT</TT> проверяет, установлен ли данный бит числа. Проверить результат этой операции можно используя условный переход:
</P><PRE CLASS="verbatim">MOV EAX,105
BIT EAX,0
JNZ LABEL //Переход удался, если бит не нулевой

BIT EAX,1
JNZ LABEL //Переход не удался, если бит нулевой
</PRE><P>Инструкции <TT>SBIT</TT> и <TT>CBIT</TT> выставляют или убирают определённый бит числа. Инструкция <TT>TBIT</TT> меняет этот бит на противоположный:
</P><PRE CLASS="verbatim">MOV EAX,105 //1101001
SBIT EAX,1
//EAX = 107   1101011

CBIT EAX,6
//EAX = 43    0101011

TBIT EAX,0
//EAX = 42    0101010
</PRE><!--TOC section Поддержка блоков в памяти-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">2.5</A>  Поддержка блоков в памяти</H2><!--SEC END --><P>
Некоторые инструкции процессора поддерживают инструкцию <TT>BLOCK</TT>, которая выполняется перед выполнением нужной инструкции. Она используется для указания блока, над которым будет действовать следующая инструкция, например можно задать права для целого блока памяти сразу:
</P><PRE CLASS="verbatim">BLOCK 1024,8192 //8-килобайтовый блок начиная с адреса 1024
SRL 0,4 //Выставить уровень доступа всего блока в 4
</PRE><P>Первый операнд инструкции <TT>BLOCK</TT> указывает на абсолютное смещение в памяти с которого начинается блок (должен быть выровнен по краю страницы если используется для инструкций, которые работают со страницами), а второй операнд указывает на размер блока (если используется для работы со страницами, то размер тоже должен быть кратный размеру страницы).</P><P>Инструкция <TT>BLOCK</TT> выставляет два внутренних регистра <TT>BlockStart</TT>, <TT>BlockSize</TT>. После выполнения инструкции, которая поддерживает выставление блоков это регистры будут сброшены обратно в 0.</P><P>Размер блока должен быть отличным от нуля, иначе инструкция не будет действовать.</P><P><EM>Есть возможность возникновения прерывания между инструкцией </EM><EM><TT>BLOCK</TT></EM><EM> и другой инструкцией</EM>. Поэтому желательно не использовать инструкцию <TT>BLOCK</TT> внутри обработчика прерывания, поскольку его состояние восстановлено не будет.</P><P>Данные инструкции поддерживают этот префикс: <TT>SPP</TT>, <TT>CPP</TT>, <TT>SRL</TT>, <TT>SMAP</TT>.</P><!--TOC section Копирование, сдвиг, обмен больших блоков данных-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc18">2.6</A>  Копирование, сдвиг, обмен больших блоков данных</H2><!--SEC END --><P>
(MCOPY, MSHIFT, MXCHG)</P><!--TOC section Поддержка стекового кадра-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">2.7</A>  Поддержка стекового кадра</H2><!--SEC END --><P>
(using EBP register, and ENTER/LEAVE opcodes)</P><!--TOC section Прерывания/расширенный режим-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc20">2.8</A>  Прерывания/расширенный режим</H2><!--SEC END --><P> <A NAME="advancedinterrupts"></A>
If an interrupt occurs while reading or writing to memory pointer specified by the operand the operation will ???.</P><P>The processor interrupt handler performs a variety of checks before turning the control over back to the execution.</P><P>The interrupt handler is fairly complex. The psuedocode for the interrupt handler is listed below:
</P><PRE CLASS="verbatim">// Если прерывание включено, запретить любой обмен данными на шине
INTR = 1
BusLock = 1
  
// Выставить регистры
LINT = interruptNo
LADD = interruptParameter or XEIP

// Выдать сигнал прерывания на выход процессора
SignalError(interruptNo,LADD)
  
if IF == 1 then
  if EF == 1 then // Расширеный режим
    // Проверка границ
    if (interruptNo &lt; 0) or (interruptNo &gt; 255) then
      if not cascadeInterrupt then Interrupt(13,3) end
    end

    // Проверка границ таблицы прерываний
    if interruptNo &gt; NIDT-1 then
      if interruptNo == 0 then Reset = 1 end
      if interruptNo == 1 then Clk = 0 end
    end

    // Вычислить смещение в таблице прерываний
    interruptOffset = IDTR + interruptNo*4

    // Отключить запрет на работу шины процессора
    BusLock = 0
    SetCurrentPage(interruptOffset)

    IF = 0
    INTR = 0
    IP    = ReadCell(interruptOffset+0)
    CS    = ReadCell(interruptOffset+1)
            ReadCell(interruptOffset+2)
    FLAGS = ReadCell(interruptOffset+3)
    IF = 1
    
    if INTR == 1 then
      if not cascadeInterrupt then Interrupt(13,2) end
    else
      INTR = 1
    end
    
    // Вызвать предыдущую страницу, правильно настроив
    // состояние страниц
    SetCurrentPage(XEIP)
    SetPrevPage(interruptOffset)
    BusLock = 1

    if isExternal and (FLAGS[6] &lt;&gt; 1) then
      if not cascadeInterrupt then Interrupt(13,4) end
    end
    
    if FLAGS[5] == 1 then
      // Записать данные о возврате
      BusLock = 0
      IF = 0
      INTR = 0
      Push(IP)
      Push(CS)
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,6) end
      else
        INTR = 1
      end
      BusLock = 1

      // Произвести переход
      IF = 0
      INTR = 0
      if FLAGS[4] == 0
      then Jump(IP,CS)
      else Jump(IP)
      end
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,7) end
      else
        INTR = 1
      end
      
      // Выставить CMPR
      if FLAGS[3] == 1 then
        CMPR = 1
      end
    else
      if interruptNo == 0 then
        Reset()
      end
      if interruptNo == 1 then
        Clk = 0
      end
      if FLAGS[3] == 1 then
        CMPR = 1
      end
    end
  end
  
  if PF == 1 then // Расширенный режим (совместимости)
    // Проверка границ
    if (interruptNo &lt; 0) or (interruptNo &gt; 255) then
      if not cascadeInterrupt then Interrupt(13,3) end
    end
    
    // Проверка памяти
    if RAMSize &lt; 512 then
      if not cascadeInterrupt then Interrupt(13,5) end
    end

    // Посчитать абсолютное смещение записи прерывания
    interruptOffset = IDTR + interruptNo*2
    
    if interruptOffset &gt; RAMSize-2 then interruptOffset = RAMSize-2 end
    if interruptOffset &lt; 0         then interruptOffset = 0 end
    
    interruptOffset = Memory[interruptOffset]
    interruptFlags = Memory[interruptOffset+1]
    if (interruptFlags == 32) or (interruptFlags == 96) then
      BusLock = 0
      IF = 0
      INTR = 0
      if (interruptNo == 4 ) or
         (interruptNo == 7 ) or
         (interruptNo == 9 ) or
         (interruptNo == 10) then
        Push(LADD)
      end
      if (interruptNo == 4 ) or
         (interruptNo == 31) then
        Push(LINT)
      end
      if Push(IP) and Push(XEIP) then
        Jump(interruptOffset)
      end
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,6) end
      else
        INTR = 1
      end
      CMPR = 0
      BusLock = 1
    else
      if interruptNo == 1 then Clk = 0 end
      CMPR = 1
    end
  end
  
  if (PF == 0) and (EF == 0) then // Обычный режим
    if (interruptNo &lt; 0) or (interruptNo &gt; 255) or (interruptNo &gt; NIDT-1) then
      // Прерывание не обработано
      Exit()
    end
    if interruptNo == 0 then Reset = 1 end
    if interruptNo ~= 31 then Clk = 0 end
  end
end
  
// Сделать возможным запись по шине процессора
BusLock = 0
</PRE><!--TOC section Внешние прерывания-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">2.9</A>  Внешние прерывания</H2><!--SEC END --><P>
(NMI stuff)</P><!--TOC section Перехват доступа к памяти-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc22">2.10</A>  Перехват доступа к памяти</H2><!--SEC END --><P> <A NAME="memoverride"></A>
(using page traps to override access to specific memory areas)</P><!--TOC section Внутренний таймер-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc23">2.11</A>  Внутренний таймер</H2><!--SEC END --><P>
В ZCPU есть внутренний таймер, который можно использовать для точного измерения времени выполнения кода. Таймер может быть также использован для вызова прерываний с регулярным интервалом.</P><P>Инструкция <TT>TIMER</TT> возвращает значение внутреннего таймера в секундах:
</P><PRE CLASS="verbatim">TIMER EAX
//EAX теперь равен количеству секунд, прошедших с момента старта процессора
</PRE><P>Можно настроить таймер так, что-бы он вызывал внешнее прерывание после некоторого количества секунд, или циклов, настроив один из специальных регистров.</P><P>Регистр <TT>TimerMode</TT> управляет режимом таймера. Если он установлен в 0, то таймер будет отключён. Если <TT>TimerMode</TT> выставлен в 1, то как источник сигнала для таймера будет использован регистр <TT>TMR</TT>, а если <TT>TimerMode</TT> установлен в 2, то таймер будет использовать регистр <TT>TIMER</TT>.</P><P>Регистром <TT>TimerRate</TT> задаётся количество циклов или количество секунд, которые должны быть отсчитаны таймером перед вызовом следующего прерывания. Регистр <TT>TimerPrevTime</TT> хранит предыдущее значение регистра <TT>TMR</TT> или <TT>TIMER</TT>, когда прерывание было вызвано прошлый раз.</P><P>Регистром <TT>TimerAddress</TT> указывается номер внешнего прерывания, которое будет вызвано когда таймер сработает.</P><P>При изменении значения регистра <TT>TimerMode</TT> значение <TT>TimerPrevTime</TT> будет сброшено.</P><P>Вот пример, как настроить таймер:
</P><PRE CLASS="verbatim">CPUSET 65,90; //Вызов каждые 90 циклов
CPUSET 67,40; //Вызов внешнего прерывания #40

CPUSET 64,1;  //Включить таймер
</PRE><P>Также можно установить таймер на секунды:
</P><PRE CLASS="verbatim">CPUSET 65,1.5; //Вызов каждые 1.5 секунд
CPUSET 67,40;  //Вызов внешнего прерывания #40

CPUSET 64,2;   //Включить таймер
</PRE><P>Если нужна точность в интервалах между срабатываниями ми таймера, то можно сбросить значения предыдущего времени срабатывания таймера (если нужно):
</P><PRE CLASS="verbatim">ExternalInterrupt:
  CLI; //Отключить прерывания
  
  .....
  
  CPUGET EAX,29; //Прочитать счётчик циклов
  ADD EAX,4;     //Добавить 4 пропущенны[ цикла
  CPUSET 66,EAX; //Записать в последнее время срабатывания таймера
  
  STI; //Включить прерывания
EXTRET;
</PRE><P>Также можно просто перезапустить таймер:
</P><PRE CLASS="verbatim">ExternalInterrupt:
  CLI; //Отключить прерывания
  
  .....
  
  CPUSET 64,1; //Перезапустить таймер
  STI; //Включить прерывания
EXTRET;
</PRE><P>Если интервал таймера установлен в 0, а последнее время срабатывания находится позже чем текущее время, то таймер можно использовать для единократного вызова события через некоторое время.</P><!--TOC section Векторное расширение-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">2.12</A>  Векторное расширение</H2><!--SEC END --><P>
(using VMODE,VADD,etc)</P><!--TOC section Режим аппаратной отладки-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc25">2.13</A>  Режим аппаратной отладки</H2><!--SEC END --><P>
(Using hardware debug mode)</P><!--TOC section Кеширование и оптимизации реального времени-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">2.14</A>  Кеширование и оптимизации реального времени</H2><!--SEC END --><P> <A NAME="caching"></A>
Процессор Zyelios CPU кеширует выполняемый микрокод для более быстрой работы. Это намного повышает скорость повторного исполнения кода, но при этом первый запуск этого блока кода будет использовать значительное количество циклов процессора. Более быстро выполняется код в циклах, которые много раз повторяются.</P><P>Некоторые ограничения, которые накладываются системой кеширования:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
	При выполнении кешированого блока микрокода процессор использует временные скоростные регистры вместо настоящих. Настоящее значение регистра будет обновлено только после выполнения блока микрокода.
	</LI><LI CLASS="li-enumerate">Процессор кеширует инструкции первый раз когда они декодируются. Чтение или запись в память самим процессором могут обнулить кеш, но операции ввода-вывода других устройств в эту-же область не меняют кеша, создавая возможность выполнения несуществующего кода.
	</LI><LI CLASS="li-enumerate">В каждом кешированом блоке микрокода содержится до 24 инструкций. Если происходит переход по адресу, то выполнение обрывается заранее.
	</LI><LI CLASS="li-enumerate">Все операции чтения-записи могут быть задержаны на несколько циклов, или не выполнены вообще.
</LI></OL><!--TOC chapter Формат инструкций-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc27">Chapter 3</A>  Формат инструкций</H1><!--SEC END --><P> <A NAME="instructionformat"></A>
</P><!--TOC section Формат-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">3.1</A>  Формат</H2><!--SEC END --><P>
Каждая инструкция в ZCPU начинается с одного байта, который определяет, какая инструкция должна быть выполнена. Если у инструкции есть операнды, то далее следует селектор <EM>RM</EM> (register/memory). Этот дополнительный байт указывает, какого типа операнды используются с инструкцией.</P><P>Номер инструкции также содержит информацию про использование сегментного префикса, и про текущий режим выполнения (см. стр <A HREF="#localexec">??</A>). Номер инструкции может принадлежать к одному из таких интервалов:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
	<TT>000 – 999</TT>: инструкции переменной длины
	</LI><LI CLASS="li-itemize"><TT>1000 – 1999</TT>: инструкции переменной длины с сегментным префиксом для 1ого операнда
	</LI><LI CLASS="li-itemize"><TT>10000 – 10999</TT>: инструкции переменной длины с сегментным префиксом для 2ого операнда
	</LI><LI CLASS="li-itemize"><TT>11000 – 11999</TT>: инструкции переменной длины с сегментным префиксом для обоих операндов
	</LI><LI CLASS="li-itemize"><TT>2000 – 2999</TT>: инструкции постоянной длины
	</LI><LI CLASS="li-itemize"><TT>3000 – 3999</TT>: инструкции постоянной длины с сегментным префиксом для 1ого операнда
	</LI><LI CLASS="li-itemize"><TT>12000 – 12999</TT>: инструкции постоянной длины с сегментным префиксом для 2ого операнда
	</LI><LI CLASS="li-itemize"><TT>13000 – 13999</TT>: инструкции постоянной длины с сегментным префиксом для обоих операндов
</LI></UL><P>Далее могут следовать несколько байтов, которые указуют сегментный префикс, константы, и т.п. Константные значения всегда последние в описании каждой инструкции. Вот пример разных инструкций:
</P><PRE CLASS="verbatim">STEF            48
INC EAX         20, 1
MOV EAX,10      14, 1, 10
ADD EAX,ESP     10, 70001
DIV EBX,ES:ECX  10013, 290002, 4
ADD R0,#R2      10, 20822048
MOV #100,#500   14, 250025, 100, 500
MOV EAX:#50,GS  1014, 130025, 9, 50
</PRE><!--TOC section Селектор Регистра-Памяти-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">3.2</A>  Селектор Регистра-Памяти</H2><!--SEC END --><P>
Селектор RM состоит из двух частей - селектор для первого операнда, и второго операнда: <I>RM</I> = <I>RM</I><SUB>1</SUB> + 10000 · <I>RM</I><SUB>2</SUB>.</P><P>Например, вот пример значений байтов RM, и как они декодируются:
</P><PRE CLASS="verbatim">                RM        RM1   RM2
STEF            н/о       н/о   н/о
INC EAX         1         1     н/о
MOV EAX,10      1         1     0
ADD EAX,ESP     70001     1     7
DIV EBX,ES:ECX  290002    2     29
ADD R0,#R2      20822048  2048  2082
MOV #100,#500   250025    25    25
MOV EAX:#50,GS  130025    25    13
</PRE><P>Вот эти селекторы сейчас поддерживаются процессором:



</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Селектор</TD><TD VALIGN=top ALIGN=center NOWRAP>Операнд</TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>0</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>123</TT></TD><TD VALIGN=top ALIGN=left>Константное значение</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>1</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>EAX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EAX</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>2</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>EBX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EBX</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>3</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ECX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>ECX</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>4</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>EDX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EDX</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>5</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ESI</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>ESI</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>6</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>EDI</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EDI</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>7</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ESP</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>ESP</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>8</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>EBP</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EBP</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>9</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>CS</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>CS</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>10</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>SS</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>SS</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>11</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>DS</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>DS</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>12</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>ES</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>13</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>GS</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>GS</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>14</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>FS</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>FS</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>15</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>KS</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>KS</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>16</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>LS</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>LS</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>17</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#EAX</TT>, <TT>ES:#EAX</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EAX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>18</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#EBX</TT>, <TT>ES:#EBX</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EBX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>19</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#ECX</TT>, <TT>ES:#ECX</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>ECX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>20</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#EDX</TT>, <TT>ES:#EDX</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EDX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>21</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#ESI</TT>, <TT>ES:#ESI</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>ESI + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>22</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#EDI</TT>, <TT>ES:#EDI</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EDI + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>23</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#ESP</TT>, <TT>ES:#ESP</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>ESP + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>24</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#EBP</TT>, <TT>ES:#EBP</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EBP + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>25</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#123</TT>, <TT>ES:#123</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти за константным указателём</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>26</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:EAX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EAX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>27</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:EBX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EBX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>28</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:ECX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>ECX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>29</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:EDX</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EDX + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>30</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:ESI</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>ESI + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>31</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:EDI</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EDI + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>32</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:ESP</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>ESP + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>33</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:EBP</TT></TD><TD VALIGN=top ALIGN=left>Регистр <TT>EBP + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>34</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EAX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>35</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EBX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>36</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>ECX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>37</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EDX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>38</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>ESI + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>39</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EDI + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>40</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>ESP + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>41</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>EBP + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>42</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>EAX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>43</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>EBX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>44</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>ECX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>45</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>EDX + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>46</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>ESI + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>47</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>EDI + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>48</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>ESP + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>49</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Регистр <TT>EBP + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>50</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:123</TT></TD><TD VALIGN=top ALIGN=left>Константное значение с сегментом</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>1000</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>PORT0</TT></TD><TD VALIGN=top ALIGN=left>Порт 0</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>1001</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>PORT1</TT></TD><TD VALIGN=top ALIGN=left>Порт 1</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=left>....</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>2023</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>PORT1023</TT></TD><TD VALIGN=top ALIGN=left>Порт 1023</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>2048</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>R0</TT></TD><TD VALIGN=top ALIGN=left>Расширеный регистр <TT>R0</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=left>....</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>2079</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>R31</TT></TD><TD VALIGN=top ALIGN=left>Расширеный регистр <TT>R31</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>2080</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#R0</TT>, <TT>ES:#R0</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>R0 + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=left>....</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>2111</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>#R31</TT>, <TT>ES:#R31</TT></TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>R31 + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>2112</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:R0</TT></TD><TD VALIGN=top ALIGN=left>Extended register <TT>R0 + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=left>....</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>2143</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>ES:R31</TT></TD><TD VALIGN=top ALIGN=left>Extended register <TT>R31 + сегмент</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>2144</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>R0 + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=left>....</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>2175</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Ячейка памяти <TT>R31 + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>2176</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Extended register <TT>R0 + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>....</TT></TD><TD VALIGN=top ALIGN=left>....</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>2207</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>No syntax</TD><TD VALIGN=top ALIGN=left>Extended register <TT>R31 + константа</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Сегментные префикс-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc30">3.3</A>  Сегментные префикс</H2><!--SEC END --><P>
Сегменты указываются байтом, который следует за селектором RM. Например, вот несколько примеров разных префиксов:
</P><PRE CLASS="verbatim">MOV EAX,EBX        14,20001
MOV LS:EAX,EBX     1014,20027,8
MOV EAX,LS:EBX     10014,280001,8
MOV LS:EAX,LS:EBX  11014,280027,8,8
MOV R0:EAX,EBX     1014,20027,17
MOV EAX,R0:EBX     10014,280001,17
MOV R0:EAX,R0:EBX  11014,280027,17,17
</PRE><P>Вот список доступных сегментных префиксов:
</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>Value</TD><TD ALIGN=center NOWRAP>Регистр</TD><TD ALIGN=center NOWRAP>Value</TD><TD ALIGN=center NOWRAP>Register</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-02</TT></TD><TD ALIGN=center NOWRAP><TT>CS</TT></TD><TD ALIGN=center NOWRAP><TT>01</TT></TD><TD ALIGN=center NOWRAP><TT>CS</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-03</TT></TD><TD ALIGN=center NOWRAP><TT>SS</TT></TD><TD ALIGN=center NOWRAP><TT>02</TT></TD><TD ALIGN=center NOWRAP><TT>SS</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-04</TT></TD><TD ALIGN=center NOWRAP><TT>DS</TT></TD><TD ALIGN=center NOWRAP><TT>03</TT></TD><TD ALIGN=center NOWRAP><TT>DS</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-05</TT></TD><TD ALIGN=center NOWRAP><TT>ES</TT></TD><TD ALIGN=center NOWRAP><TT>04</TT></TD><TD ALIGN=center NOWRAP><TT>ES</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-06</TT></TD><TD ALIGN=center NOWRAP><TT>GS</TT></TD><TD ALIGN=center NOWRAP><TT>05</TT></TD><TD ALIGN=center NOWRAP><TT>GS</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-07</TT></TD><TD ALIGN=center NOWRAP><TT>FS</TT></TD><TD ALIGN=center NOWRAP><TT>06</TT></TD><TD ALIGN=center NOWRAP><TT>FS</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-08</TT></TD><TD ALIGN=center NOWRAP><TT>KS</TT></TD><TD ALIGN=center NOWRAP><TT>07</TT></TD><TD ALIGN=center NOWRAP><TT>KS</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-09</TT></TD><TD ALIGN=center NOWRAP><TT>LS</TT></TD><TD ALIGN=center NOWRAP><TT>08</TT></TD><TD ALIGN=center NOWRAP><TT>LS</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-10</TT></TD><TD ALIGN=center NOWRAP><TT>EAX</TT></TD><TD ALIGN=center NOWRAP><TT>09</TT></TD><TD ALIGN=center NOWRAP><TT>EAX</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-11</TT></TD><TD ALIGN=center NOWRAP><TT>EBX</TT></TD><TD ALIGN=center NOWRAP><TT>10</TT></TD><TD ALIGN=center NOWRAP><TT>EBX</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-12</TT></TD><TD ALIGN=center NOWRAP><TT>ECX</TT></TD><TD ALIGN=center NOWRAP><TT>11</TT></TD><TD ALIGN=center NOWRAP><TT>ECX</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-13</TT></TD><TD ALIGN=center NOWRAP><TT>EDX</TT></TD><TD ALIGN=center NOWRAP><TT>12</TT></TD><TD ALIGN=center NOWRAP><TT>EDX</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-14</TT></TD><TD ALIGN=center NOWRAP><TT>ESI</TT></TD><TD ALIGN=center NOWRAP><TT>13</TT></TD><TD ALIGN=center NOWRAP><TT>ESI</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-15</TT></TD><TD ALIGN=center NOWRAP><TT>EDI</TT></TD><TD ALIGN=center NOWRAP><TT>14</TT></TD><TD ALIGN=center NOWRAP><TT>EDI</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-16</TT></TD><TD ALIGN=center NOWRAP><TT>ESP</TT></TD><TD ALIGN=center NOWRAP><TT>15</TT></TD><TD ALIGN=center NOWRAP><TT>ESP</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>-17</TT></TD><TD ALIGN=center NOWRAP><TT>EBP</TT></TD><TD ALIGN=center NOWRAP><TT>16</TT></TD><TD ALIGN=center NOWRAP><TT>EBP</TT></TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>17</TT></TD><TD ALIGN=center NOWRAP><TT>R0</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>...</TT></TD><TD ALIGN=center NOWRAP><TT>...</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>47</TT></TD><TD ALIGN=center NOWRAP><TT>R32</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE><!--TOC section Локальный режим выполнения-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">3.4</A>  Локальный режим выполнения</H2><!--SEC END --><P> <A NAME="localexec"></A>
Процессор Zyelios CPU поддерживает два формата машинного кода: инструкции переменной длины, и инструкции постоянной длины. Процессора автоматически определяет тип машинного кода для поддержки обратной совместимости. Для этого существует насколько правил.</P><P>							</P><P>Пример инструкций в обычном режиме:
</P><PRE CLASS="verbatim">STEF            48
INC EAX         20, 1
MOV EAX,10      14, 1, 10
ADD EAX,ESP     10, 70001
DIV EBX,ES:ECX  10013, 290002, 4
ADD R0,#R2      10, 20822048
MOV #100,#500   14, 250025, 100, 500
MOV EAX:#50,GS  1014, 130025, 9, 50
</PRE><P>Пример инструкций в режиме фиксированого размера:
</P><PRE CLASS="verbatim">STEF            2048,0,-4,-4,0,0
INC EAX         2020,1,-4,-4,0,0
MOV EAX,10      2014,1,-4,-4,0,10
ADD EAX,ESP     2010,70001,-4,-4,0,0
DIV EBX,ES:ECX  12013,290002,-4,4,0,0
ADD R0,#R2      2010,20822048,-4,-4,0,0
MOV #100,#500   2014,250025,-4,-4,100,500
MOV EAX:#50,GS  3014,130025,9,-4,50,0
</PRE><P>Пример инструкций в режиме совместимости:
</P><PRE CLASS="verbatim">STEF            48, 0
INC EAX         20, 1
MOV EAX,10      14, 1, 10
ADD EAX,ESP     10, 70001
DIV EBX,ES:ECX  10013, 290002, 4
ADD R0,#R2      10, 20822048
MOV #100,#500   14, 250025, 100, 500
MOV EAX:#50,GS  1014, 130025, 9, 50
</PRE><!--TOC chapter Внутренние регистры-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc32">Chapter 4</A>  Внутренние регистры</H1><!--SEC END --><P>
У процессора есть несколько внутренних регистров, которые используются для хранения состояния процессора, и управления его работой. Записывать и читать из этих регистров можно с помощью инструкций <TT>CPUSET</TT> и <TT>CPUGET</TT>.</P><P>Например:</P><PRE CLASS="verbatim">CPUGET EAX,24 //Прочитать регистр 24 в EAX (указатель на таблицу прерываний)
CPUSET 9,EBX //Выставить регистр 9 (размер стека) в значение EBX

CPUGET EAX,1000 //Несуществующий регистр запишет 0 в EAX
</PRE><P>Регистры <TT>XEIP</TT>, <TT>CPAGE</TT>, <TT>PPAGE</TT>, <TT>SerialNo</TT>, <TT>CODEBYTES</TT>, <TT>TimerDT</TT> только для чтения - их значение невозможно изменить.</P><P>Изменение регистров <TT>IP</TT> или <TT>CS</TT> будет эквивалентно безусловному переходу.</P><P>


</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Mnemonic</TD><TD VALIGN=top ALIGN=center NOWRAP>Number</TD><TD VALIGN=top ALIGN=left>Description</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>IP</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>00</TT></TD><TD VALIGN=top ALIGN=left>Указатель на инструкцию</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EAX</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>01</TT></TD><TD VALIGN=top ALIGN=left>Регистр общего назначения A</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EBX</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>02</TT></TD><TD VALIGN=top ALIGN=left>Регистр общего назначения B</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>ECX</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>03</TT></TD><TD VALIGN=top ALIGN=left>Регистр общего назначения C</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EDX</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>04</TT></TD><TD VALIGN=top ALIGN=left>Регистр общего назначения D</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>ESI</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>05</TT></TD><TD VALIGN=top ALIGN=left>Исходный индекс</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EDI</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>06</TT></TD><TD VALIGN=top ALIGN=left>Целевой индекс</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>ESP</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>07</TT></TD><TD VALIGN=top ALIGN=left>Указатель стека</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EBP</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>08</TT></TD><TD VALIGN=top ALIGN=left>Базовый указатель</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>ESZ</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>09</TT></TD><TD VALIGN=top ALIGN=left>Размер стека</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>CS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>16</TT></TD><TD VALIGN=top ALIGN=left>Сегмент кода</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>SS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>17</TT></TD><TD VALIGN=top ALIGN=left>Сегмент стека</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>DS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>18</TT></TD><TD VALIGN=top ALIGN=left>Сегмент данных</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>ES</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>19</TT></TD><TD VALIGN=top ALIGN=left>Дополнительный сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>GS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>20</TT></TD><TD VALIGN=top ALIGN=left>Дополнительный сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>FS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>21</TT></TD><TD VALIGN=top ALIGN=left>Дополнительный сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>KS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>22</TT></TD><TD VALIGN=top ALIGN=left>Дополнительный сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>LS</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>23</TT></TD><TD VALIGN=top ALIGN=left>Дополнительный сегмент</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>IDTR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>24</TT></TD><TD VALIGN=top ALIGN=left>Указатель на таблицу прерываний</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CMPR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>25</TT></TD><TD VALIGN=top ALIGN=left>Результат операции сравнения</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>XEIP</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>26</TT></TD><TD VALIGN=top ALIGN=left>Указатель на начало текущей инструкции</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>LADD</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>27</TT></TD><TD VALIGN=top ALIGN=left>Код текущего прерывания</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>LINT</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>28</TT></TD><TD VALIGN=top ALIGN=left>Номер текущего прерывания</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>TMR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>29</TT></TD><TD VALIGN=top ALIGN=left>Счётчик циклов</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>TIMER</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>30</TT></TD><TD VALIGN=top ALIGN=left>Внутренний таймер</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CPAGE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>31</TT></TD><TD VALIGN=top ALIGN=left>Текущий номер страницы</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>IF</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>32</TT></TD><TD VALIGN=top ALIGN=left>Флаг состояния системы прерываний</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>PF</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>33</TT></TD><TD VALIGN=top ALIGN=left>Флаг режима совместимости</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EF</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>34</TT></TD><TD VALIGN=top ALIGN=left>Флаг расширеного режима</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>NIF</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>35</TT></TD><TD VALIGN=top ALIGN=left>Значение флага прерываний на следущем шаге</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>MF</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>36</TT></TD><TD VALIGN=top ALIGN=left>Флаг расширеного режима работы с памятью</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>PTBL</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>37</TT></TD><TD VALIGN=top ALIGN=left>Адрес таблицы страницы</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>PTBE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>38</TT></TD><TD VALIGN=top ALIGN=left>Количество записей в таблице страниц</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>PCAP</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>39</TT></TD><TD VALIGN=top ALIGN=left>Возможность работы с системой страниц</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>RQCAP</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>40</TT></TD><TD VALIGN=top ALIGN=left>Возможность задержаных обращений к памяти</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>PPAGE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>41</TT></TD><TD VALIGN=top ALIGN=left>Номер предыдущей страницы</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>MEMRQ</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>42</TT></TD><TD VALIGN=top ALIGN=left>Тип запроса памяти</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>RAMSize</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>43</TT></TD><TD VALIGN=top ALIGN=left>Количество внутренней памяти</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>External</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>44</TT></TD><TD VALIGN=top ALIGN=left>Внешняя операция ввода-вывода</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>BusLock</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>45</TT></TD><TD VALIGN=top ALIGN=left>Состояние шины</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>Idle</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>46</TT></TD><TD VALIGN=top ALIGN=left>Сигнал о пропуске циклов до следущего сигнала синхронизации</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>INTR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>47</TT></TD><TD VALIGN=top ALIGN=left>Обработка прерывания</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>SerialNo</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>48</TT></TD><TD VALIGN=top ALIGN=left>Серийный номер процессора</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CODEBYTES</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>49</TT></TD><TD VALIGN=top ALIGN=left>Количество запущеного кода</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>BPREC</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>50</TT></TD><TD VALIGN=top ALIGN=left>Режим точности операций с двоичными числами</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>IPREC</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>51</TT></TD><TD VALIGN=top ALIGN=left>Режим точности операций с целыми числами</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>NIDT</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>52</TT></TD><TD VALIGN=top ALIGN=left>Количество записей в таблице прерываний</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>BlockStart</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>53</TT></TD><TD VALIGN=top ALIGN=left>Начало блока</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>BlockSize</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>54</TT></TD><TD VALIGN=top ALIGN=left>Размер блока</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>VMODE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>55</TT></TD><TD VALIGN=top ALIGN=left>Режим векторных операций (2: 2D, 3: 3D)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>XTRL</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>56</TT></TD><TD VALIGN=top ALIGN=left>Уровень доступа для внешнего доступа</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>HaltPort</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>57</TT></TD><TD VALIGN=top ALIGN=left>Номер порта, до получения значения на котором процессор остановлен</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>HWDEBUG</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>58</TT></TD><TD VALIGN=top ALIGN=left>Режим аппаратной отладки</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>DBGSTATE</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>59</TT></TD><TD VALIGN=top ALIGN=left>Состояние аппаратного режима отладки</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>DBGADDR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>60</TT></TD><TD VALIGN=top ALIGN=left>Адрес/параметр аппаратной отладки</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>CRL</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>61</TT></TD><TD VALIGN=top ALIGN=left>Текущий уровень доступа</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>TimerDT</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>62</TT></TD><TD VALIGN=top ALIGN=left>Шаг таймера</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>MEMADDR</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>63</TT></TD><TD VALIGN=top ALIGN=left>Адрес, запрашиваемый операцией связаной с памятью</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>TimerMode</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>64</TT></TD><TD VALIGN=top ALIGN=left>Режим таймера</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>TimerRate</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>65</TT></TD><TD VALIGN=top ALIGN=left>Частота срабатывания таймера</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>TimerPrevTime</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>66</TT></TD><TD VALIGN=top ALIGN=left>Время предыдущего срабатывания</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>TimerAddress</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>67</TT></TD><TD VALIGN=top ALIGN=left>Номер внешнего прерывания для вызова при срабатывании таймера</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>	

</P><!--TOC chapter Список инструкций процессора-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc33">Chapter 5</A>  Список инструкций процессора</H1><!--SEC END --><P> <A NAME="opcodelist"></A>
</P><!--TOC section Основной набор инструкций ZCPU-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc34">5.1</A>  Основной набор инструкций ZCPU</H2><!--SEC END --><P>
В этой секции описан основной набор инструкций, доступных для использования в ZCPU. Некоторые из указанных инструкций не могут быть использованы в производных от ZCPU архитектурах (ZGPU, ZSPU). Недоступны указанные инструкции: <TT>EXTINT</TT></P><P>Для некоторых инструкций указаны ошибки, которые могут быть ими вызваны, исключая ошибки которые могут быть вызваны декодированием инструкции, например если один из операндов это указатель на чтение из памяти.</P><!--TOC subsection 000 STOP-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.1  000 STOP</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>STOP</TT><BR>
 <B>Кодирование:</B> <TT>000</TT><BR>

Вызывает прерывание #2 (тоже самое что выполнение <TT>INT 2</TT>). Останавливает выполнение программы процессором, если расширенный режим не включен.</P><P>Используется для обнаружения конца программы/некорректного перехода, поскольку часто является следствием некорректного перехода по адресу. Работает как <TT>NOP</TT> если система прерываний отключена (флаг <TT>IF</TT> установлен в 0).</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">Interrupt(2,0)
</PRE><!--TOC subsection 001 JNE/JNZ-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.2  001 JNE/JNZ</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>JNE/JNZ</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>001</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения значения были не равны друг другу.</P><P>Также данная инструкция может быть использована для проверки установленности бита числа:
</P><PRE CLASS="verbatim">BIT EAX,2
JNZ LABEL
</PRE><P>Переход будет осуществлён только когда бит равен единице.</P><P>
 


 

Может вызвать ошибку <TT>14</TT> (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр <A HREF="#paging">??</A> для более детальной информации о механизме страниц и защиты памяти.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CMPR &lt;&gt; 0 then
  Jump(X)
end
</PRE><!--TOC subsection 002 JMP-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.3  002 JMP</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>JMP</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>002</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Безусловный переход по заданному адресу.</P><P>
 


 

Может вызвать ошибку <TT>14</TT> (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр <A HREF="#paging">??</A> для более детальной информации о механизме страниц и защиты памяти.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">Jump(X)
</PRE><!--TOC subsection 001 JG/JNLE-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.4  001 JG/JNLE</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>JG/JNLE</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>001</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было больше второго.</P><P>
 


 

Может вызвать ошибку <TT>14</TT> (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр <A HREF="#paging">??</A> для более детальной информации о механизме страниц и защиты памяти.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CMPR &gt; 0 then
  Jump(X)
end
</PRE><!--TOC subsection 004 JGE/JNL-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.5  004 JGE/JNL</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>JGE/JNL</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>004</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было больше или равно второму.</P><P>
 


 

Может вызвать ошибку <TT>14</TT> (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр <A HREF="#paging">??</A> для более детальной информации о механизме страниц и защиты памяти.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CMPR &gt;= 0 then
  Jump(X)
end
</PRE><!--TOC subsection 005 JL/JNGE-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.6  005 JL/JNGE</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>JL/JNGE</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>005</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было меньше второго.</P><P>
 


 

Может вызвать ошибку <TT>14</TT> (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр <A HREF="#paging">??</A> для более детальной информации о механизме страниц и защиты памяти.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CMPR &lt; 0 then
  Jump(X)
end
</PRE><!--TOC subsection 006 JLE/JNG-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.7  006 JLE/JNG</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>JLE/JNG</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>006</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было меньше или равно второму.</P><P>
 


 

Может вызвать ошибку <TT>14</TT> (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр <A HREF="#paging">??</A> для более детальной информации о механизме страниц и защиты памяти.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CMPR &lt;= 0 then
  Jump(X)
end
</PRE><!--TOC subsection 007 JE/JZ-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.8  007 JE/JZ</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>JE/JZ</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>007</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения значения были равны.</P><P>Также даная инструкция может быть использована для проверки установленности бита числа:
</P><PRE CLASS="verbatim">BIT EAX,2
JZ LABEL
</PRE><P>Переход будет осуществлён только когда бит равен нулю.</P><P>
 


 

Может вызвать ошибку <TT>14</TT> (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр <A HREF="#paging">??</A> для более детальной информации о механизме страниц и защиты памяти.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CMPR &lt;&gt; 0 then
  Jump(X)
end
</PRE><!--TOC subsection 008 CPUID-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.9  008 CPUID</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>CPUID</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>008</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Инструкция <TT>CPUID</TT> позволяет получить информацию о текущей версии процессора, и его возможностям. Результат будет записан в регистр <TT>EAX</TT>.</P><P>Параметр инструкции указывает какую информацию нужно получить:</P><P>


</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Параметр</TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>0</TD><TD VALIGN=top ALIGN=left>Текущая версия процессора (10.00, записывается как <TT>1000</TT>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>1</TD><TD VALIGN=top ALIGN=left>Количество внутренней оперативной памяти в байтах</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>2</TD><TD VALIGN=top ALIGN=left>Тип процессора</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>3</TD><TD VALIGN=top ALIGN=left>Количество внутренней постоянной памяти в байтах</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Результат будет записан в регистр <TT>EAX</TT>. Тип процессора может указывать на:



</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EAX</TT></TD><TD VALIGN=top ALIGN=left>Описание</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>0</TD><TD VALIGN=top ALIGN=left>ZCPU</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>1</TD><TD VALIGN=top ALIGN=left>ZGPU (бета версия)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>2</TD><TD VALIGN=top ALIGN=left>ZSPU</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>3</TD><TD VALIGN=top ALIGN=left>ZGPU</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">EAX = CPUID[X]
</PRE><!--TOC subsection 009 PUSH-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.10  009 PUSH</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>PUSH</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>009</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Отсылает значение на стек процессора (см. стр <A HREF="#stack">??</A> для более детальной информации о работе стека процессора). Также будет проведена проверка на ошибку выхода за пределы стека (проверка перехода указателя стека через ноль).</P><P>Как указатель на стек используется регистр <TT>ESP</TT>, а как размер стека - регистр <TT>ESZ</TT>.</P><P>Пример использования:
</P><PRE CLASS="verbatim">PUSH 10
PUSH 20

POP EAX //EAX теперь равен 20
</PRE><P>
 

Может вызвать ошибку <TT>6</TT> (переполнение/недополнение стека) если указатель стека выйдет за допустимые пределы.</P><P>

 



 


Может вызвать ошибку <TT>7</TT> (ошибка чтения/записи памяти) если инструкция не смогла выполнить необходимую запись в память.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">MEMORY[ESP+SS] = X
ESP = ESP - 1

if ESP &lt; 0 then
  ESP = 0
  Interrupt(6,ESP)
end
</PRE><!--TOC subsection 010 ADD-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.11  010 ADD</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>ADD</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>010</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Находит сумму двух значений, и записывает результат в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X + Y
</PRE><!--TOC subsection 011 SUB-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.12  011 SUB</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>SUB</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>011</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Отнимает второй операнд от первого, и записывает результат в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X - Y
</PRE><!--TOC subsection 012 MUL-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.13  012 MUL</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>MUL</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>012</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Множит два значения между собой, и записывает результат в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X * Y
</PRE><!--TOC subsection 013 DIV-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.14  013 DIV</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>DIV</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>013</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Делит первый операнд на второй, и записывает результат в первый операнд. Также проверяет второй операнд на равность нулю.</P><P>

Может вызвать ошибку <TT>3</TT> (деление на ноль) если второй операнд равен нулю.</P><P>Ошибка будет проигнорирована если отключены прерывания.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if Y &lt;&gt; 0 then
  X = X / Y
else
  Interrupt(3,0)
end
</PRE><!--TOC subsection 014 MOV-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.15  014 MOV</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>MOV</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>014</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Копирует содержимое второго операнда в первый.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = Y
</PRE><!--TOC subsection 015 CMP-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.16  015 CMP</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>CMP</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>015</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Сравнивает два значения, и запоминает результат этого сравнения.</P><P>Эта инструкция используется вместе с инструкциями условного перехода (см. стр <A HREF="#branching">??</A>), например:
</P><PRE CLASS="verbatim">CMP EAX,EBX
JG  LABEL1 //Переход, если EAX &gt;  EBX
JLE LABEL2 //Переход, если EAX &lt;= EBX
JE  LABEL3 //Переход, если EAX  = EBX
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">CMPR = X - Y
</PRE><!--TOC subsection 018 MIN-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.17  018 MIN</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>MIN</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>018</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает меньшее из двух значений в первый операнд, например:
</P><PRE CLASS="verbatim">MOV EAX,100
MOV EBX,200
MIN EBX,EAX //Записывает 100 в EBX
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if X &gt; Y then
  X = Y
end
</PRE><!--TOC subsection 019 MAX-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.18  019 MAX</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>MAX</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>019</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает большее из двух значений в первый операнд, например:
</P><PRE CLASS="verbatim">MOV EAX,100
MOV EBX,200
MAX EAX,EBX //Записывает 200 в EAX
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if X &lt; Y then
  X = Y
end
</PRE><!--TOC subsection 020 INC-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.19  020 INC</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>INC</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>020</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Увеличивает операнд на единицу, например:
</P><PRE CLASS="verbatim">MOV EAX,100
INC EAX //EAX теперь равен 101
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X + 1
</PRE><!--TOC subsection 021 DEC-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.20  021 DEC</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>DEC</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>021</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Уменьшает операнд на единицу, например:
</P><PRE CLASS="verbatim">MOV EAX,100
DEC EAX //EAX теперь равен 99
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X - 1
</PRE><!--TOC subsection 022 NEG-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.21  022 NEG</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>NEG</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>022</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Меняет знак операнда на противоположный. Например:
</P><PRE CLASS="verbatim">MOV EAX,123
NEG EAX //EAX теперь равен -123

MOV EBX,0
NEG EBX //EBX теперь равен -0, нуль со знаком
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = -X
</PRE><!--TOC subsection 023 RAND-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.22  023 RAND</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>RAND</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>023</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Аппаратно генерирует случайное число в интервале от 0.0 до 1.0, включительно.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = RANDOM(0.0,1.0)
</PRE><!--TOC subsection 024 LOOP-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.23  024 LOOP</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>LOOP</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>024</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Выполняет условный переход по заданному адресу если регистр ECX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
</P><PRE CLASS="verbatim">MOV ECX,100;
LABEL:
  &lt;...&gt;
LOOP ECX; //Повторяет 100 раз
</PRE><P>Цикл будет остановлен только когда ECX станет равным нулю.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if ECX &lt;&gt; 0 then
  ECX = ECX - 1
  IP = X
end
</PRE><!--TOC subsection 025 LOOPA-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.24  025 LOOPA</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>LOOPA</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>025</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Выполняет условный переход по заданному адресу если регистр EAX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
</P><PRE CLASS="verbatim">MOV EAX,100;
LABEL:
  &lt;...&gt;
LOOP EAX; //Повторяет 100 раз
</PRE><P>Цикл будет остановлен только когда EAX станет равным нулю. Аналогичен инструкции <TT>LOOP</TT>.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if EAX &lt;&gt; 0 then
  EAX = EAX - 1
  IP = X
end
</PRE><!--TOC subsection 026 LOOPB-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.25  026 LOOPB</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>LOOPB</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>026</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Выполняет условный переход по заданному адресу если регистр EBX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
</P><PRE CLASS="verbatim">MOV EBX,100;
LABEL:
  &lt;...&gt;
LOOP EBX; //Повторяет 100 раз
</PRE><P>Цикл будет остановлен только когда EBX станет равным нулю. Аналогичен инструкции <TT>LOOP</TT>.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if EBX &lt;&gt; 0 then
  EBX = EBX - 1
  IP = X
end
</PRE><!--TOC subsection 027 LOOPD-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.26  027 LOOPD</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>LOOPD</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>027</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Выполняет условный переход по заданному адресу если регистр EDX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
</P><PRE CLASS="verbatim">MOV EDX,100;
LABEL:
  &lt;...&gt;
LOOP EDX; //Повторяет 100 раз
</PRE><P>Цикл будет остановлен только когда EDX станет равным нулю. Аналогичен инструкции <TT>LOOP</TT>.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if EDX &lt;&gt; 0 then
  EDX = EDX - 1
  IP = X
end
</PRE><!--TOC subsection 028 SPG-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.27  028 SPG</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>SPG</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>028</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Делает заданную страницу доступной только для чтения. Инструкция убирает флаг возможности записи, и выставляет флаг возможности чтения страницы указанной операндом. См. стр <A HREF="#paging">??</A> для более детальной информации о системе страниц.</P><P>Например:
</P><PRE CLASS="verbatim">SPG 1 //Сделать адреса 128..255 доступными только для чтения
SPG 2 //Сделать адреса 256..511 доступными только для чтения

CPG 1 //Сделать адреса 128..255 доступными для чтения и записи
</PRE><P>
 



Может вызвать ошибку <TT>11</TT> (ошибка доступа к странице) если инструкция обращаеться к странице, к которой нету прав доступа (уровень доступа текущей страницы больше чем уровень доступа страницы, над которой производится операция).</P><P>В случае ошибки номер страницы, настройки которой менялись инструкцией, будет передан как параметр прерывания (регистр <TT>LADD</TT>).</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CurrentPage.Runlevel &lt; Page[X].Runlevel then
  Page[X].Read = 1
  Page[X].Write = 0
else
  Interrupt(11,X)
end
</PRE><!--TOC subsection 029 CPG-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.28  029 CPG</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>CPG</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>029</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Делает заданную страницу доступной для чтения и записи. Инструкция выставляет флаг возможности записи, и возможности чтения страницы указанной операндом. См. стр <A HREF="#paging">??</A> для более детальной информации о системе страниц.</P><P>Например:
</P><PRE CLASS="verbatim">SPG 1 //Сделать адреса 128..255 доступными только для чтения
SPG 2 //Сделать адреса 256..511 доступными только для чтения

CPG 1 //Сделать адреса 128..255 доступными для чтения и записи
</PRE><P>
 



Может вызвать ошибку <TT>11</TT> (ошибка доступа к странице) если инструкция обращаеться к странице, к которой нету прав доступа (уровень доступа текущей страницы больше чем уровень доступа страницы, над которой производится операция).</P><P>В случае ошибки номер страницы, настройки которой менялись инструкцией, будет передан как параметр прерывания (регистр <TT>LADD</TT>).</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if CurrentPage.Runlevel &lt; Page[X].Runlevel then
  Page[X].Read = 1
  Page[X].Write = 1
else
  Interrupt(11,X)
end
</PRE><!--TOC subsection 030 POP-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.29  030 POP</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>POP</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>030</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Убирает значение с вершины стеке процессора, и записывает его в операнд (см. стр <A HREF="#stack">??</A> для более подробной информации о работе стека процессора). Проверяет ошибку недополнения стека сравнивая значение нового указателя стека, и регистра размера стека.</P><P>Использует регистр <TT>ESP</TT> как указатель стека, и регистр <TT>ESZ</TT> для размера стека.</P><P>Пример использования:
</P><PRE CLASS="verbatim">PUSH 10
PUSH 20

POP EAX //EAX теперь равен 20
</PRE><P>
 

Может вызвать ошибку <TT>6</TT> (переполнение/недополнение стека) если указатель стека выйдет за допустимые пределы.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">ESP = ESP + 1
if ESP &gt; ESZ then
  ESP = ESZ
  Interrupt(6,ESP)
end
</PRE><!--TOC subsection 031 CALL-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.30  031 CALL</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>CALL</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>031</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Вызывает подпрограмму. Выполнение основной программы будет продолжено из этого самого момента после возвращения из подпрограммы используя инструкцию <TT>RET</TT>.</P><P>Эта инструкция сохраняет текущий указатель на инструкцию <TT>IP</TT> на стек (адрес возврата), и восстанавливает его при вызове соответствующей инструкции <TT>RET</TT>. Повреждение или нарушение работы стека вызовет ошибку при возврате из функции.</P><P>Данная инструкция может вызвать ошибку стека, если на стеке недостаточно места для сохранения адреса возврата.</P><P>Например:
</P><PRE CLASS="verbatim">CALL SUBROUTINE0;
CALL SUBROUTINE1;

SUBROUTINE0:
RET

SUBROUTINE1:
  CALL SUBROUTINE0;
RET
</PRE><P>
 

Может вызвать ошибку <TT>6</TT> (переполнение/недополнение стека) если указатель стека выйдет за допустимые пределы.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">Push(IP)
if NoInterrupts then
  IP = X
end
</PRE><!--TOC subsection 032 BNOT-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.31  032 BNOT</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>BNOT</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>032</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Меняет все биты числа на противоположные. Количество бит которые будут затронуты зависит от текущего значения регистра <TT>BPREC</TT> (точность двоичных операций).</P><P>Например:
</P><PRE CLASS="verbatim">CPUSET 50,8 //Выставить 8-битную точность

MOV EAX,1
BNOT EAX //EAX теперь равен 254
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = NOT X
</PRE><!--TOC subsection 033 FINT-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.32  033 FINT</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FINT</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>033</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Округляет значение вниз (до меньшего целого числа):
</P><PRE CLASS="verbatim">MOV EAX,1.9
FINT EAX //EAX = 1.0

MOV EAX,4.21
FINT EAX //EAX = 4.0

MOV EAX,1520.101
FINT EAX //EAX = 1520.0
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = FLOOR(X)
</PRE><!--TOC subsection 034 FRND-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.33  034 FRND</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FRND</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>034</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Округляет значение за правилом округления (до более близкого целого числа):
</P><PRE CLASS="verbatim">MOV EAX,1.9
FRND EAX //EAX = 2.0

MOV EAX,4.21
FRND EAX //EAX = 4.0

MOV EAX,1520.101
FRND EAX //EAX = 1520.0
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = ROUND(X)
</PRE><!--TOC subsection 035 FFRAC-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.34  035 FFRAC</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FFRAC</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>035</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Возвращает дробную часть операнда:
</P><PRE CLASS="verbatim">MOV EAX,1.9
FRND EAX //EAX = 0.9

MOV EAX,4.21
FRND EAX //EAX = 0.21

MOV EAX,1520.101
FRND EAX //EAX = 0.101
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = FRAC(X)
</PRE><!--TOC subsection 036 FINV-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.35  036 FINV</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FINV</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>036</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Находит значение, обратное операнду. Проверяет на возникновение ошибки деления на ноль.</P><P>

Может вызвать ошибку <TT>3</TT> (деление на ноль) если второй операнд равен нулю.</P><P>Ошибка деления на ноль вызвана не будет если регистр <TT>IF</TT> (флаг прерываний) выставлен в 0.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if X &lt;&gt; 0 then
  X = 1 / X
else
  Interrupt(3,1)
end
</PRE><!--TOC subsection 038 FSHL-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.36  038 FSHL</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FSHL</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>038</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Производит арифметический сдвиг влево домножая заданное число на два. В результате может быть получено число с плавающей точкой:
</P><PRE CLASS="verbatim">MOV EAX,100
FSHR EAX //EAX = 200

MOV EAX,8
FSHR EAX //EAX = 16

MOV EAX,4.2
FSHR EAX //EAX = 8.2
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X * 2
</PRE><!--TOC subsection 039 FSHR-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.37  039 FSHR</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FSHR</TT> <TT>X</TT><BR>
 <B>Кодирование:</B> <TT>039</TT> <TT>RM [Сегмент1]</TT>  <TT>[Данные1]</TT><BR>

Производит арифметический сдвиг вправо деля заданное число на два. В результате может быть получено число с плавающей точкой:
</P><PRE CLASS="verbatim">MOV EAX,100
FSHR EAX //EAX = 50

MOV EAX,8
FSHR EAX //EAX = 4

MOV EAX,4.2
FSHR EAX //EAX = 2.1
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X / 2
</PRE><!--TOC subsection 040 RET-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.38  040 RET</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>RET</TT><BR>
 <B>Кодирование:</B> <TT>040</TT><BR>

Возвращается из подпрограммы вызванной инструкцией <TT>CALL</TT>. Эта инструкция убирает с вершины стека адрес возврата, и записывает его в регистр <TT>IP</TT> (указатель на инструкцию).</P><P>Обычно используется для создания подпрограмм:
</P><PRE CLASS="verbatim">CALL SUBROUTINE0;
CALL SUBROUTINE1;

SUBROUTINE0:
  &lt;...&gt;
RET

SUBROUTINE1:
  &lt;...&gt;
  CALL SUBROUTINE0;
RET
</PRE><P>
 

Может вызвать ошибку <TT>6</TT> (переполнение/недополнение стека) если указатель стека выйдет за допустимые пределы.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">IP = POP()
</PRE><!--TOC subsection 041 IRET-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.39  041 IRET</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>IRET</TT><BR>
 <B>Кодирование:</B> <TT>041</TT><BR>

Данная инструкция возвращается из выполнения обработчика прерывания. Она работает таким-же образом как и инструкция <TT>RET</TT>, только восстанавливает и сегмент кода<TT>CS</TT>, и указатель на инструкцию <TT>IP</TT>. Оба значения будут сняты со стека.</P><P>Восстановленное значение сегмента кода соответствует сегменту, в котором выполнялся код на момент возникновения прерывания. Данная инструкция не зависит от флага прерываний <TT>IF</TT>.</P><P>Например тело обработчика прерывания может быть вот таким:
</P><PRE CLASS="verbatim">INTERRUPT_HANDLER:
  &lt;...&gt;
IRET;
</PRE><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">if EF = 0 then
  IP = Pop()
end
if EF = 1 then
  CS = Pop()
  IP = Pop()
end
</PRE><!--TOC subsection 042 STI-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.40  042 STI</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>STI</TT><BR>
 <B>Кодирование:</B> <TT>042</TT><BR>

Устанавливает флаг прерываний <TT>IF</TT> в 1 <EM>после следующей инструкции</EM>. Это включит возможность обработки прерываний (без этого прерывания будут пропускаться).</P><P>Задержка в одну инструкцию создана для того, что-бы можно было скомбинировать инструкцию <TT>STI</TT> вместе с <TT>IRET</TT> или <TT>EXTRET</TT> для обеспечения корректного выхода из обработчика прерывания (что-бы прерывание не возникло до того, как будет выход из обработчика).</P><P>Например:
</P><PRE CLASS="verbatim">INTERRUPT_HANDLER:
  CLI;
  &lt;...&gt;
  STI;
EXTRET;
</PRE><P>
Данная инструкция привилегированна, то есть она может быть исполнена лишь когда текущий уровень доступа равен 0.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">NextIF = 1
</PRE><!--TOC subsection 043 CLI-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.41  043 CLI</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>CLI</TT><BR>
 <B>Кодирование:</B> <TT>043</TT><BR>

Очищает флаг прерываний <TT>IF</TT>. Это предотвратит вызов любых прерываний, они будут просто игнорироваться. Обработку прерываний снова можно включить используя инструкцию <TT>STI</TT>.</P><P>
Данная инструкция привилегированна, то есть она может быть исполнена лишь когда текущий уровень доступа равен 0.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">IF = 0
</PRE><!--TOC subsection 047 RETF-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.42  047 RETF</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>RETF</TT><BR>
 <B>Кодирование:</B> <TT>047</TT><BR>

Производит дальний возврат из подпрограммы, которая была вызвана с помощью инструкции <TT>CALLF</TT>. Работает схожим образом с инструкцией <TT>IRET</TT>.</P><P>Значения текущего сегмента кода и указателя инструкций будут взяты с вершины стека.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">CS = Pop()
IP = Pop()
</PRE><!--TOC subsection 048 STEF-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.43  048 STEF</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>STEF</TT><BR>
 <B>Кодирование:</B> <TT>048</TT><BR>

Включает расширенный режим процессора. В этом режиме включается поддержка таблицы прерываний и проверок связанных с защитой памяти для страниц.</P><P>Система страниц не зависит от работы расширенного режима, и может работать с выключенным защищённым режимом.</P><P>Возможно отключить расширенный режим с помощью инструкции <TT>CLEF</TT>.</P><P>
Данная инструкция привилегированна, то есть она может быть исполнена лишь когда текущий уровень доступа равен 0.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">EF = 1
</PRE><!--TOC subsection 049 CLEF-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.44  049 CLEF</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>CLEF</TT><BR>
 <B>Кодирование:</B> <TT>049</TT><BR>

Выключает расширенный режим, который был включен инструкцией <TT>STEF</TT>. Это отключит таблицу прерываний и проверки прав доступа при обращении к страницам памяти.</P><P>Система страниц не зависит от работы расширенного режима, и может работать с выключенным защищённым режимом.</P><P>
Данная инструкция привилегированна, то есть она может быть исполнена лишь когда текущий уровень доступа равен 0.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">EF = 0
</PRE><!--TOC subsection 050 AND-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.45  050 AND</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>AND</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>050</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Производит логическую операцию И. В первый операнд будет записана единица если оба операнда больше или равны единице, иначе будет записан ноль.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X AND Y
</PRE><!--TOC subsection 051 OR-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.46  051 OR</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>OR</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>051</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Производит логическую операцию ИЛИ. В первый операнд будет записана единица если один из операндов больше или равен единице, иначе будет записан ноль.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X OR Y
</PRE><!--TOC subsection 052 XOR-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.47  052 XOR</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>XOR</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>052</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Производит логическую операцию исключающего ИЛИ. В первый операнд будет записана единица если один из операндов больше или равен единице, но только один, иначе будет записан ноль.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X XOR Y
</PRE><!--TOC subsection 053 FSIN-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.48  053 FSIN</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FSIN</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>053</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает синус второго операнда в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = Sin(Y)
</PRE><!--TOC subsection 054 FCOS-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.49  054 FCOS</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FCOS</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>054</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает косинус второго операнда в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = Cos(Y)
</PRE><!--TOC subsection 055 FTAN-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.50  055 FTAN</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FTAN</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>055</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает тангенс второго операнда в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = Tan(Y)
</PRE><!--TOC subsection 056 FASIN-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.51  056 FASIN</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FASIN</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>056</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает арксинус второго операнда в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = ArcSin(Y)
</PRE><!--TOC subsection 057 FACOS-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.52  057 FACOS</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FACOS</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>057</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает арккосинус второго операнда в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = ArcCos(Y)
</PRE><!--TOC subsection 058 FATAN-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.53  058 FATAN</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>FATAN</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>058</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Записывает арктангенс второго операнда в первый операнд.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = ArcTan(Y)
</PRE><!--TOC subsection 059 MOD-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.1.54  059 MOD</H3><!--SEC END --><P>
<B>Мнемоника:</B> <TT>MOD</TT> <TT>X</TT><TT>,Y</TT><BR>
 <B>Кодирование:</B> <TT>059</TT> <TT>RM [Сегмент1]</TT> <TT>[Сегмент2]</TT> <TT>[Данные1]</TT> <TT>[Данные2]</TT><BR>

Находит остаток от деления первого операнда на второй. Если на входе число с плавающей точкой, то записано будет число <I>X</I> &#X2212; <I>n</I> * <I>Y</I>, где <I>n</I> это результат деления of <I>X</I> / <I>Y</I> округлённый в сторону нуля.</P><P><B>Псевдокод:</B>
</P><PRE CLASS="verbatim">X = X FMOD Y
</PRE><!--TOC chapter HL-ZASM-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc35">Chapter 6</A>  HL-ZASM</H1><!--SEC END --><!--TOC section Описание-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc36">6.1</A>  Описание</H2><!--SEC END --><P>
HL-ZASM - это высокоуровневый ассемблер и язык програмирования. Он предоставляет поддержку основных высокоуровневых структур С, но при этом является обратно-совместимым с кодом ассемблера ZASM2.</P><!--TOC section Ключевые слова-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">6.2</A>  Ключевые слова</H2><!--SEC END --><P>
Некоторые символы и ключевые слова зарезервированы компилятором HL-ZASM и не могут быть использованы как имена переменных. Название переменной может состоять из латинских буков, цифер, нижнего подчёркивания (<TT>_</TT>) и, в некоторых случаях, точки (<TT>.</TT>) в названиях меток.</P><P>Вот список всех зарезервированых ключевых слов:
<TT>GOTO</TT>, <TT>FOR</TT>, <TT>IF</TT>, <TT>ELSE</TT>, <TT>WHILE</TT>, <TT>DO</TT>, <TT>SWITCH</TT>, <TT>CASE</TT>,
<TT>CONST</TT>, <TT>RETURN</TT>, <TT>BREAK</TT>, <TT>CONTINUE</TT>, <TT>EXPORT</TT>, <TT>FORWARD</TT>,
<TT>DB</TT>, <TT>ALLOC</TT>, <TT>SCALAR</TT>, <TT>VECTOR1F</TT>, <TT>VECTOR2F</TT>, <TT>UV</TT>, <TT>VECTOR3F</TT>,
<TT>VECTOR4F</TT>, <TT>COLOR</TT>, <TT>VEC1F</TT>, <TT>VEC2F</TT>, <TT>VEC3F</TT>, <TT>VEC4F</TT>, <TT>MATRIX</TT>,
<TT>STRING</TT>, <TT>DB</TT>, <TT>DEFINE</TT>, <TT>CODE</TT>, <TT>DATA</TT>, <TT>ORG</TT>, <TT>OFFSET</TT>,
<TT>VOID</TT>, <TT>FLOAT</TT>, <TT>CHAR</TT>, <TT>INT48</TT>, <TT>VECTOR</TT>, <TT>PRESERVE</TT>, <TT>ZAP</TT>.</P><P>Описание назначения каждого ключевого слова описано в следующих главах.</P><!--TOC section Синтаксис ассемблера-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc38">6.3</A>  Синтаксис ассемблера</H2><!--SEC END --><!--TOC subsection Базовый синтаксис-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.3.1  Базовый синтаксис</H3><!--SEC END --><P>
HL-ZASM поддерживает вот такой синтаксис (Intel-подобный):
</P><PRE CLASS="verbatim">mov eax,123; //Записать константу в регистр
mov eax,ebx; //Перенести значение из регистра в регистр

add eax,123; //Инструкция с 2мя операндами
jmp 123; //Инструкция с 1им операндом (константой)
jmp eax; //Инструкция с 1им операндом (регистром)
</PRE><P>За названием инструкции всегда следует один или два операнда. Если их два, то первый это всегда целевой операнд (в который будет записан результат), а второй это исходный операнд (из которого будет взято значение).</P><!--TOC subsection Доступ к памяти и сегменты-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.3.2  Доступ к памяти и сегменты</H3><!--SEC END --><P>
Для доступа к памяти можно использовать синтаксис ZASM (<TT>#</TT>) или более широкоиспользуемый синтаксис с квадратными скобками (<TT>[]</TT>). Оба синтаксиса являются правильными в HL-ZASM.</P><P>Процессор поддерживает сегментные префиксы для смещения адреса при обращении к памяти (см. стр <A HREF="#segments">??</A> для более подробного обяснения). Как префикс можно использовать любой сегментный регистр или регистр общего назначения, и для любого операнда.</P><P>В HL-ZASM возможнен ’инвертированый’ синтаксис, когда сегментный префикс следует за самим операндом (например ’eax:es’ вместо ’es:eax’).</P><P>Если используется обычный синтаксис для чтения значения из памяти (со скобками) то сегментный префикс должен находится внутри скобок. Вместо двоеточия (<TT>:</TT>) можно использовать знак прибавления (<TT>+</TT>), но только в обычном синтаксисе обращения к памяти.</P><P>Также можно использовать константу как префикс к регистру, но такой операнд на самом деле использует инвертированый синтаксис сегментного префикса. На данный момент невозможно использовать константный префикс к константе, а также использовать сегментный префикс к сегменту.</P><P>Пример поддерживаемого синтаксиса обращения к памяти:
</P><PRE CLASS="verbatim">//Синтаксис чтения из памяти ZASM2
mov eax,#100;
mov eax,#eax;
mov eax,es:#100;
mov eax,es:#eax;
mov eax,eax:#100;
//mov eax,eax:#es; //Неправильный синтаксис: невозможно использовать 
                   //сегментный регистр как указатель

//Обычный синтаксис чтения из памяти
mov eax,[100];
mov eax,[eax];
mov eax,[es:eax];
mov eax,[es+eax];
//mov eax,[eax:es]; //Неправильный синтаксис: невозможно использовать 
                    //сегментный регистр как указатель
//mov eax,[eax+es]; //Неправильный синтаксис: невозможно использовать 
                    //сегментный регистр как указатель

//Использование констант с сегментным префиксом
mov eax,es:100;
mov eax,eax:100;
mov eax,100:es;
mov eax,100:eax;
//mov eax,100:200; //Неправильный синтаксис

//Использование регистров с сегментным префиксом
mov eax,ebx:ecx;
mov eax,es:ebx;
mov eax,ebx:es; //Инвертированый синтаксис
//mov eax,fs:es; //Неправильный синтаксис, такого операнда нет
</PRE><!--TOC subsection Константы-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.3.3  Константы</H3><!--SEC END --><P>
Можно использовать константные выражения, шестнадцатеричные числа и значения меток в HL-ZASM:
</P><PRE CLASS="verbatim">//Целые числа
mov eax,255;   //EAX = 255
mov eax,0255;  //EAX = 255
mov eax,0x1FF; //EAX = 511

//Отрицательные числа
mov eax,-255;   //EAX = -255
mov eax,-0x1FF; //EAX = -511

//Числа с плавающей точкой и выражения
mov eax,1e4;         //EAX = 10000
mov eax,1.53e-3;     //EAX = 0.00153
mov eax,1.284;       //EAX = 1.248
mov eax,2.592+3.583; //EAX = 6.175
mov eax,1e2+15;      //EAX = 115
//mov eax,1e-5+0.034;//Не парсится (ошибка в компиляторе)
mov eax,0xFF+100;    //EAX = 355

//Сложные выражения
define labelname,512;
mov eax,10+15;         //EAX = 25
mov eax,10*(15+17*24); //EAX = 4230
mov eax,10+labelname*53-10*(17-labelname); //EAX = 32096
</PRE><!--TOC subsection Метки и переменные-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.3.4  Метки и переменные</H3><!--SEC END --><P>
Метки используются для создания возможности перехода между отдельными частями кода. Каждая метка это на самом деле число у которого есть название. При этом это число равно указателю в памяти в том месте, куда указывает метка. Все метки это просто константы, которые могут быть использованы в константных выражениях:
</P><PRE CLASS="verbatim">labelname:
  jmp labelname;
  mov eax,labelname+3;
</PRE><P>Макрос <TT>define</TT> позволяет привязать к названию метки любое константное значение:
</P><PRE CLASS="verbatim">define defVar1,120;
define defVar2,50+defVar1;
//define defVar3,labelname2*10; //Не парсится (ошибка компилятора)

labelname2:
  mov eax,defVar1; //120
  mov eax,defVar2; //170
//mov eax,defVar3; //170
</PRE><P>Макрос <TT>db</TT> используется для записи данных в память, без обработки. Они будут записаны вместе с кодом. Данные, записаные таким образом могут быть использованы программой, но нужно быть осторожным, что-бы процессор не попытался выполнить эти данные как код:
</P><PRE CLASS="verbatim">db 100; //Записывает 100
db 0xFF; //Записывает 255
db labelname2+10;
db 'This is a string',0;
db 15,28,595,'string',35,29;
</PRE><P>Макрос <TT>alloc</TT> выделяет некоторое место, и позволяет обращаться к этому пространству за именем, если оно указано. Это место будет создано в текущем положении в памяти (если данные и код находятся в одном сегменте), или в отдельном сегменте данных (в зависимости от настроек компилятора). Первым параметром макроса должно быть либо название переменной, либо константное выражение
</P><PRE CLASS="verbatim">alloc var1,100,72; //alloc label,size,value, тоже что 'var1: db 72,72,72,...'
alloc var2,100;    //alloc label,value, тоже что 'var2: db 100'
alloc var3;        //alloc label, тоже что 'var3: db 0'
alloc 120;         //alloc size, тоже что 'db 0,0,0,0,0....'

define allocsize,120;
alloc 0+allocsize; //должно быть выражением
</PRE><P>Также существуют макросы для определения векторных переменных и текстовых строчек. Синтаксис для этого выражения <TT>VECTOR_MACRO NAME,DEFAULT_VALUE</TT>. Вот пример всех доступных векторных макросов:
</P><PRE CLASS="verbatim">scalar name,...; //Например "scalar x,10"
vector1f name,...;
vector2f name,...;
vector3f name,...;
vector4f name,...;
vec1f name,...;
vec2f name,...;
vec3f name,...;
vec4f name,...;
uv name,...; 
color name,...; 
matrix name; //Без инициализатора
</PRE><P>Это создаёт указатели на все компоненты векторов:
</P><PRE CLASS="verbatim">vector3f vec1;
mov #vec1.x,10;
mov #vec1.y,20;
*(vec1.z) = 30;

uv texcoord1;
mov #texcoord1.u,10;
mov #texcoord1.v,20;

color col1;
mov #col1.r,10;
mov #col1.g,20;
mov #col1.b,30;
mov #col1.a,40;
</PRE><P>Матричные и векторные переменные можно использовать с векторным расширением ZCPU:
</P><PRE CLASS="verbatim">matrix m1;
matrix m2;
vector4f rot,0,0,1,45;

mident m1; //Load identity matrix
mrotate m2,rot; //Load rotation matrix

mmul m1,m2; //Multiply two matrices
</PRE><P>Также есть дополнительный макрос, который напрямую не связан с созданием переменных, но позволяет изменить текущий указатель в памяти (место, куда записывается код и данные). Этот макрос называется <TT>ORG</TT>:
</P><PRE CLASS="verbatim">//Write pointer 0
alloc 64;
//Write pointer is now 64
alloc 1;
//Write pointer is now 65

ORG 1000;
//Write pointer is now 1000
</PRE><P>Этот макрос может быть использован для управления генерацией кода.</P><P>Также есть два дополнительных макроса которые упрощают определение переменных и данных для простых программ: <TT>DATA</TT> и <TT>CODE</TT>. Вот как они используются:
</P><PRE CLASS="verbatim">DATA; //Data section
  alloc var1;
  alloc var2;
  ......
  subroutine1:
    ....
  ret
  ....
CODE; //Main code section
  call subroutine1;
  call subroutine2;
  ......
</PRE><P>Эти макросы эквивалентны такому коду:
</P><PRE CLASS="verbatim">//DATA
jmp _code;

//CODE
_code:
</PRE><!--TOC section Expression Generator-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc39">6.4</A>  Expression Generator</H2><!--SEC END --><P>
HL-ZASM has a built-in expression generator. It is possible to generate complex expressions that can involve function calls, registers, variables in a similar way as they are generated in the C code.</P><P>Here are the several examples of various expressions:
</P><PRE CLASS="verbatim">EAX = 0 //Same as "mov eax,0"
EAX += EBX //Same as "add EAX,EBX"

main()
print("text",999)
R17 = solve("sol1",50,R5)
R2 = R0 + R1*128
c = *ptr++;

R0 = (noise(x-1, y) + noise(x+1, y) + noise(x, y-1) + noise(x, y+1)) /  8
Offset = 65536+32+MAX_DEVICES+udhBusOffset[busIndex*2]
</PRE><P>Extra care must be taken while using the expression generator, since it will use the 6 general purpose registers (<TT>EAX</TT> .. <TT>EDI</TT>) as temporary storage for evaulating the expressions.</P><P>There is support for parsing constant expressions, which are reduced to a single constant value during compile time. It is possible to use the following syntax features in the expression parser:



</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Syntax</TD><TD VALIGN=top ALIGN=left>Description</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>-X</TT>, <TT>+X</TT></TD><TD VALIGN=top ALIGN=left>Specify value sign, or negate the value</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>&amp;globalvar</TT></TD><TD VALIGN=top ALIGN=left>Pointer to a global variable (always constant)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>&amp;stackvar</TT></TD><TD VALIGN=top ALIGN=left>Pointer to a stack variable (always dynamic)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>&amp;globalvar[..]</TT></TD><TD VALIGN=top ALIGN=left>Pointer to an element of a global array</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>&amp;stackvar[..]</TT></TD><TD VALIGN=top ALIGN=left>Pointer to an element of a stack-based array</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>1234</TT></TD><TD VALIGN=top ALIGN=left>Constant value</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>"string"</TT></TD><TD VALIGN=top ALIGN=left>Pointer to a constant string, can be only used inside functions</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>’c’</TT></TD><TD VALIGN=top ALIGN=left>Single character</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>pointervar</TT></TD><TD VALIGN=top ALIGN=left>Constant pointer (or a label)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>EAX</TT></TD><TD VALIGN=top ALIGN=left>Register</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>func(...)</TT></TD><TD VALIGN=top ALIGN=left>Function call</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>var[...]</TT></TD><TD VALIGN=top ALIGN=left>Array access</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>*var</TT></TD><TD VALIGN=top ALIGN=left>Read variable by pointer</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>expr + expr</TT></TD><TD VALIGN=top ALIGN=left>Addition</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr - expr</TT></TD><TD VALIGN=top ALIGN=left>Subtraction</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr * expr</TT></TD><TD VALIGN=top ALIGN=left>Product</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr / expr</TT></TD><TD VALIGN=top ALIGN=left>Division</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr ^^expr</TT></TD><TD VALIGN=top ALIGN=left>Raising to power</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr &amp;expr</TT></TD><TD VALIGN=top ALIGN=left>Binary AND</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr |expr</TT></TD><TD VALIGN=top ALIGN=left>Binary OR</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr ^expr</TT></TD><TD VALIGN=top ALIGN=left>Binary XOR</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr &amp;&amp;expr</TT></TD><TD VALIGN=top ALIGN=left>Logic AND</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr ||expr</TT></TD><TD VALIGN=top ALIGN=left>Logic OR</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>expr = expr</TT></TD><TD VALIGN=top ALIGN=left>Assign (returns value of left side AFTER assigning)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr &gt; expr</TT></TD><TD VALIGN=top ALIGN=left>Greater than</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr &gt;= expr</TT></TD><TD VALIGN=top ALIGN=left>Greater or equal than</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr == expr</TT></TD><TD VALIGN=top ALIGN=left>Equal</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr &lt;= expr</TT></TD><TD VALIGN=top ALIGN=left>Less or equal than</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr &lt; expr</TT></TD><TD VALIGN=top ALIGN=left>Less than</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>expr++</TT></TD><TD VALIGN=top ALIGN=left>Increment (returns value BEFORE incrementing)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>expr--</TT></TD><TD VALIGN=top ALIGN=left>Decrement (returns value BEFORE decrementing)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>++expr</TT></TD><TD VALIGN=top ALIGN=left>Increment (returns value AFTER incrementing)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>--expr</TT></TD><TD VALIGN=top ALIGN=left>Decrement (returns value AFTER decrementing)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Expression generator supports expressions inside opcodes as well.</P><!--TOC section Declaring Variables-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc40">6.5</A>  Declaring Variables</H2><!--SEC END --><P> <A NAME="vardef"></A>
It’s possible to declare variables in HL-ZASM the same way they are declared in the C programming language. It must be noted, however, that there is a difference between variables declared with this way, and variables declared using ZASM2 macros. It will be detailed a bit more on this problem further down.</P><P>Variables may be declared either in global space (data segment), or local space (stack segment/stack frame). The variables declared in the global space are created at compile-time, while the stack-based variables are allocated runtime.</P><P><EM>Take note that variable declarations and variable definitions are two different things</EM>. Variables are declared as shown below, but they can be defined using ZASM2 macros. Consider the following code:
</P><PRE CLASS="verbatim">float x;
mov x,10;  //Set variable X to 10
mov #x,10; //Same as '*(x) = 10'

scalar y;
mov y,10; //Does nothing, same as 'mov 123,10'
mov #y,10; //Sets variable Y to 10
</PRE><P>There are three types supported by the compiler right now: <TT>float</TT> (64-bit floating point variable), <TT>char</TT> (64-bit floating point character code), <TT>void</TT> (undeclared type/no assigned behaviour). Unlike the usual compilers, all three types work the same way, and are essentially the same thing:
</P><PRE CLASS="verbatim">float x;
float y,z;
char* w;
char** u; //Pointer to a pointer

//In all of these examples 'a' is a pointer to a character
char * a;
char* a;
char *a;
char b,*a;
</PRE><P>It’s possible to use <TT>*</TT> symbol to create pointers to variables. There is no difference on whether there are any whitespaces between the asterisk and the variable name (the asterisk belongs to the variable name).</P><P>Arrays of constant size may be declared as variables. If array is located in global scope, <EM>all members will usually default to zero, although this is might not be the case if program is dynamically loaded by the OS</EM>. If the array is declared in local scope, the contents of it may be undeclared. :
</P><PRE CLASS="verbatim">float arr[256];

arr[100] = 123;
R0 = arr[R1];
</PRE><P>There is no way to declare 2-dimensional arrays right now, but there will be support for that feature at some point.</P><P>It’s possible to use initializers for the arrays and the variables. It’s only possible to use constant expressions as initializers for the global scope variables and arrays (there is no limit on what expressions may be used in the stack-based mode):
</P><PRE CLASS="verbatim">//Global scope
float x = 10;
float garr1[4] = { 0, 5, 7, 2 };
float garr2[8] = { 1, 2 }; //Missing entries filled with zeroes
float garr3[8] = { 1, 2, 0, 0, 0, 0, 0, 0 }; //Same as garr2

//Local scope
void func(float x,y) {
  float z = x + y * 128;
  float larr1[4] = { x, y, 0, 0 };
  float larr2[16] = { x, 0, y }; //Missing entries filled with zeroes
}
</PRE><P>There is also support for creating variables, which are stored in the processors registers. To do this their type must be prepended with the <TT>register</TT> keyword. Local variables in registers work much faster than the stack-based local variables, but they cannot be an array type (they can be a pointer though):
</P><PRE CLASS="verbatim">void strfunc(char *str) {
  register char *ptr = str;  
  *ptr++ = 'A';
}
</PRE><P>There is a limit on how much local register variables there can be.</P><!--TOC section Declaring Functions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc41">6.6</A>  Declaring Functions</H2><!--SEC END --><P>
It’s possible to use C-style function declaration syntax, although only one style is currently supported:
</P><PRE CLASS="verbatim">return_type function_name(param_type1 name1, name2, param_type2 name3) {
  ....
  code
  ....
}
</PRE><P>Parameters are defined the same way the variables are defined, see page <A HREF="#vardef">??</A>. It’s possible to use constant-size arrays as variables into function, but <EM>there is no way to actually pass them into the function right now</EM>. It’s also possible to use sizeless array as a parameter (see examples).</P><P>Examples of declaring functions:
</P><PRE CLASS="verbatim">void main() { .. }
float func1() { .. }
float func2(float x, y, float z) { .. }

char strcmp(char* str1, char* str2) { .. }
float strlen(char str[]) { .. } //'char str[]' is same as 'char* str'

//no way to actually pass an array like this:
void dowork(char str[256]) { .. } 
</PRE><P>There are two kinds of function declarations - normal declarations, and forward declarations. Normal function declarations can be anywhere in the code, and there’s no restriction on using them from any other part of the program. Forward function declarations must always precede the function use (or they must be declared beforehand without the function body).</P><P>The forward function declarations allow to perform strict arguments check, and they allow overriding the function to have different parameter lists while having the same name. A function can be forward-declared by using the <TT>FORWARD</TT> keyword before the function type:
</P><PRE CLASS="verbatim">//Forward declarations before use
forward void func(); //First function
forward void func(float x); //Second function
forward void func(float x, *y);

func(); //Calls first function
func(10); //Calls second function

func2(); //COMPILE ERROR: function 'func2' is not declared

//Actual function bodies
forward void func() { //First function
  ...
}
forward void func(float x) { //Second function
  ...
}
forward void func(float x, *y) {
  ...
}
forward void func2() {
  ...
}
</PRE><P>Unlike the forward function declarations, the normal functions can be used from anywhere in the code, but they do not provide strict argument type checks:
</P><PRE CLASS="verbatim">void func1() { .. }

func1();
func2(); //Works even thought it's not yet declared

void func2() { .. }
</PRE><P>There’s also an additional keyword that can be used when defining functions - <TT>EXPORT</TT>. If this keyword is used, the function name will be preserved in the generated library (see page <A HREF="#libgen">??</A> for more informations on how to generate libraries). The compiler will also add a declaration for this function automatically in the generated library file:
</P><PRE CLASS="verbatim">export void func1() { .. }
void func2() { .. } //Function name will be mangled in the resulting file
</PRE><!--TOC section Function Calling-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc42">6.7</A>  Function Calling</H2><!--SEC END --><!--TOC subsection Calling Convention-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.7.1  Calling Convention</H3><!--SEC END --><P>
HL-ZASM uses the <TT>cdecl</TT> calling convention. The function result is passed via the EAX register. If the function is not forward-declared, or if it has variable argument count, then the ECX register must be set to the parameter count:
</P><PRE CLASS="verbatim">R0 = func(a,b,c);

//Same as:
push c;
push b;
push a;
mov ecx,3; //Optional if forward-declared
call func;
add esp,3; //Must clean up stack
mov r0,eax; //Return result

main();

//Same as:
mov ecx,0;
call func;
</PRE><P>The function will modify EAX, ECX, EBP registers (along with the ESP register), and may modify all other registers unless they are marked as preserved (see <A HREF="#preserve">??</A>).</P><!--TOC subsection Stack Frame-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.7.2  Stack Frame</H3><!--SEC END --><P>
The HL-ZASM uses the ZCPU stack frame management instructions (<TT>ENTER</TT>, <TT>LEAVE</TT>) for creating a stack frame for the function. It will pass number of local variables into the <TT>ENTER</TT> instruction, so it will create a stack frame with pre-allocated space for local variables.</P><P>The function would generate such code:
</P><PRE CLASS="verbatim">void func(float x,y) {
  float z,w;
  ...
}

//Generates:
func:
  enter 2;
    ....
  leave;
  ret
</PRE><P>All the access to variables on stack is done via the <TT>RSTACK</TT>, <TT>SSTACK</TT> instructions. The compiler will use <TT>EBP:X</TT> as the stack offset, where <TT>EBP</TT> is the stack frame base register, and <TT>X</TT> is the offset of the target value on stack. For example:
</P><PRE CLASS="verbatim">void func(float x,y) {
  float z,w;
}

//These values would be laying on stack
//[ 3] Y
//[ 2] X
//[ 1] Return address
//[ 0] Saved value of EBP (at function call)
//[-1] Z
//[-1] Z

//Therefore this would be valid:
rstack R0,EBP:2  //R0 = X
rstack R1,EBP:3  //R1 = Y
rstack R2,EBP:-1 //R2 = Z
rstack R3,EBP:-2 //R3 = W
</PRE><P>Therefore it’s possible to generate a stack trace using the following code:
</P><PRE CLASS="verbatim">void stack_trace() {
  char* returnAddress,savedEBP;
  
  R0 = EBP; //'Current' EBP
  while ((R0 &gt; 0) &amp;&amp; (R0 &lt; 65535)) {
    rstack returnAddress,R0:1;
    rstack savedEBP,R0:0;    
    
    add_to_trace(returnAddress);    
    R0 = savedEBP;
  }
}
</PRE><!--TOC subsection Preserving Registers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.7.3  Preserving Registers</H3><!--SEC END --><P> <A NAME="preserve"></A>
If the current program makes use of any ZCPU registers, it must mark them as preserved so the expression generator does not use those registers for purpose of calculating expressions.</P><P>The compiler will give out warning when unpreserved registers are being used. Right now only EAX-EDI registers must be marked as preserved (since only those are used for expression generator):
</P><PRE CLASS="verbatim">void func(float x,y) {
  preserve EAX, EBX;
  
  //Expression generator will never change EAX or EBX registers
  EAX = 123;
  EBX = x*10 + y;
}
</PRE><!--TOC section Control Structures-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc43">6.8</A>  Control Structures</H2><!--SEC END --><P>
The HL-ZASM compiler supports common C control structures, although right now the support is limited.</P><P>The conditional branching can be done via the <TT>if</TT> construct. The <TT>else</TT> clause, and the <TT>else if</TT> are supported. It’s possible to branch into a single expression, or into an entire block of code too:
</P><PRE CLASS="verbatim">//Can use blocks
if (expression) {
  ....
} else if (expression) {
  ....
} else {
  ....
}

//Can avoid using blocks:
if (expression) expression;
if (expression) expression1 else expression2;
</PRE><P>HL-ZASM supports <TT>for</TT> loops. The syntax is:
</P><PRE CLASS="verbatim">for (initializer; condition; step) { ... }
</PRE><P>where <TT>initializer</TT> is the expression that will be executed to setup the loop, <TT>condition</TT> is the condition that is tested on each step, and <TT>step</TT> is the expression executed after each step. For example:
</P><PRE CLASS="verbatim">float x;
for (x = 0; x &lt; 128; x++) { .. } //Loop for X from 0 to 127
for (x = 128; x &gt; 0; x--) { .. } //Loop for X from 128 to 1
for (;;) { .. } //Infinite loop
</PRE><P>It’s possible to use the <TT>while</TT> loop (but no support for <TT>do - while</TT> loops yet):
</P><PRE CLASS="verbatim">while (expression) { ... }
while ((x &lt; y) &amp;&amp; (x &gt; 0)) { ... }
while (1) { ... } //Infinite loop
</PRE><P>The <TT>break</TT> keyword can be used to end the currently executed loop, for example:
</P><PRE CLASS="verbatim">while(1) {
  if (condition) {
    break;
  }
  ....
}
</PRE><P>It’s possible to use the <TT>continue</TT> keyword to go on to the next step in the loop. For example:
</P><PRE CLASS="verbatim">float x;
for (x = 0; x &lt; 128; x++) {
  if (x == 50) { //Skip iteration 50
    continue;
  }
}
</PRE><P>It’s also possible to define labels, and then jump to those labels by defining them the same way they are defined in ZASM2, and using <TT>GOTO</TT>:
</P><PRE CLASS="verbatim">....
  goto label1; //Jumps to label1
....
  label1:
</PRE><P>When using the <TT>GOTO</TT> it’s also possible to pass a complex expression into it:
</P><PRE CLASS="verbatim">goto function_entrypoints[10];
</PRE><!--TOC section Preprocessor-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">6.9</A>  Preprocessor</H2><!--SEC END --><P>
The HL-ZASM preprocessor supports C-style preprocessor macros. Preprocessor macros are always last on the current line (it is not possible to write two preprocessor macros on same line).</P><!--TOC subsection C Runtime Library Macros-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.9.1  C Runtime Library Macros</H3><!--SEC END --><P> <A NAME="crtmacro"></A>
By default programs compiled with HL-ZASM have no attached runtime library, and would require rewriting all the basic routines. It is possible to link to a runtime library of a choice though. The default runtime library is called <TT>ZCRT</TT>, and it allows to boot up the ZCPU without any additional software.</P><P>The CRT library can be picked with the following preprocessor macro. It must be located in the first line of code, before any other code is generated, otherwise it will not work correctly (macro is case-insensitive):
</P><PRE CLASS="verbatim">#pragma CRT ZCRT
</PRE><P>This macro will add CRT folder as one of the search paths, and include the main CRT file:
</P><PRE CLASS="verbatim">#pragma SearchPath lib\zcrt\
#include &lt;zcrt\main.txt&gt;
</PRE><P>This makes it possible to use the default libraries that belong to that runtime library. See page <A HREF="#zcrtlib">??</A> for more information on the <TT>ZCRT</TT> library.</P><!--TOC subsection Definition And Conditional Macros-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.9.2  Definition And Conditional Macros</H3><!--SEC END --><P>
It is possible to use the C style definition preprocessor macros (it is not possible to define preprocessor functions yet though). It supports the <TT>#define</TT>, <TT>#ifdef</TT>, <TT>#elseif</TT>, <TT>#else</TT>, <TT>#endif</TT> and the <TT>#undef</TT> macros:
</P><PRE CLASS="verbatim">#define DEF1
#define DEF2 1234

#ifdef DEF1
  func(DEF2) //same as func(1234)
  ...
#elseif DEF2
  ....
#else
  ...
#endif

#undef DEF1
</PRE><!--TOC subsection File Inclusion Macros-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.9.3  File Inclusion Macros</H3><!--SEC END --><P>
The preprocessor supports including external files using the <TT>#include</TT> macro:
</P><PRE CLASS="verbatim">#include "filename"
#include &lt;filename&gt;
</PRE><P>The <TT>#include "filename"</TT> macro will include file from the current working directory. This is the same directory the main (first) compiled source file is located in. The other version of this macro includes file relative to the base directory (<TT>CPUChip</TT>).</P><P>If file is not found, it will also be searched on one of the search paths.</P><P>The preprocessor also supports the ZASM2 file include syntax:
</P><PRE CLASS="verbatim">##include## filename
same as
#include &lt;filename&gt;
</PRE><!--TOC subsection Special Compiler Commands-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.9.4  Special Compiler Commands</H3><!--SEC END --><P>
There are several special compiler commands available through the <TT>#pragma</TT> macro.</P><P>The <TT>#pragma set</TT> macro allows user to modify settings of the compiler. Example of the syntax (everything is case-sensitive):
</P><PRE CLASS="verbatim">#pragma set OutputResolveListing true
</PRE><P>There are the following settings available:



</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Name</TD><TD VALIGN=top ALIGN=center NOWRAP>Default</TD><TD VALIGN=top ALIGN=left>Description</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>CurrentLanguage</TD><TD VALIGN=top ALIGN=center NOWRAP>HLZASM</TD><TD VALIGN=top ALIGN=left>Current compiler language. Can be HLZASM or ZASM2</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>CurrentPlatform</TD><TD VALIGN=top ALIGN=center NOWRAP>CPU</TD><TD VALIGN=top ALIGN=left>Target platform. Defines the feature set, cannot be modified</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>MagicValue</TD><TD VALIGN=top ALIGN=center NOWRAP>-700500</TD><TD VALIGN=top ALIGN=left>The magic value is used in place of an erroneous constant value</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OptimizeLevel</TD><TD VALIGN=top ALIGN=center NOWRAP>0</TD><TD VALIGN=top ALIGN=left>Optimizer level. 0 is none, 1 is low, 2 is high. Not supported right now.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
OutputCodeTree</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output code tree</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputResolveListing</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output code listing for resolve stage</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputFinalListing</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output code listing for final stage</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputTokenListing</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output tokenized sourcecode</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputBinaryListing</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output final binary dump as listing</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputDebugListing</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output the debug data as listing</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputToFile</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output listings to files instead of to the console</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputOffsetsInListing</TD><TD VALIGN=top ALIGN=center NOWRAP>true</TD><TD VALIGN=top ALIGN=left>Output binary offsets in listings</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>OutputLabelsInListing</TD><TD VALIGN=top ALIGN=center NOWRAP>true</TD><TD VALIGN=top ALIGN=left>Output label names in final listing</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>GenerateComments</TD><TD VALIGN=top ALIGN=center NOWRAP>true</TD><TD VALIGN=top ALIGN=left>Generate extra comments in output listing</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
FixedSizeOutput</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Output fixed-size instructions (can be toggled at any time)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>SeparateDataSegment</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Puts all variables into separate data segment Not supported right now.</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>GenerateLibrary</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Generate a precompiled library. See page <A HREF="#libgen">??</A></TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>AlwaysEnterLeave</TD><TD VALIGN=top ALIGN=center NOWRAP>false</TD><TD VALIGN=top ALIGN=left>Always generate the enter/leave blocks in functions</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>NoUnreferencedLeaves</TD><TD VALIGN=top ALIGN=center NOWRAP>true</TD><TD VALIGN=top ALIGN=left>Do not compile functions and variables which are not used by the program</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The <TT>#pragma language</TT> macro can be used in place of setting the language via changing the compiler variables:
</P><PRE CLASS="verbatim">#pragma language zasm
#pragma set CurrentLanguage ZASM2
</PRE><P>The <TT>#pragma crt</TT> macro can be used to attach a C runtime library. See page <A HREF="#crtmacro">??</A> for more information.</P><P>The <TT>#pragma cpuname</TT> macro is used to assign a specific name to the target processor:
</P><PRE CLASS="verbatim">#pragma CPUName ACPI Power Controller
</PRE><!--TOC subsection Preprocessor Definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.9.5  Preprocessor Definitions</H3><!--SEC END --><P>
There are several preprocessor definitions and special labels available for use by the programmer:



</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><DIV CLASS="center"><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>Bit</TD><TD VALIGN=top ALIGN=left>Description</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__PTR__</TT></TD><TD VALIGN=top ALIGN=left>Current write pointer</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__LINE__</TT></TD><TD VALIGN=top ALIGN=left>Current line number</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__FILE__</TT></TD><TD VALIGN=top ALIGN=left>Current file name (a string)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__DATE_YEAR__</TT></TD><TD VALIGN=top ALIGN=left>Current year (at compile time)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__DATE_MONTH__</TT></TD><TD VALIGN=top ALIGN=left>Current month (at compile time)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__DATE_DAY__</TT></TD><TD VALIGN=top ALIGN=left>Current day (at compile time)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__DATE_HOUR__</TT></TD><TD VALIGN=top ALIGN=left>Current hour (at compile time)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__DATE_MINUTE__</TT></TD><TD VALIGN=top ALIGN=left>Current minute (at compile time)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__DATE_SECOND__</TT></TD><TD VALIGN=top ALIGN=left>Current second (at compile time)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>__PROGRAMSIZE__</TT></TD><TD VALIGN=top ALIGN=left>Total size of the program in bytes</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP><TT>programsize</TT></TD><TD VALIGN=top ALIGN=left>Total size of the program in bytes (ZASM2 compatibility macro)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>&nbsp;</TD></TR>
</TABLE>

</DIV><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Advanced Features-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc45">6.10</A>  Advanced Features</H2><!--SEC END --><!--TOC subsection Generating Libraries-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.10.1  Generating Libraries</H3><!--SEC END --><P> <A NAME="libgen"></A>
no chapter
</P><!--TOC subsection Optimizer-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.10.2  Optimizer</H3><!--SEC END --><P> <A NAME="optimizer"></A>
no chapter
</P><!--TOC subsection ZCRT Library Reference-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.10.3  ZCRT Library Reference</H3><!--SEC END --><P> <A NAME="zcrtlib"></A>
no chapter but lots of incredible fun</P><!--TOC section List Of Errors-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">6.11</A>  List Of Errors</H2><!--SEC END --><!--TOC subsection General Compiler Errors-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->6.11.1  General Compiler Errors</H3><!--SEC END --><!--TOC subsubsection Undefined label-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Undefined label</H4><!--SEC END --><P>
Previously unknown label, variable, or function call was never declared in the current scope.</P><!--TOC subsubsection Variable redefined-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Variable redefined</H4><!--SEC END --><P>
Variable or function with this name was already defined previously in the scope. Error message will point to initial definition.</P><!--TOC subsubsection Identifier expected-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Identifier expected</H4><!--SEC END --><P>
Expression generator expects identifier to follow (variable/function name, etc).</P><!--TOC subsubsection Expression expected, got ...-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Expression expected, got ...</H4><!--SEC END --><P>
There was something unexpected in the source code at that position. Can also indicate invalid expression syntax.</P><!--TOC subsubsection Ident ... is not a variable/pointer/array-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Ident ... is not a variable/pointer/array</H4><!--SEC END --><P>
Unable to get pointer of the given identifier.</P><!--TOC subsubsection Invalid instruction operand-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Invalid instruction operand</H4><!--SEC END --><P>
The ZCPU does not support the given instruction operand. Can indicate that segment prefix is used for segment register access, or for port access.</P><!--TOC subsubsection Undefined opcode-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Undefined opcode</H4><!--SEC END --><P>
Given opcode is not supported by the current architecture.</P><!--TOC subsubsection Array size must be constant-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Array size must be constant</H4><!--SEC END --><P>
It’s only possible to define arrays which have constant size. There is no support for declaring variable-sized arrays.</P><!--TOC subsubsection Cannot have expressions in global initializers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Cannot have expressions in global initializers</H4><!--SEC END --><P>
There is no support for having complex expressions as variable initializers right now.</P><!--TOC subsubsection Can only zap/preserve registers inside functions/local blocks-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Can only zap/preserve registers inside functions/local blocks</H4><!--SEC END --><P>
Compiler does not support preserving registers in global scope right now.</P><!--TOC subsubsection ... must be constant-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->... must be constant</H4><!--SEC END --><P>
A constant value is expected, and it must not rely on values of any unknown variables or labels.</P><!--TOC subsubsection Expected ... got ... instead-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Expected ... got ... instead</H4><!--SEC END --><P>
Invalid syntax is being used for some specific language structure.</P><!--TOC subsubsection Out of free registers-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Out of free registers</H4><!--SEC END --><P>
This error indicates one of the following things:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
	There are no more free registers to use due to too much local register variables allocated.
	</LI><LI CLASS="li-itemize">The expression being generated was too complex (there are not enough unallocated registers).
	</LI><LI CLASS="li-itemize">Internal compiler error.
</LI></UL><!--TOC subsubsection Unable to include CRT library-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Unable to include CRT library</H4><!--SEC END --><P>
Invalid runtime library name/library is not found.</P><!--TOC subsubsection Cannot open file-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Cannot open file</H4><!--SEC END --><P>
File was not found in the specified folder, and it was not found on one of the search paths.</P><!--TOC subsubsection Internal error ...-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Internal error ...</H4><!--SEC END --><P>
Internal compiler error (is not an error that can be worked around).</P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
