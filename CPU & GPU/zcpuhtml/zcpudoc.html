<!-- Custom Markup, not generated by TeX -->
<!DOCTYPE html>
<html>

	<head>
		<link href="zcpudoc.css" rel="stylesheet" type="text/css">
		<meta charset="utf8">
		<title>ZCPU Documentation</title>
	</head>
<body>
<!-- End Custom Markup -->

<table class="title"><tbody><tr><td><h1 class="titlemain">Zyelios CPU 10 Handbook</h1><h3 class="titlerest">Black Phoenix</h3></td></tr>
</tbody></table>
<h1 class="chapter"><a href="zcpudoc_ru.html">Русская документация доступна здесь</a></h3>
<h1 class="chapter">
<h1 class="chapter">
<h2 class="section"><p>
The Zyelios CPU is a virtual processor. It was created so the Wiremod 
players could include it in their contraptions, automating their 
contraptions and learning the basics of low-level programming, assembly 
programming and, with introduction of the HL-ZASM compiler, C 
programming.</p><p>This processor is very similar to the kind of processors all modern complex devices use. Its closest real-world analog is the <tt>x86</tt>
 architecture, but it has several major distinctions, the most of which 
is the use of floating-point numbers instead of integers.</p><p>It 
should be noted that the processor is a complex machine, and just like a
 real vehicle it will require some practice to master. It should be 
understood, however, that despite large number of possible uses of the 
processor it’s based on a very simple set of logic rules. Only the 
complex combination of these basic logic rules creates all the behaviour
 of the processor.</p><p>This handbook should serve as a concise 
documentation that covers all of the ZCPU features and quirks you might 
encounter during your programming. Just like a car manual for a real 
car, this book covers all of the controls and features of the ZCPU. This
 handbook assumes the reader has some basic knowledge of real-world 
processors. </p>
<h2 class="section"><p>
The processor was invented as a logical step up from basic analog 
computers. First processors were tasked with solving mathematical 
equations, performing simulations, and processing large arrays of 
statistic data.</p><p>The program that the processor must execute is 
split into instructions. Each instruction is a simple operation, which 
somehow alters processor state, or state of any external devices. For 
example:
</p><pre class="verbatim">MOV R0,100 //Move 100 to R0
ADD R0,R1 //Add R0 with R1
</pre><p>The extra parameters specified by a programmer to alter the execution of a specific instruction by the processor are called <em>operands</em>. All the instructions in ZCPU have zero, one or two operands. The first operand is usually the <em>destanation</em> operand, and the second one is the <em>source</em> operand.</p><p>If there is some result after execution the instruction, it is written to the first operand:
</p><pre class="verbatim">ADD R0,200; //R0 = R0 + 200
</pre><p>A <em>register</em> is a variable inside the processor. They are divided into <em>general purpose</em> registers and the <em>special</em>
 (internal) registers. Programmer may use general purpose registers as 
temporary or intermediate storage for any sort of numeric data:
</p><pre class="verbatim">MOV R6,100;
MOV R7,R6;
</pre><p>The special registers are used to alter the processor execution mode.</p><p>The processor may be attached to external devices and external memory via data bus. A <em>data bus</em> is a special type of device which allows to connect several other devices together. There are two data buses in ZCPU: the <tt>MemBus</tt> (memory bus), and the <tt>IOBus</tt> (input/output bus). Any memory cell on these buses and in the processors internal memory can be accessed by an <em>address</em>
 - an integer value. There is no principial difference between how the 
two buses operate, although it is possible to use memory cells located 
on the <tt>IOBus</tt> in an easy to understand way - by addressing them as ports:
</p><pre class="verbatim">MOV R0,PORT0 //Read cell 0 via I/O bus
MOV [500],R0 //Write to cell 500 via memory bus
</pre><p>There are several memory models provided by the ZCPU - these 
specify how much internal memory the ZCPU has (it may either have some 
memory and ROM, like a microcontroller, or not use any internal memory 
at all, similarly to common processors).</p>
<h2 class="section"><p>
There are 40 general purpose registers in the ZCPU. They are divided into the <em>main</em> and the <em>extended</em> set. The registers from the main set are called <tt>EAX</tt>, <tt>EBX</tt>, <tt>ECX</tt>, <tt>EDX</tt>, <tt>ESI</tt>, <tt>EDI</tt>, <tt>ESP</tt> and <tt>EBP</tt> (named similarly to the x86 architecture registers). The registers from the extended set are called <tt>R0</tt>, <tt>R1</tt>, ..., <tt>R31</tt>. </p><p>You can use any of these for any arithmetics purposes (that means they only hold numerical values), apart from the <tt>ESP</tt> register, which is reserved as the stack pointer (see: <a href="#stack">??</a> for more information on the processor stack). When programming using C syntax the <tt>EBP</tt> register is also used for storing stack frame pointer, and must not be altered to avoid program crash.</p><p>Every register is a single 64-bit floating point value. It can contain any value between &#8722;10<sup>3000</sup> and 10<sup>3000</sup>,
 but the precision in digits is limited to 48 bits. This is a 
simplification that differs ZCPU from any other real-world processor.</p><p>Registers are <em>a lot faster</em>
 than using memory. In the version 10 of the processor 32 more general 
purpose registers were added to speed up the program execution.</p><p>When the CPU is reset, all registers (except for <tt>ESP</tt>) will be set to 0. If the current ZCPU memory model includes RAM space, then <tt>ESP</tt> will be reset to the CPU internal RAM size minus one (e.g. <tt>65535</tt> for 64k memory model).</p>
<h2 class="section"><p>
The Zyelios CPU has a special register called the instruction pointer (<tt>IP</tt>). <tt>IP</tt> points to the currently executed instruction and is incremented every time a new instruction is read.</p><p>Instructions can be either variable sized or fixed-sized, depending on the local execution mode (see: <a href="#localexec">??</a>), so the <tt>IP</tt> may increment in varying steps. It is possible to set <tt>IP</tt> explictly by using any of the branching opcodes (see: <a href="#branching">??</a>)</p><p>The following is the internal execution flow for fetching and executing an instruction:
</p><ol class="enumerate" type="1"><li class="li-enumerate">
	Fetch instruction number (so the processor would know what instruction 
it is going to execute, and how much operands will the instruction have)
	</li><li class="li-enumerate">If the instruction has operands, then fetch the RM byte (see <tt>rmbyte</tt>).
 If the instruction has no operands and the next byte is zero it will be
 skipped (this behaviour assures that the processor is backwards 
compatible).
	</li><li class="li-enumerate">Processor decodes instruction number and 
fetches segment prefix bytes (if required, this provides support for 
segment prefixes. see: <a href="#instructionformat">??</a> for more information on the instruction format).
	</li><li class="li-enumerate">If RM byte requires an immediate value to follow, it will be fetched too.
	</li><li class="li-enumerate">The processor executes the instruction 
microcode, which somehow alters the processor state (but does not touch 
the values which are explictly stated in the operation).
	</li><li class="li-enumerate">All values that must be written are written back to registers, memory, etc.
</li></ol><p>For the purpose of optimization, one or more of these steps
 might be cached by the processor and omitted from actual execution. See
 page <a href="#caching">??</a> for more information on this behaviour.</p><p>The
 processor will run a specific amount of cycles per second. The amount 
of cycles required for executing each instruction may vary, and it is 
counted by the <tt>TMR</tt> register. Most instructions are only 1 cycle long, although internal caching or memory access may consume additional cycles.</p><p>see: <a href="#advexecution">??</a> more information on the execution process.</p>
<h2 class="section"><p>
When a certain exceptional event occurs (external signal, error in 
arithmetics, memory error, etc), the ZCPU will generate an interrupt. 
Interrupts are special events which will temporarily "interrupt" or 
change flow of the program and branch to execute the appropriate 
interrupt handler code. This means that whenever the ZCPU encounters an 
interrupt it will remember its current state, store it on the processor 
stack (see: <a href="#stack">??</a>) and change <tt>IP</tt> to the first opcode of the interrupt handler.</p><p>In
 extended mode the processor stores an interrupt table - a table which 
holds pointers to all interrupt handlers. If extended mode is not 
enabled, any interrupts called will stop the processor execution.</p><p>After
 the interrupt handler has finished running, it can restore the ZCPU 
state and the previously executed code will continue executing from 
where it was interrupted.</p><p>For example, if this was the stack state before an interrupt call, and current value of <tt>IP</tt> is 157:
</p><pre class="verbatim">..........
65304: ...
65306: 181
65305: -94

ESP = 65304
</pre><p>then the stack state will be altered to this after an interrupt call (and <tt>IP</tt> will be set to interrupt handler entrypoint):
</p><pre class="verbatim">..........
65304: ...
65306: 181
65305: -94
65304: 0   CS
65303: 157 IP

ESP = 65302
</pre><p>Interrupts are very similar to normal calls (see: <a href="#branching">??</a>),
 but instead of using a memory pointer an interrupt number is given. 
Also unlike the regular calls a special return instruction <tt>IRET</tt> must be used in place of <tt>RET</tt>. Any interrupt can be called using the <tt>INT</tt> instruction. For example:
</p><pre class="verbatim">interrupt_handler:
  ....
iret;
</pre><p>There are two types of interrupts: internal interrupts, and 
external interrupts. The external interrupts will push the entire ZCPU 
state (along with the return data internal interrupt would push) to 
stack before entering the interrupt handler. They can only be triggered 
via external interrupt pin, or by using the <tt>EXTINT</tt> instruction. The external interrupts require <tt>EXTRET</tt> instruction instead of the <tt>IRET</tt> to restore the processor state.</p><p>There
 are several static interrupts. These interrupts are executed when 
certain exceptional conditions happen internally. All interrupt numbers 
less than 32 are reserved by the processor. In addition, interrupts 0 
and 1 have special meanings and are handled internally. The user program
 can only use the interrupts 32..255. see: <a href="#errorcodes">??</a> for more information on the error interrupts.</p><p>The following table describes all of the reserved interrupt numbers:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Number</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">0</td><td align="left" valign="top"><em>Reset</em></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">1</td><td align="left" valign="top"><em>Halt</em></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">2</td><td align="left" valign="top">End of program execution</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">3</td><td align="left" valign="top">Division by zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">4</td><td align="left" valign="top">Unknown opcode</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">5</td><td align="left" valign="top">Internal processor error</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">6</td><td align="left" valign="top">Stack error (overflow/underflow)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">7</td><td align="left" valign="top">Memory read/write fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">8</td><td align="left" valign="top">MemBus fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">9</td><td align="left" valign="top">Write access violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">10</td><td align="left" valign="top">Port read/write fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">11</td><td align="left" valign="top">Page acccess violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">12</td><td align="left" valign="top">Read access violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">13</td><td align="left" valign="top">General processor fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">14</td><td align="left" valign="top">Execute access violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">15</td><td align="left" valign="top">Address space violation</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">17</td><td align="left" valign="top">Frame instruction limit (<em>GPU only</em>)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">23</td><td align="left" valign="top">String read error (<em>GPU only</em>)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">28</td><td align="left" valign="top"><em>Page read access trap</em></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">29</td><td align="left" valign="top"><em>Page write access trap</em></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">30</td><td align="left" valign="top"><em>Page access trap</em></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">31</td><td align="left" valign="top"><em>Debug trap</em></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>The
 reset interrupt (0) will reset the processor state, and restart code 
execution from the top of memory. The halt interrupt (1) will stop 
execution until the processor is reset externally. The <tt>int 1</tt> and <tt>int 0</tt>
 instructions will work as long as the interrupts are not handled by the
 software (as long as they are disabled in the interrupt table, or 
interrupt table is not used):
</p><pre class="verbatim"> INT 1; //Stop execution
 
 INT 0; //Reset the processor
</pre><p>If extended mode is not enabled, <em>all the interrupts</em> will work similarly to the halt interrupt (<tt>int 1</tt>) when triggered. The error code will be set on the error output.</p><p>Interrupt handling can be disabled using the <tt>IF</tt> flag. It is not directly writeable, but it can be changed using the special instructions. <em>When setting the flag, the value will only become updated after the next instruction</em>. For example:</p><pre class="verbatim">STI;         //Set interrupt flag
MOV EAX,123; //IF = 0
ADD EAX,123; //IF = 1 (flag updated)
CLI;         //Clear interrupt flag
SUB EAX,123; //IF = 0 (flag clear on this instruction)
RET;         //IF = 0 
</pre><p>This assures that for example in this situation the interrupt will not occur between the <tt>RET</tt> and the <tt>STI</tt>:</p><pre class="verbatim">ContextSwitch:
  CLI;
  
  ... thread switcher code ...
  
  STI;  //An interrupt will never occur between this
EXTRET; //STI instruction and the NMIRET
</pre><p>For information on using the interrupt table, consult the advanced interrupts chapter (see: <a href="#advancedinterrupts">??</a>).</p>
<h2 class="section"><p> <a name="segments"></a>
There are 8 segment registers in the ZCPU. They are <tt>CS</tt>, <tt>SS</tt>, <tt>DS</tt>, <tt>ES</tt>, <tt>GS</tt>, <tt>FS</tt>, <tt>KS</tt> and <tt>LS</tt>.
 They are used by the ZCPU to support certain memory models. 
Additionally any of the 40 general purpose registers can be used as 
segment registers.</p><p>Every segment register can contain a 48-bit 
integer. This value can be used for specifying an offset for a pointer 
to memory. The ZCPU always uses segments when referencing memory: it 
translates the local address (the memory address explictly written by 
the user, it’s important to remember that any variable or label has a 
certain memory address) into the absolute address (the physical address,
 which serves as a command to direct ZCPU towards where the real data is
 located).</p><p>The formula used for the address translation is:
</p><table class="display dcenter"><tbody><tr valign="middle"><td class="dcell"><i>AbsoluteAddress</i>&nbsp;=&nbsp;<i>LocalAddress</i>&nbsp;+&nbsp;<i>SegmentOffset</i></td></tr>
</tbody></table><p>The user can specify which register to use for 
offsets by prefixing the operand with the segment name followed by a 
semicolon. If a segment is not specified, <tt>DS</tt> is used.</p><p>Both
 segment and general purpose registers can be used for segment 
prefixing. It is not possible to use a constant value for segment 
prefix. Here is an example of various ZASM syntax for reading memory:
</p><pre class="verbatim">MOV EAX,#EBX      //Address: DS+EBX
MOV EAX,ES:#EBX   //Address: ES+EBX
MOV EAX,[EBX]     //Address: DS+EBX
MOV EAX,[ES:EBX]  //Address: ES+EBX
MOV EAX,[ES+EBX]  //Address: ES+EBX

MOV EAX,EBX:ECX   //Address: EBX+ECX
MOV EAX,[EBX+ECX] //Address: EBX+ECX
MOV EAX,[EBX:100] //Address: EBX+100
MOV EAX,[100:EBX] //This is not valid
</pre><p>With some clever programming the segment prefixes can be used 
for quick array access, typically by using the prefix as the array 
pointer and the base as the index into the array:
</p><pre class="verbatim">MOV ES,ArrayStart
MOV EAX,ES:#0 //EAX = 10
MOV EBX,ES:#2 //EBX = 30
MOV ECX,ES:#1 //ECX = 50

MOV EAX,0
MOV EBX,EAX:#ArrayStart //EBX = 10
INC EAX
MOV EBX,EAX:#ArrayStart //EBX = 50
INC EAX
MOV EBX,EAX:#ArrayStart //EBX = 30

ArrayStart: db 10,50,30
</pre><p>Some of the segment registers are used by the processor for specific tasks, as per the following table:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Register</td><td align="center" nowrap="nowrap" valign="top">Name</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CS</tt></td><td align="center" nowrap="nowrap" valign="top">Code segment</td><td align="left" valign="top">Processor fetches code from this segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>SS</tt></td><td align="center" nowrap="nowrap" valign="top">Data segment</td><td align="left" valign="top">Default segment for data</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DS</tt></td><td align="center" nowrap="nowrap" valign="top">Stack segment</td><td align="left" valign="top">Processor stack is located in this segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ES</tt></td><td align="center" nowrap="nowrap" valign="top">Extra segment</td><td align="left" valign="top">User segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>GS</tt></td><td align="center" nowrap="nowrap" valign="top">G segment</td><td align="left" valign="top">User segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>FS</tt></td><td align="center" nowrap="nowrap" valign="top">F segment</td><td align="left" valign="top">User segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>KS</tt></td><td align="center" nowrap="nowrap" valign="top">Key segment</td><td align="left" valign="top">User segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>LS</tt></td><td align="center" nowrap="nowrap" valign="top">Library segment</td><td align="left" valign="top">User segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>All segment registers other than <tt>CS</tt> can be directly set by using the <tt>MOV</tt> operation. The only way to modify the <tt>CS</tt> is to execute <tt>CALLF</tt> or <tt>JMPF</tt> instructions (see: <a href="#branching">??</a> for more information):
</p><pre class="verbatim">//CS = 0
//IP = 928

JMPF 500,100;

//CS = 100
//IP = 500
</pre><p>Attempting to set <tt>CS</tt> directly will trigger interrupt <tt>13:1</tt> (general processor fault). For example:
</p><pre class="verbatim">MOV DS,100
MOV ES,KS
MOV CS,1000 //Will generate interrupt 13:1
</pre><p>After CPU reset all segment registers will be initialized to <tt>0</tt>.</p>
<h2 class="section"><p>
The ZCPU is capable of working in several different memory modes. Linear
 addressing mode is the default mode, and it is the mode in use when the
 CPU is reset.</p><p>Different modes require different use of registers 
and provide different execution features. Each mode will usually require
 extended processor mode to be active, enabling some advanced memory 
protection features such as page permissions and memory mapping.</p><p>It
 is important to be aware of how memory access actually works. When a 
memory request occurs (read or write) these are the actions that will be
 undertaken by the CPU:</p><ol class="enumerate" type="1"><li class="li-enumerate">
	Check <tt>BusLock</tt> register. If this register is set to 1 the request will fail.
	</li><li class="li-enumerate">Validate the address. The address must be a 48-bit integer value.
	</li><li class="li-enumerate">Fetch page that corresponds to the requested address.
	</li><li class="li-enumerate">If <tt>EF</tt> flag is set check if 
current runlevel is less or equal to target page runlevel and check if 
it’s possible to read/write on the page.
	</li><li class="li-enumerate">If page has <tt>Mapped</tt> flag set then change the address accordingly.
	</li><li class="li-enumerate">Perform the I/O operation.
</li></ol>
<h3 class="subsection"><p>
This is the default address mode when all segment registers are initialized to <tt>0</tt>.
 This mode is available after the initial processor startup. Since all 
registers are set to zero, in this mode the code, data and stack are all
 located in same address space. </p><p>No segment prefixes are required in this mode. For example you can access the processor stack without specifying the <tt>SS</tt> prefix:</p><pre class="verbatim">MOV EAX,#0  //EAX will be equal to 14 (MOV opcode no)
MOV #ESP,100 //Same as PUSH 100
DEC ESP
POP EAX     //EAX will be equal to 100
</pre>
<h3 class="subsection"><p>
This is the most common addressing mode when segment registers are used 
differently. For example, the code, data and stack might all be located 
in different areas of memory. This has certain benefits:</p><ul class="itemize"><li class="li-itemize">
Allows to prevent accidental data/code corruption
</li><li class="li-itemize">Same code can be used for different blocks of data
</li><li class="li-itemize">Programs can run in local address space, not aware of different programs (for example BIOS)
</li></ul><p>Example:
</p><pre class="verbatim">MOV DS,1000 //Set first data block
MOV SS,2000 //Set first stack block
CALLF 0,500 //Call the routine (CS will be set to 500, IP to 0)

MOV DS,3000 //Set second data block
MOV SS,4000 //Set second stack block
CALLF 0,500 //Call the same routine, but now
            //working on different data block
</pre><p>This will run the same routine (located at physical offset <tt>500</tt>) on two different sets of data. Thus the same subprogram can be reused for different sets of variables.</p>
<h3 class="subsection"><p>
Mapped memory mode uses the memory mapping features of the processor to 
reroute memory addresses in order to create the appearance of a single 
continuous address space for the user program. This mode allows user 
programs to dynamically allocate blocks of data, which can themselves be
 physically located in different areas of memory. This also allows use 
of dynamic libraries, where single library loaded once can be used in 
many programs while remaining in a single place in physical memory.</p><p>see: <a href="#paging">??</a> for more information.</p>
<h2 class="section"><p> <a name="stack"></a>
The Zyelios CPU has a built-in hardware processor stack. Stack operation is controlled by the current stack pointer register (<tt>ESP</tt>), the stack size register (<tt>ESZ</tt>) and the stack segment register (<tt>SS</tt>) Stack data is located in physical RAM.</p><p><tt>ESP</tt> points to the <em>next free value on the stack</em>. The stack grows <em>down</em>.</p><p><tt>PUSH</tt> and <tt>POP</tt> are used to push or pop values to or from the stack, respectively. Stack overflow or underflow is indicated by the interrupt <tt>6:ESP</tt> (stack error). The interrupt parameter will be set to the value of <tt>ESP</tt>. For example:</p><pre class="verbatim">MOV SS,5000   //Stack starts at offset 5000
MOV ESP,2999  //Stack is 3000 bytes in size
              //Next free offset in segment is 2999
CPUSET 9,3000 //Set ESZ register

PUSH 200
PUSH 100
POP EAX //EAX = 100
POP EBX //EBX = 200

//PUSH X is same as the following (but with error checks):
MOV SS:#ESP,X
DEC ESP

//POP Y is same as the following (but with error checks):
INC ESP
MOV Y,SS:#ESP
</pre><p>Additionally, the <tt>RSTACK</tt> and <tt>SSTACK</tt> 
instructions allow the user to read or write an arbitrary position on 
the stack. These instructions may also trigger stack underflow or 
overflow interrupts. The following example illustrates the use of <tt>RSTACK</tt> and <tt>SSTACK</tt>:</p><pre class="verbatim">RSTACK X,Y //X = MEMORY[SS+Y]
SSTACK X,Y //MEMORY[SS+X] = Y

RSTACK EAX,ESP:1 //Read stack top
RSTACK EAX,ESP:2 //Read value under stack top

PUSH 100 //
PUSH 200 //Value under top value
PUSH 300 //Value on top

SSTACK ESP:2,123 //Set value under stack top
POP EAX //EAX = 300
POP EBX //EBX = 123
POP ECX //ECX = 100
</pre>
<h2 class="section"><p> <a name="branching"></a>
The Zyelios CPU supports various kinds of branching: conditional or 
unconditional, absolute or relative. The instruction pointer (<tt>IP</tt>) points to the currently executing instruction. All branching instructions modify <tt>IP</tt>; some also modify <tt>CS</tt> (see: <a href="#segments">??</a>).</p><p>The simpliest type of branching is absolute unconditional. To perform an unconditional jump, <tt>JMP</tt> or <tt>JMPF</tt> are used (the latter also modifies <tt>CS</tt>).</p><p>Program subroutines can be called by using <tt>CALL</tt> or <tt>CALLF</tt>. This will save current the instruction pointer (and <tt>CS</tt> when <tt>CALLF</tt>
 is used) to the processor stack. The instruction pointer (and code 
segment if required) can be restored from the stack by using <tt>RET</tt> or <tt>RETF</tt> accordingly.</p><p>The following example illustrates creating routines and jumping:</p><pre class="verbatim">JMPF MAIN,CODE_SEGMENT //Syntax is JMPF IP,CS

......

MAIN: //A label
  CALL SUBROUTINE
  JMP EXIT

SUBROUTINE:
  CALL SUBROUTINE2
RET //Exit subroutine

SUBROUTINE2: //Called inside SUBROUTINE
  ... do something ...
RET
......

EXIT:
</pre><p>It is possible to perform a relative jump. To do this, <tt>JMPR</tt> (jump relative) is used. This instruction adds or subtracts <tt>IP</tt> by a certain amount instead of giving a specific number. For example example:</p><pre class="verbatim">JMPR +10 //Jump 10 bytes forward
JMPR -10 //Jump 10 bytes backward

JMPR LABEL-__PTR__ //Jump to label
                   //__PTR__ label always points
                   //to current write pointer

......

LABEL:
</pre><p>Conditional branching allows program flow to be changed depending on certain conditions. <tt>CMP</tt> is used to compare two values, and instructions from the following table react accordingly:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Instruction</td><td align="center" nowrap="nowrap" valign="top">Operation</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNE</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt;&gt; Y</td><td align="left" valign="top">Jump if not equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNZ</tt></td><td align="center" nowrap="nowrap" valign="top">X - Y &lt;&gt; 0</td><td align="left" valign="top">Jump if not zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JG</tt></td><td align="center" nowrap="nowrap" valign="top">X &gt; Y</td><td align="left" valign="top">Jump if greater than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNLE</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &lt;= Y</td><td align="left" valign="top">Jump if not less or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JGE</tt></td><td align="center" nowrap="nowrap" valign="top">X &gt;= Y</td><td align="left" valign="top">Jump if greater or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNL</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &lt; Y</td><td align="left" valign="top">Jump if not less than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JL</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt; Y</td><td align="left" valign="top">Jump if less than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNGE</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &gt;= Y</td><td align="left" valign="top">Jump if not greater or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JLE</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt;= Y</td><td align="left" valign="top">Jump if less or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNG</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &gt; Y</td><td align="left" valign="top">Jump if not greater than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JE</tt></td><td align="center" nowrap="nowrap" valign="top">X = Y</td><td align="left" valign="top">Jump if equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JZ</tt></td><td align="center" nowrap="nowrap" valign="top">X - Y = 0</td><td align="left" valign="top">Jump if zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>CNE</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt;&gt; Y</td><td align="left" valign="top">Call if not equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CNZ</tt></td><td align="center" nowrap="nowrap" valign="top">X - Y &lt;&gt; 0</td><td align="left" valign="top">Call if not zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CG</tt></td><td align="center" nowrap="nowrap" valign="top">X &gt; Y</td><td align="left" valign="top">Call if greater than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CNLE</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &lt;= Y</td><td align="left" valign="top">Call if not less or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CGE</tt></td><td align="center" nowrap="nowrap" valign="top">X &gt;= Y</td><td align="left" valign="top">Call if greater or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CNL</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &lt; Y</td><td align="left" valign="top">Call if not less than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CL</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt; Y</td><td align="left" valign="top">Call if less than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CNGE</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &gt;= Y</td><td align="left" valign="top">Call if not greater or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CLE</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt;= Y</td><td align="left" valign="top">Call if less or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CNG</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &gt; Y</td><td align="left" valign="top">Call if not greater than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CE</tt></td><td align="center" nowrap="nowrap" valign="top">X = Y</td><td align="left" valign="top">Call if equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CZ</tt></td><td align="center" nowrap="nowrap" valign="top">X - Y = 0</td><td align="left" valign="top">Call if zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>JNER</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt;&gt; Y</td><td align="left" valign="top">Jump relative if not equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNZR</tt></td><td align="center" nowrap="nowrap" valign="top">X - Y &lt;&gt; 0</td><td align="left" valign="top">Jump relative if not zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JGR</tt></td><td align="center" nowrap="nowrap" valign="top">X &gt; Y</td><td align="left" valign="top">Jump relative if greater than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNLER</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &lt;= Y</td><td align="left" valign="top">Jump relative if not less or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JGER</tt></td><td align="center" nowrap="nowrap" valign="top">X &gt;= Y</td><td align="left" valign="top">Jump relative if greater or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNLR</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &lt; Y</td><td align="left" valign="top">Jump relative if not less than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JLR</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt; Y</td><td align="left" valign="top">Jump relative if less than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNGER</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &gt;= Y</td><td align="left" valign="top">Jump relative if not greater or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JLER</tt></td><td align="center" nowrap="nowrap" valign="top">X &lt;= Y</td><td align="left" valign="top">Jump relative if less or equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JNGR</tt></td><td align="center" nowrap="nowrap" valign="top">NOT X &gt; Y</td><td align="left" valign="top">Jump relative if not greater than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JER</tt></td><td align="center" nowrap="nowrap" valign="top">X = Y</td><td align="left" valign="top">Jump relative if equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>JZR</tt></td><td align="center" nowrap="nowrap" valign="top">X - Y = 0</td><td align="left" valign="top">Jump relative if zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>There are other instruction which perform branch testing, such as <tt>BIT</tt>, which tests specific bits of a given value. For example: <a name="branchbit"></a></p><pre class="verbatim">CMP EAX,EBX
JG  LABEL1 //Jump if EAX &gt;  EBX
JLE LABEL2 //Jump if EAX &lt;= EBX
JE  LABEL3 //Jump if EAX  = EBX
CL  LABEL4 //Call if EAX &lt;  EBX
CGE LABEL5 //Call if EAX &gt;= EBX

BIT EAX,4 //Test 5th bit of EAX
JZ  LABEL1 //Jump if 5th bit is 0
JNZ LABEL1 //Jump if 5th bit is 1
</pre>
<h2 class="section"><p><a name="errorcodes"></a>
There are several error codes that might be generated during program execution. Each error condition generates an interrupt.</p><p>If
 processor is not in extended mode, code execution will halt when the 
error is generated. Upon encountering an error, the processor will halt 
and output the error code to <tt>ERROR</tt> processor output. It will also emit a secondary error code in the fraction part of the <tt>ERROR</tt> processor output. If the processor is in extended mode, the corresponding interrupt will be called instead.</p><p>For example, a typical output might be <tt>7.65536</tt>, which would indicate a memory read/write fault at address 65536.</p><p>The
 error code will be reset to zero when the CPU is reset. The following 
are error codes are defined by the current version of the processor:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Code</td><td align="center" nowrap="nowrap" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>02</tt></td><td align="center" nowrap="nowrap" valign="top">End of program execution</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>03</tt></td><td align="center" nowrap="nowrap" valign="top">Division by zero</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>04</tt></td><td align="center" nowrap="nowrap" valign="top">Unknown opcode</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>05</tt></td><td align="center" nowrap="nowrap" valign="top">Internal processor error</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>06</tt></td><td align="center" nowrap="nowrap" valign="top">Stack error (overflow/underflow)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>07</tt></td><td align="center" nowrap="nowrap" valign="top">Memory read/write fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>08</tt></td><td align="center" nowrap="nowrap" valign="top">MemBus fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>09</tt></td><td align="center" nowrap="nowrap" valign="top">Write access violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>10</tt></td><td align="center" nowrap="nowrap" valign="top">Port read/write fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>11</tt></td><td align="center" nowrap="nowrap" valign="top">Page acccess violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>12</tt></td><td align="center" nowrap="nowrap" valign="top">Read access violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>13</tt></td><td align="center" nowrap="nowrap" valign="top">General processor fault</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>14</tt></td><td align="center" nowrap="nowrap" valign="top">Execute access violation (page protection)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>15</tt></td><td align="center" nowrap="nowrap" valign="top">Address space violation</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote>
<h3 class="subsection"><p><b>Error message</b>: STOP detected<br>
<b>Occurs when</b>: <tt>STOP</tt>/<tt>OPCODE 0</tt> is executed<br>
<b>Cause</b>: Abnomal program end<br>
<b>Result</b>: None</p><p><br>
</p><p><b>Error message</b>: Invalid opcode<br>
<b>Occurs when</b>: Any of the branching instructions is executed (<tt>JMP</tt>, <tt>CALL</tt>, etc)<br>
<b>Cause</b>: Jumping by offset that does not point to valid ZCPU instruction<br>
<b>Result</b>: None</p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Unable to divide by zero<br>
<b>Occurs when</b>: Second operand for <tt>DIV</tt> opcode is zero<br>
<b>Cause</b>: User error<br>
<b>Result</b>: <tt>LADD = 1</tt></p><p><br>
</p><p><b>Error message</b>: Unable to perform inversion on a zero<br>
<b>Occurs when</b>: Calling <tt>FINV</tt> opcode with zero operand<br>
<b>Cause</b>: User error<br>
<b>Result</b>: <tt>LADD = 2</tt></p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Unknown opcode detected in the instruction stream<br>
<b>Occurs when</b>: Next executed instruction is not one of the recognized instructions<br>
<b>Cause</b>: Invalid branching operation is performed (processor attempts to execute data)<br>
<b>Result</b>: <tt>LADD = OPCODE NUMBER</tt></p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Unable to execute instruction (microcode error)<br>
<b>Occurs when</b>: An internal error has ocurred while executing microcode<br>
<b>Cause</b>: Encountering a bug in processor<br>
<b>Result</b>: <tt>LADD = 01</tt></p><p><br>
</p><p><b>Error message</b>: Unknown internal error<br>
<b>Occurs when</b>: Never<br>
<b>Cause</b>: None<br>
<b>Result</b>: <tt>LADD = 02</tt></p><p><br>
</p><p><b>Error message</b>: Read error while fetching the instruction<br>
<b>Occurs when</b>: Instruction decoder was not able to fetch all of the instruction bytes<br>
<b>Cause</b>: <tt>JMP</tt> or <tt>CALL</tt> to a memory location outside of physical/logical range<br>
<b>Result</b>: <tt>LADD = 12</tt></p><p><br>
</p><p><b>Error message</b>: Could not fetch an immediate byte for operand 1<br>
<b>Occurs when</b>: Instruction decoder was not able to fetch an immediate byte for the first operand<br>
<b>Cause</b>: <tt>JMP</tt> or <tt>CALL</tt> to a memory location outside of physical/logical range<br>
<b>Result</b>: <tt>LADD = 22</tt></p><p><br>
</p><p><b>Error message</b>: Could not fetch an immediate byte for operand 2<br>
<b>Occurs when</b>: Instruction decoder was not able to fetch an immediate byte for the second operand<br>
<b>Cause</b>: <tt>JMP</tt> or <tt>CALL</tt> to a memory location outside of physical/logical range<br>
<b>Result</b>: <tt>LADD = 32</tt></p><p><br>
</p><p><b>Error message</b>: Invalid RM parameter for operand 1<br>
<b>Occurs when</b>: Never<br>
<b>Cause</b>: None<br>
<b>Result</b>: <tt>LADD = 42</tt></p><p><br>
</p><p><b>Error message</b>: Invalid RM parameter for operand 2<br>
<b>Occurs when</b>: Never<br>
<b>Cause</b>: None<br>
<b>Result</b>: <tt>LADD = 52</tt></p><p><br>
</p><p><b>Error message</b>: Target operand not writeable<br>
<b>Occurs when</b>: Never<br>
<b>Cause</b>: None<br>
<b>Result</b>: <tt>LADD = 62</tt></p><p><br>
</p><p><b>Error message</b>: Source operand not writeable (<tt>XCHG</tt> instruction only)<br>
<b>Occurs when</b>: Never<br>
<b>Cause</b>: None<br>
<b>Result</b>: <tt>LADD = 72</tt></p><p><br>
</p><p><b>Error message</b>: Unknown opcode<br>
<b>Occurs when</b>: Never<br>
<b>Cause</b>: None<br>
<b>Result</b>: <tt>LADD = 82</tt></p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Stack overflow error<br>
<b>Occurs when</b>: <tt>PUSH</tt> is executed<br>
<b>Cause</b>: <tt>ESP</tt> register value becomes negative<br>
<b>Result</b>: <tt>LADD = 0</tt></p><p><br>
</p><p><b>Error message</b>: Stack underflow error<br>
<b>Occurs when</b>: <tt>POP</tt> is executed<br>
<b>Cause</b>: <tt>ESP</tt> register is greater than <tt>ESZ</tt><br>
<b>Result</b>: <tt>LADD = ESZ</tt></p><p><br>
</p><p><b>Error message</b>: Stack read error<br>
<b>Occurs when</b>: <tt>POP</tt> is executed<br>
<b>Cause</b>: Unable to read value from memory<br>
<b>Result</b>: <tt>LADD = ESP</tt></p><p><br>
</p><p><b>Error message</b>: Stack out of bounds error<br>
<b>Occurs when</b>: <tt>RSTACK</tt> or <tt>SSTACK</tt> is executed<br>
<b>Cause</b>: Requested value out of stack bounds<br>
<b>Result</b>: <tt>LADD</tt> equals to requested index on stack</p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Read error: address does not exist<br>
<b>Occurs when</b>: Processor attempts to read a value from outside of the internal RAM<br>
<b>Cause</b>: No device is attached to the MemBus<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p><p><b>Error message</b>: Read error: unable to read memory location<br>
<b>Occurs when</b>: Processor attempts to read a value from outside of the internal RAM<br>
<b>Cause</b>: A failure has occured while attempting to read a value (value out of the device address range)<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p><p><b>Error message</b>: Write error: address does not exist<br>
<b>Occurs when</b>: Processor attempts to write a value to outside of the internal RAM<br>
<b>Cause</b>: No device is attached to the MemBus<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p><p><b>Error message</b>: Write error: unable to write to memory location<br>
<b>Occurs when</b>: Processor attempts to write a value to outside of the internal RAM<br>
<b>Cause</b>: A failure has occured while attempting to write a value (value out of the device address range)<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: MemBus device error<br>
<b>Occurs when</b>: Processor attempts to read a value from outside of the internal RAM<br>
<b>Cause</b>: Device currently attached to MemBus does not support hispeed interface<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p><p><b>Error message</b>: IOBus device error<br>
<b>Occurs when</b>: Processor attempts to read a value from a port<br>
<b>Cause</b>: Device currently attached to IOBus does not support hispeed interface<br>
<b>Result</b>: <tt>LADD = -PORT_NUMBER</tt></p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Access violation<br>
<b>Occurs when</b>: Attempting to write a value<br>
<b>Cause</b>: <tt>EF</tt> flag set to 1, no write permission on 
referenced page, and referenced by the address has a smaller runlevel 
than the current one.<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Read error: unable to read a port<br>
<b>Occurs when</b>: Processor attempts to read a value from a port<br>
<b>Cause</b>: A failure has occured while attempting to read a value (value out of he device address range)<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p><p><b>Error message</b>: Write error: unable to write to a port<br>
<b>Occurs when</b>: Processor attempts to write a value to a port<br>
<b>Cause</b>: A failure has occured while attempting to write a value (value out of the device address range)<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Unable to set page readonly<br>
<b>Occurs when</b>: <tt>SPG</tt> opcode is executed<br>
<b>Cause</b>: Current runlevel greater than runlevel of the refernced page<br>
<b>Result</b>: <tt>LADD</tt> points to referenced page</p><p><br>
</p><p><b>Error message</b>: Unable to set page read- and writeable<br>
<b>Occurs when</b>: <tt>CPG</tt> opcode is executed<br>
<b>Cause</b>: Current runlevel greater than runlevel of the refernced page<br>
<b>Result</b>: <tt>LADD</tt> points to referenced page</p><p><br>
</p><p><b>Error message</b>: Unable to set page flag<br>
<b>Occurs when</b>: <tt>SPP</tt> opcode is executed<br>
<b>Cause</b>: Current runlevel greater than runlevel of the refernced page<br>
<b>Result</b>: <tt>LADD</tt> points to referenced page</p><p><br>
</p><p><b>Error message</b>: Unable to clear page flag<br>
<b>Occurs when</b>: <tt>CPP</tt> opcode is executed<br>
<b>Cause</b>: Current runlevel greater than runlevel of the refernced page<br>
<b>Result</b>: <tt>LADD</tt> points to referenced page</p><p><br>
</p><p><b>Error message</b>: Unable to set page runlevel<br>
<b>Occurs when</b>: <tt>SRL</tt> opcode is executed<br>
<b>Cause</b>: Current runlevel greater than runlevel of the refernced page<br>
<b>Result</b>: <tt>LADD</tt> points to referenced page</p><p><br>
</p><p><b>Error message</b>: Unable to set page mapping<br>
<b>Occurs when</b>: <tt>SMAP</tt> opcode is executed<br>
<b>Cause</b>: Current runlevel greater than runlevel of the refernced page<br>
<b>Result</b>: <tt>LADD</tt> points to referenced page</p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Access violation<br>
<b>Occurs when</b>: Attempting to read a value<br>
<b>Cause</b>: <tt>EF</tt> flag set to 1, no read permission on 
referenced page, and referenced by the address has a smaller runlevel 
than the current one.<br>
<b>Result</b>: <tt>LADD</tt> equals to faulty address in memory</p><p><br>
</p><p><b>Error message</b>: Referenced page outside ROM<br>
<b>Occurs when</b>: <tt>ERPG</tt> opcode executed<br>
<b>Cause</b>: Page referenced by the instruction could not be erased, because it lies outside the processor ROM<br>
<b>Result</b>: <tt>LADD = 0</tt></p><p><br>
</p><p><b>Error message</b>: Referenced page outside ROM<br>
<b>Occurs when</b>: <tt>WRPG</tt> opcode executed<br>
<b>Cause</b>: Page referenced by the instruction could not be written, because it lies outside the processor ROM<br>
<b>Result</b>: <tt>LADD = 0</tt></p><p><br>
</p><p><b>Error message</b>: Referenced page outside ROM<br>
<b>Occurs when</b>: <tt>RDPG</tt> opcode executed<br>
<b>Cause</b>: Page referenced by the instruction could not be read, because it lies outside the processor ROM<br>
<b>Result</b>: <tt>LADD = 0</tt></p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Code segment write violation<br>
<b>Occurs when</b>: <tt>CS</tt> value is being used as a target operand<br>
<b>Cause</b>: An attempt is being made to set a read-only segment register. Use <tt>CALLF</tt> or <tt>JMPF</tt> instructions to modify the CS register<br>
<b>Result</b>: <tt>LADD = 1</tt></p><p><br>
</p><p><b>Error message</b>: Unable to read interrupt table<br>
<b>Occurs when</b>: Could not fetch entry from interrupt table<br>
<b>Cause</b>: Invalid interrupt table location set with <tt>LIDTR</tt><br>
<b>Result</b>: <tt>LADD = 2</tt></p><p><br>
</p><p><b>Error message</b>: Invalid interrupt number<br>
<b>Occurs when</b>: Interrupt outside of the acceptable boundary (0..255) is called<br>
<b>Cause</b>: Misuse of the <tt>INT</tt> or the <tt>EXTINT</tt> instructions<br>
<b>Result</b>: <tt>LADD = 3</tt></p><p><br>
</p><p><b>Error message</b>: Unprivileged external interrupt call<br>
<b>Occurs when</b>: External interrupt was called while the appropriate flag was not set in the interrupt table<br>
<b>Cause</b>: <tt>6th</tt> bit not set for the external interrupt in the interrupt table, and the external interrupt is called<br>
<b>Result</b>: <tt>LADD = 4</tt></p><p><br>
</p><p><b>Error message</b>: Incompatible mode<br>
<b>Occurs when</b>: Interrupt call in protected (compatibility) mode with less than 512 bytes of RAM<br>
<b>Cause</b>: Not enough RAM to contain a complete interrupt table<br>
<b>Result</b>: <tt>LADD = 5</tt></p><p><br>
</p><p><b>Error message</b>: Unable to push return data<br>
<b>Occurs when</b>: Interrupt handler was unable to push return data onto the processor stack<br>
<b>Cause</b>: Interrupt was called with no stack space available<br>
<b>Result</b>: <tt>LADD = 6</tt></p><p><br>
</p><p><b>Error message</b>: Unable to call an interrupt<br>
<b>Occurs when</b>: Interrupt is called without sufficient rights<br>
<b>Cause</b>: Interrupt is called without sufficient rights to complete the jump<br>
<b>Result</b>: <tt>LADD = 7</tt></p><p><br>
</p><p><b>Error message</b>: Unable to read page table<br>
<b>Occurs when</b>: Page table is not located in valid memory range<br>
<b>Cause</b>: Page table is not located in valid memory range<br>
<b>Result</b>: <tt>LADD = 8</tt></p><p><br>
</p><p><b>Error message</b>: Attempting to execute a privileged instruction<br>
<b>Occurs when</b>: Could not execute a privileged instruction due to runlevel<br>
<b>Cause</b>: Calling one of the following instructios without sufficient rights: <tt>RD</tt>, <tt>WD</tt>, <tt>SPG</tt>, <tt>CPG</tt>, <tt>STI</tt>, <tt>CLI</tt>, <tt>STP</tt>, <tt>CLP</tt>, <tt>STEF</tt>, <tt>CLEF</tt>, <tt>EXTINT</tt>, <tt>ERPG</tt>, <tt>WRPG</tt>, <tt>RDPG</tt>, <tt>LIDTR</tt>, <tt>EXTRET</tt>, <tt>IDLE</tt>, <tt>STD2</tt>, <tt>STM</tt>, <tt>CLM</tt>, <tt>CPUGET</tt>, <tt>CPUSET</tt>, <tt>CPP</tt>, <tt>SPP</tt>, <tt>SRL</tt>, <tt>GRL</tt>, <tt>SMAP</tt>, <tt>GMAP</tt><br>
<b>Result</b>: <tt>LADD = Opcode number</tt></p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Access violation<br>
<b>Occurs when</b>: Execution is attempted on a memory page that does not allow execution<br>
<b>Cause</b>: Invalid branching into the protected memory areas<br>
<b>Result</b>: <tt>LADD = Page number</tt></p><p><br>
</p><p><b>Error message</b>: Access violation<br>
<b>Occurs when</b>: Execution is attempted on a memory page that does not allow execution<br>
<b>Cause</b>: Code execution has entered page that does not allow execution<br>
<b>Result</b>: <tt>LADD = Page number</tt></p><p><br>
</p>
<h3 class="subsection"><p><b>Error message</b>: Address space violation<br>
<b>Occurs when</b>: Memory is accessed by an invalid address<br>
<b>Cause</b>: Address is not a 48-bit signed integer<br>
<b>Result</b>: <tt>LADD = Referenced invalid address</tt></p><p><br>
</p>
<h1 class="chapter">
<h2 class="section"><p> <a name="advexecution"></a>
This section describes instruction execution in complete detail. The 
processor will fetch instructions sequentially, decode them, and then 
execute.</p><p>During execution the <tt>XEIP</tt> register points to the instruction start address in global memory space, while the <tt>IP</tt> register is incremented as the instruction bytes are fetched in sequence.</p><p>The execution will also increment <tt>TMR</tt> register by amount of cycles that have been required to complete this instruction. The <tt>CODEBYTES</tt> register is incremented each time next byte is fetched by the instruction decoder (so the <tt>CODEBYTES</tt> register counts the total size of executable code executed so far).</p><pre class="verbatim">//TMR = 170

MOV EAX,10; //1-cycle instructions
ADD EAX,EBX;

//TMR = 172
</pre><p>The instruction decoder will set <tt>CPAGE</tt> register to number of the current page (the page that fetched instruction is located on), and <tt>PPAGE</tt> to number of the page previous instruction was located on. <em>Current page is determined by the location of the first fetched byte of the currently executed instruction</em>.</p><p>When <tt>CPAGE</tt> and <tt>PPAGE</tt>
 values mismatch the permission check logic is triggered. Peforming a 
jump of any sort will run a different check logic, and will reset both <tt>CPAGE</tt> and <tt>PPAGE</tt> to page the target jump offset is located on.</p><p>The instructions can be either fixed-sized or variable-sized, see: <a href="#localexec">??</a>.</p><p>This is the Pseudocode for the instruction decoding procedure:</p><pre class="verbatim">// Calculate absolute execution address and set current page
XEIP = IP + CS
SetCurrentPage(floor(XEIP/128))

// Do not allow execution if we are not on kernel
// page, or not calling from kernel page
if (PCAP == 1) and (CurrentPage.Execute == 0) and 
   (PreviousPage.RunLevel &lt;&gt; 0) then
  Interrupt(14,CPAGE)
end

// Reset interrupts flags
INTR = 0
if NIF &lt;&gt; undefined then
  IF = NIF
  NIF = undefined
end

// Fetch instruction and RM byte
Opcode = Fetch()
RM = 0
isFixedSize = false

// Check if it is a fixed-size instruction
if ((Opcode &gt;= 2000) and (Opcode &lt; 4000)) or
   ((Opcode &gt;= 12000) and (Opcode &lt; 14000)) then
  Opcode = Opcode - 2000
  isFixedSize = true
end

// Fetch RM if required
if (OperandCount &gt; 0) or
   (Precompile_Peek() == 0) or 
   (isFixedSize) then
  RM = Fetch()
end

// If failed to fetch opcode/RM then report an error
if INTR == 1 then
  IF = 1
  Interrupt(5,12)
end

// Check opcode runlevel
if (PCAP == 1) and (CurrentPage.Runlevel &gt; RunLevel[Opcode]) then
  Interrupt(13,Opcode)
end

// Decode RM byte
dRM2 = floor(RM / 10000)
dRM1 = RM - dRM2*10000

// Default segment offsets
Segment1 = -4
Segment2 = -4

// Decode segment offsets
if Opcode &gt; 1000 then
  if Opcode &gt; 10000 then
    Segment2 = Fetch()

    Opcode = Opcode-10000
    if Opcode &gt; 1000 then
      Segment1 = Fetch()
      
      Opcode = Opcode-1000
      Segment1 &lt;&gt; Segment 2
    else
      if isFixedSize then
        Fetch()
      end
    end
  else
    Segment1 = Fetch()
    Opcode = Opcode-1000
    if isFixedSize then
      Fetch()
    end
  end
elseif isFixedSize then
  Fetch()
  Fetch()
end

// If failed to fetch segment prefix then report an error
if INTR == 1 then
  Interrupt(5,12)
end

// Check if opcode is invalid
if opcode is not valid then
  Interrupt(4,Opcode)
else
  // Fetch immediate values if required
  if isFixedSize then
    OperandByte1 = Fetch()
    if INTR == 1 then 
      Interrupt(5,22)
    end
    OperandByte2 = Fetch()
    if INTR == 1 then 
      Interrupt(5,32)
    end
  else
    if OperandCount &gt; 0 then
      if NeedFetchByte1 then
        OperandByte1 = Fetch()
        // If failed to read the byte, report an error
        if INTR == 1 then 
          Interrupt(5,22)
        end
      end
      if OperandCount &gt; 1 then
        if NeedFetchByte2 then
          OperandByte2 = Precompile_Fetch() or 0
          // If failed to read the byte, report an error
          if INTR == 1 then
            Interrupt(5,32)
          end
        end
      end
    end
  end
  
  // Execute instruction
  Execute()

  // Write back the values
  if OperandCount &gt; 0 then
    WriteBack(1)
    if OperandCount &gt; 1 then
      WriteBack(2)
    end
  end
end

// Advance timers and counters
CODEBYTES = CODEBYTES + Instruction_Size
TMR = TMR + Instrucion_Cycles
TIMER = TIMER + TimerDT

// Set this page as previous (if it is executable)
XEIP = IP + CS
SetPreviousPage(floor(XEIP/128))  
</pre>
<h2 class="section"><p> <a name="paging"></a>
The Zyelios CPU divides the entire accessable memory space into pages. 
Every page is 128 bytes in size. Pages are numbered sequentially; This 
means that addresses 0, 1, ... 127 belong to page 0, addresses 128 .. 
255 belong to page 1, 256 .. 383 belong to page 2 and so on.</p><p>Every page can have a separate permission mask (read permission, write permission, execute permission) and runlevel.</p><p>Runlevel
 is a number that can be used to divide code into different permission 
levels, with higher levels reflecting kernel-mode code and lower levels 
reflecting user-level code. Each runlevel is a number between 0 and 255 
inclusive. Higher permission levels are those that are closer to 0. 
Lower permission levels are those that are closer to 255. Code executing
 from a page with a higher permission level can read or write pages of a
 lower runlevel, but the opposite cannot occur.</p><pre class="verbatim">SRL 1,12 //Set page 1 runlevel to 12
//Page 1 is addresses 128..255

SPP 5,0 //Set page 5 to be readable
CPP 6,1 //Make page 6 non-writeable
CPP 7,2 //Prevent code execution on page 7
</pre><p>Runlevel 0 is a special runlevel which will ignore all 
permission settings. This runlevel is also capable of running several 
privileged instructions such as <tt>CPUSET</tt>. All others runlevels follow page permissions.</p><p>When
 a page is marked non-readable, it can only be read from a page with a 
higher runlevel. When a page is marked non-writeable it can only be 
written from a page with smaller runlevel. When a page is marked 
non-executable, then only code from runlevel 0 can branch into this 
page.</p><p>Every page can also be remapped to any other page in memory.
 This means that every time the processor accessess target page, the 
data will be read from a different physical address. Any page can be 
remapped, even if the page already points to valid memory.</p><pre class="verbatim">MOV #130,1234 //Set cell 2 of page 1 to 1234
SMAP 0,1 //Remap page 0 to page 1
MOV EAX,#2 //Read cell 2 of page 0 (but really read from page 1)
//EAX is now set to 1234
</pre><p>Page mapping and permissions settings are stored in the <em>page table</em>. The page table is active when the processor has the extended memory mode enabled (<tt>MF</tt> set to 1). If <tt>MF</tt>
 is set to 0 the page table will be stored internally; if it is set to 1
 the page table will be stored in RAM. The actual permission checks are 
being made only when <tt>EF</tt> flag is set to 1, and the processor is running in the extended mode.</p><p>The <tt>PTBL</tt> internal register is an <em>absolute</em> pointer to the table start, and <tt>PTBE</tt> holds the number of entires in the table. It is possible to switch page tables during execution.</p><p>Every
 page table entry is 2 bytes in size. The first entry (entry number 0) 
is the default page. All other pages in the table correspond to memory 
pages.</p><p>If the address being accessed is not covered by any page 
listed in the page table, it will use the permissions set on the default
 page entry. You cannot perform memory mapping on pages which do not 
have entry in page table.</p><p>The first byte of every entry holds the 
runlevel and permission flags. The second byte holds index of page this 
page should be remapped to. Note that permission flags in the page table
 entry are <em>inverted</em>; 1 means the permission is restricted and 0 means that it is not.</p><p>Example on how to setup a page table:
</p><pre class="verbatim">PageTable:
  alloc 513*2 //512 page entries + default for 64KB of RAM
  
  .....
  
//Setup page table
CPUSET 37,PageTable //PTBL
CPUSET 38,512 //PTBE

//Enable extended memory mode
STM

//Indirect table manipulation
SMAP 0,1 //Map page 0 to 1
SPP 5,0 //Set page 5 to be readable

//Direct table manipulation
MOV ESI,PageTable; //Table offset
MOV ESI:#0,0xE0; //Set default page permissions to not allow anything
MOV ESI:#2,0; //Disable page 0
MOV ESI:#5,10; //Remap page 1 to page 10
</pre><p>The layout of the first byte of each entry is as follows:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Bit</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>00</tt></td><td align="left" valign="top">Is page disabled? Set to 1 to disable this page</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>01</tt></td><td align="left" valign="top">Is page remapped? Set to 1 to remap this page</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>02</tt></td><td align="left" valign="top">Page must generate external interrupt 30 (page trap) upon access</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>03</tt></td><td align="left" valign="top">Page trap overrides read/write (generates external interrupts 28, 29)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>04</tt></td><td align="left" valign="top">Reserved</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>05</tt></td><td align="left" valign="top">Read permissions (0: allowed, 1: disabled)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>06</tt></td><td align="left" valign="top">Write permissions (0: allowed, 1: disabled)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>07</tt></td><td align="left" valign="top">Execute permissions (0: allowed, 1: disabled)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>08..15</tt></td><td align="left" valign="top">Runlevel</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>Disabled
 pages will cause a memory fault when a read is attempted to any address
 in its range (as if page wasn’t in the address space). Remapped pages 
will use the second byte in the entry as the index for the <em>physical</em> page this page must be remapped to.</p><p>It
 is possible to trap page accesses by setting bits 2 and/or 3. This will
 cause any access to this page to generate external interrupt 28 (read),
 29 (write), or 30 (access) with the page number being accessed as the 
parameter.</p><p>If bit 2 and is set, the external interrupt 30 will be 
generated on memory access attempt. If bit 3 is also set then the 
external interrupts 28 or 29 will be generated instead of the interrupt 
30, and it will be possible to override the result of the memory 
read/write access (see: <a href="#memoverride">??</a> for more info).</p><p><a name="interrupthandlingpg"></a></p><p>There
 are special rules when handling interrupts. Permissions to call the 
interrupts are defined by runlevel of the interrupt table. This means 
you can restrict the user program from calling certain interrupts, but 
the user program would be able to call lower runlevel code using other 
(non-restricted) interrupts. You can imagine it as if you were <tt>CALL</tt>ing
 your interrupt routine from the interrupt table (and not from user 
program). This is the way you can protect your kernel code from 
reading/writing/executing while retaining the ability to run the code 
(via calling interrupts).</p><pre class="verbatim">STEF //Enable extended mode
LIDTR 2048 //Interrupt table at pages 16-23

SRL 16,0 //Set runlevel of interrupts 0..31 to 0
SRL 17,1 //Set runlevel of interrupts 32..63 to 1
SRL 18,2 //Set runlevel of interrupts 64..95 to 2
SRL 19,3 //Set runlevel of interrupts 96..127 to 3
</pre><p>Current page when executing the instructions is determined by the <tt>CPAGE</tt> register. <em>The actual current page is determined by the location of the first fetched byte of the currently executed instruction</em>. The paging system performs permissions checks whenever <tt>PPAGE</tt> (page the previously executed instruction was located on) and <tt>CPAGE</tt> register values mismatch (which corresponds to crossing the page boundary).</p><p>Peforming a jump of any sort will run permission check logic, and will reset both <tt>CPAGE</tt> and <tt>PPAGE</tt> to page the target jump offset is located on.</p><p>It
 is only possible to cross page boundary or perform a jump if execute 
flag of the next (target) page is set to 1, or if it is set to 0 and 
previous page has runlevel 0.</p><p>All external access to the ZCPU 
inside memory will trigger the corresponding read/write permission 
checks. The runlevel for the external access is equal to the value of 
the <tt>XTRL</tt> register (external runlevel). By default the external memory access operations have a runlevel of 0.</p><p>To sum it up, these are all the permission and logic checks performed by the paging system:
</p><ul class="itemize"><li class="li-itemize">
	Boundary permission check (when execution crosses boundary between two pages)
	</li><li class="li-itemize">Jump permission check (execution jumps to a new offset)
</li><li class="li-itemize">Interrupt table permission checks	
	</li><li class="li-itemize">Read/write memory access (to any location)
	</li><li class="li-itemize">External read/write memory access (accessing CPU address space from outside)	
	</li><li class="li-itemize">Read/write address remapping logic
	</li><li class="li-itemize">Page access trapping logic
</li></ul>
<h2 class="section"><p>
The Zyelios CPU can be configured to have built-in ROM and RAM. This 
allows you to store some program code right on the processor chip. The 
contents of ROM will be written into RAM every time the processor is 
reset. The ROM can be read from and written to in software.</p><p>There are three opcodes to work with the internal ROM: <tt>ERPG</tt> (erase ROM page), <tt>WRPG</tt> (write ROM page), <tt>RDPG</tt> (read ROM page).</p><p>See example of use:
</p><pre class="verbatim">ERPG 4 //Erase some data from ROM
WRPG 4 //Write this block of data to ROM
       //After CPU reset it will be still preserved
RDPG 4 //Restore this page from ROM

ORG 512 //Put on page 4
SOME_AREA:
 ... some data ...
</pre>
<h2 class="section"><p> <a name="bitwiseops"></a>
The ZCPU can work with integer values of variable bit width. It supports
 8, 16, 32, and 48 bit integers, and has a complete instruction set to 
work with them.</p><p>There are bitwise logic instructions which work on all bits of the integer number. They are <tt>BAND</tt>, <tt>BOR</tt>, <tt>BXOR</tt>, <tt>BSHL</tt>, <tt>BSHR</tt>, <tt>BNOT</tt>. For example:
</p><pre class="verbatim">MOV  EAX,105 //1101001
BAND EAX,24  //0011000
//EAX = 8      0001000

BOR EAX,67   //1000011
//EAX = 75   //1001011

BXOR EAX,15  //0001111
//EAX = 68   //1000100

BSHL EAX,2
//EAX = 272  //100010000

BSHR EAX,4
//EAX = 17   //0010001

BNOT EAX
//EAX = -18  //111111111111111111101110
</pre><p>Also there are additional operations that work on separate bits of the number. They are <tt>BIT</tt>, <tt>SBIT</tt>, <tt>TBIT</tt>, <tt>CBIT</tt>.</p><p>The <tt>BIT</tt>
 operation tests whether specific bit of the number is set. It is 
possible to check result of this comparsion by using a conditional jump:
</p><pre class="verbatim">MOV EAX,105
BIT EAX,0
JNZ LABEL //Jump succeeds (bit is not zero)

BIT EAX,1
JNZ LABEL //Jump fails (bit is zero)
</pre><p>The <tt>SBIT</tt> and <tt>CBIT</tt> clear and set the specific bit of the number. <tt>TBIT</tt> instruction will toggle that bit:
</p><pre class="verbatim">MOV EAX,105 //1101001
SBIT EAX,1
//EAX = 107   1101011

CBIT EAX,6
//EAX = 43    0101011

TBIT EAX,0
//EAX = 42    0101010
</pre>
<h2 class="section"><p>
Certain instructions in the ZCPU support using the <tt>BLOCK</tt> 
instruction before them to specify a memory block the instruction must 
be executed on. For example it is possible to set permissions of an 
entire memory block at once:
</p><pre class="verbatim">BLOCK 1024,8192 //A 8KB block at offset 1024
SRL 0,4 //Set runlevel of all pages in this block to 4
</pre><p>The first operand of the <tt>BLOCK</tt> instruction is the 
memory offset the block must start from (must be aligned on page 
boundary for the paging instructions), and the second operand is the 
block size (the size must be divisable by 128 if this is a block for the
 page permission instructions).</p><p>The <tt>BLOCK</tt> instruction sets the two internal registers <tt>BlockStart</tt>, <tt>BlockSize</tt>. After the instruction that supports memory blocks has executed, it will reset block size back to zero.</p><p>The block size must be non-zero for the instruction to work on that block.</p><p><em>It is possible that an interrupt will occur between the </em><em><tt>BLOCK</tt></em><em> instruction and the target instruction</em>. It is advised against using <tt>BLOCK</tt> instruction inside an interrupt handler!</p><p>The following instructions support this psuedo-prefix: <tt>SPP</tt>, <tt>CPP</tt>, <tt>SRL</tt>, <tt>SMAP</tt>.</p>
<h2 class="section"><p>
There are built-in instructions in the ZCPU for quickly moving and working with large arrays of data in an easy way.</p><p>It’s possible to copy one area of memory to another using the <tt>MCOPY</tt> instruction:
</p><pre class="verbatim">mov ESI,source_data;
mov EDI,dest_data;
mcopy 5; //Copy 5 bytes

string source_data,"Apple";
string dest_data,"A quick fox";
</pre><p>After running this code "dest_data" string will be equal to "Appleck fox".</p><p>Two blocks of memory can be swapped using the <tt>MXCHG</tt> instruction:
</p><pre class="verbatim">mov ESI,source_data;
mov EDI,dest_data;
mxchg 5; //Swap 5 bytes

string source_data,"Apple";
string dest_data,"A quick fox";
</pre><p>After running this code "dest_data" string will be equal to "Appleck fox", and "source_data" will be equal to "A qui".</p><p>And it’s also possible to shift all values in block of data:
</p><pre class="verbatim">mov ESI,source_data;

mshift 13,2; //Shift 13 bytes by 2 cells to the right
//source_data = "quick foxA "

mshift 13,-4; //Shift 13 bytes by 4 cells to the left
//source_data = "oxA quick f"

string source_data,"A quick fox";
</pre><p>The offset by which data is shifted must be less or equal to 
amount of bytes that are being shifted. But it is possible to specify 
offsets larger than the data size, and that will reverse the direction 
of shift, and will not wrap the data around.</p><p>All of these instructions can work on up to <tt>8192</tt> bytes in a memory block.</p>
<h2 class="section"><p>
The ZCPU processor has two extra instructions to provide stack frame 
support. Stack frame allows to prevent stack corruption by induvidual 
subroutines, and it also provides an easy way to create local variables 
on stack, and pass values to the subroutine via stack.</p><p><tt>ENTER X</tt> instruction is same as the following code:
</p><pre class="verbatim">Push(EBP)
EBP = ESP + 1
ESP = ESP - X
</pre><p>It will set <tt>EBP</tt> register to stack frame base (value of
 stack pointer at function entrypoint), and add some empty space on 
stack for the local variables.</p><p><tt>LEAVE</tt> instruction corresponds to the following code:
</p><pre class="verbatim">ESP = EBP - 1
EBP = Pop()
</pre><p>It will restore the stack frame base of the previous function (if it exists), and restore stack.</p>
<h2 class="section"><p> <a name="advancedinterrupts"></a>
Interrupts work in a way similar to processor subroutines, but they can 
also be triggered if an error occurs while executing an instruction. In 
this case the instruction execution will not be completed, and the 
processor will attempt to handle this interrupt.</p><p>Interrupt 
handling is only available in extended mode of the processor. If 
interrupt occurs with extended mode disabled the processor will halt its
 execution and report error code to the external output:
</p><pre class="verbatim">lidtr interrupt_table; //Load interrupt table
stef; //Enable extended mode

int 40; //Handle interrupt 40
mov #0.123,10; //Handle interrupt 15 (address space violation)

clef; //Disable extended mode
int 40; //Will halt processor execution
</pre><p>The processor determines which subroutine it must call by 
checking the interrupt descriptor table/interrupt table. It’s a table 
located somewhere in the processor memory which holds addresses to all 
interrupt handlers, and extra flags that alter the way the interrupt is 
handled.</p><p>The pointer to this table must be specified using the <tt>LIDTR</tt> instruction. The interrupt table usually has 256 entries for 256 possible interrupts, but it may have less entries if <tt>NIDT</tt>
 (interrupt table entry count) register is changed. If processor 
attempts to handle an interrupt which is not in the table, it will skip 
it:
</p><pre class="verbatim">cpuset 52,32; //Only have 32 entries
lidtr interrupt_table; //Load interrupt table
stef; //Enable extended mode

int 31; //Will be handled
int 32; //Will be skipped
</pre><p>Each entry in the interrupt table has the following format:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Byte</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>0</tt></td><td align="left" valign="top">Interrupt handler IP</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>1</tt></td><td align="left" valign="top">Interrupt handler CS (if required, see flags)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2</tt></td><td align="left" valign="top">Reserved (must be 0)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>3</tt></td><td align="left" valign="top">Flags</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>There are the following flags that can be set:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Bit</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">3</td><td align="left" valign="top">CMPR register will be set to 1 if an interrupt has occured</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">4</td><td align="left" valign="top">1 if interrupt should <em>not</em> set CS</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">5</td><td align="left" valign="top">Interrupt enabled (active)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">6</td><td align="left" valign="top">This interrupt is an external interrupt</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"> <tt>0</tt></td><td align="left" valign="top">Interrupt handler IP</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>If bit 3 is set, the interrupt will set CMPR register to 1. This can be used for making simple exception handlers:</p><p>If
 bit 4 is set, the interrupt will not set the code segment (it sets it 
by default). The interrupt will only be called if bit 5 is set, if it’s 
clear then it will be ignored (unless it’s the interrupt 0 or 1, if so, 
then they will act as if called without extended mode enabled).</p><p>This
 interrupt can only be called as an external interrupt if bit 6 is set. 
Otherwise it will generate interrupt 13 (general processor fault) 
instead.</p><p>There are special rules for using the interrupt table if paging is used. see: <a href="#interrupthandlingpg">??</a> for more information on how permissions will work if that’s the case.</p><p>The interrupt handler is fairly complex. The Pseudocode for the interrupt handler is listed below:
</p><pre class="verbatim">// Interrupt is active, lock the bus to prevent any further read/write
INTR = 1
BusLock = 1
  
// Set registers
LINT = interruptNo
LADD = interruptParameter or XEIP

// Output the error externally
SignalError(interruptNo,LADD)
  
if IF == 1 then
  if EF == 1 then // Extended mode
    // Boundary check
    if (interruptNo &lt; 0) or (interruptNo &gt; 255) then
      if not cascadeInterrupt then Interrupt(13,3) end
    end

    // Check against boundaries of the interrupt table
    if interruptNo &gt; NIDT-1 then
      if interruptNo == 0 then Reset = 1 end
      if interruptNo == 1 then Clk = 0 end
    end

    // Calculate absolute offset in the interrupt table
    interruptOffset = IDTR + interruptNo*4

    // Disable bus lock, set the current page for read operations
    BusLock = 0
    SetCurrentPage(interruptOffset)

    IF = 0
    INTR = 0
    IP    = ReadCell(interruptOffset+0)
    CS    = ReadCell(interruptOffset+1)
            ReadCell(interruptOffset+2)
    FLAGS = ReadCell(interruptOffset+3)
    IF = 1
    
    if INTR == 1 then
      if not cascadeInterrupt then Interrupt(13,2) end
    else
      INTR = 1
    end
    
    // Set previous page to trigger same logic as if
    //  CALL-ing from a privilegied page
    SetCurrentPage(XEIP)
    SetPrevPage(interruptOffset)
    BusLock = 1

    if isExternal and (FLAGS[6] &lt;&gt; 1) then
      if not cascadeInterrupt then Interrupt(13,4) end
    end
    
    if FLAGS[5] == 1 then
      // Push return data
      BusLock = 0
      IF = 0
      INTR = 0
      Push(IP)
      Push(CS)
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,6) end
      else
        INTR = 1
      end
      BusLock = 1

      // Perform a short or a long jump
      IF = 0
      INTR = 0
      if FLAGS[4] == 0
      then Jump(IP,CS)
      else Jump(IP)
      end
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,7) end
      else
        INTR = 1
      end
      
      // Set CMPR
      if FLAGS[3] == 1 then
        CMPR = 1
      end
    else
      if interruptNo == 0 then
        Reset()
      end
      if interruptNo == 1 then
        Clk = 0
      end
      if FLAGS[3] == 1 then
        CMPR = 1
      end
    end
  end

  if (EF == 0) then // Normal mode
    if (interruptNo &lt; 0) or 
       (interruptNo &gt; 255) or 
       (interruptNo &gt; NIDT-1) then
      // Interrupt not handled
      Exit()
    end
    if interruptNo == 0 then Reset = 1 end
    if interruptNo ~= 31 then Clk = 0 end
  end
end
  
// Unlock the bus
BusLock = 0
</pre>
<h2 class="section"><p>
(no chapter)
</p>
<h2 class="section"><p> <a name="memoverride"></a>
(no chapter)
</p>
<h2 class="section"><p>
The ZCPU has an internal timer which can be used for precise time 
measurements during the code execution. The timer can also be used for 
triggering interrupts at precise time intervals.</p><p>The <tt>TIMER</tt> instruction can be used to fetch the internal timer value in seconds:
</p><pre class="verbatim">TIMER EAX
//EAX is now equal to amount of seconds since CPU startup
</pre><p>It is possible to configure the timer to trigger external 
interrupt after certain amount of seconds, or a certain amount of cycles
 has passed by configuring one of the special registers.</p><p><tt>TimerMode</tt> register controls the timer mode. If it’s set to 0 the timer will be disabled. If <tt>TimerMode</tt> is set to 1 the timer will use <tt>TMR</tt> register as counter source, and if <tt>TimerMode</tt> is set to 2 the timer will use the <tt>TIMER</tt> register as the source.</p><p><tt>TimerRate</tt> sets the number of cycles, or the number of seconds that must pass before the timer will trigger. <tt>TimerPrevTime</tt> register stores value of the <tt>TMR</tt> or the <tt>TIMER</tt> register when timer fired the last time.</p><p><tt>TimerAddress</tt> is the number of the interrupt that will be called when the timer fires. The interrupt call will be an external interrupt call.</p><p>Changing value of the <tt>TimerMode</tt> register will reset the <tt>TimerPrevTime</tt> register.</p><p>This is an example of how to setup timer:
</p><pre class="verbatim">CPUSET 65,90; //Trigger once per 90 cycles
CPUSET 67,40; //Trigger external interrupt #40

CPUSET 64,1;  //Enable timer to count cycles
</pre><p>It could also be initialized for an interval in seconds:
</p><pre class="verbatim">CPUSET 65,1.5; //Trigger once per 1.5 seconds
CPUSET 67,40;  //Trigger external interrupt #40

CPUSET 64,2;   //Enable timer to count seconds
</pre><p>If precision in intervals between timer firing is required, the timer can be reset in the interrupt caller (if required):
</p><pre class="verbatim">ExternalInterrupt:
  CLI; //Disable interrupts
  
  .....
  
  CPUGET EAX,29; //Read cycles counter
  ADD EAX,4;     //Account for 4 'missing' cycles
  CPUSET 66,EAX; //Write last timer fire time
  
  STI; //Enable interrupts
EXTRET;
</pre><p>Or alternatively it’s possible to reset it by swapping the timer mode:
</p><pre class="verbatim">ExternalInterrupt:
  CLI; //Disable interrupts
  
  .....
  
  CPUSET 64,1; //Restart timer   
  STI; //Enable interrupts
EXTRET;
</pre>
<h2 class="section"><p>
(using VMODE,VADD,etc)</p>
<h2 class="section"><p>
(Using hardware debug mode)</p>
<h2 class="section"><p> <a name="caching"></a>
The Zyelios CPU will cache executed microcode for faster execution. This
 increases code execution speed, but some penalties apply. The processor
 will decode instructions the first time they are encountered, and all 
subsequent executions will use the cached execution information.</p><p>The
 Zyelios CPU will cache executed microcode for faster execution. The 
processor will decode instructions the first time they are encountered, 
and all subsequent executions will use the cached execution information.
 The cache will provide very little benefit for code that is executed 
infrequently, but code that is executed frequently will run much faster.</p><p>The penalties caused by caching system mostly concern the flow of execution and the internal optimizations the processor makes:
</p><ol class="enumerate" type="1"><li class="li-enumerate">
	While executing a single cached block of microcode the processor uses 
fast-access cached registers. This means that register values are not 
changed until the block finishes executing.
	</li><li class="li-enumerate">The processor only caches instructions 
the first time they are decoded. It will invalidate cache if the 
processor itself writes or reads to the memory, but it does not 
invalidate cache if any other device writes to an external source.
	</li><li class="li-enumerate">Cached microcode blocks contain up to 8 instructions each. They will end prematurely on unconditional branches and jumps.
	</li><li class="li-enumerate">All reading and writing operations might 
be delayed by several instructions until they actually happen. There are
 only very specific ways to make sure your I/O operation really happens.
</li></ol><p>	</p><p>																</p>
<h1 class="chapter"><p> <a name="instructionformat"></a>
</p>
<h2 class="section"><p>
Each instruction in the ZCPU begins with a single byte which identifies 
the instruction to be executed. If the instruction has operands, then a <em>RM byte</em> (register/memory selector byte) follows. This extra byte specifies what kind of operands are being passed to the instruction.</p><p>Instruction number may also encode information about use of segment prefix, or about the local execution mode (see: <a href="#localexec">??</a>). The instruction number can fall into one of the following ranges:
</p><ul class="itemize"><li class="li-itemize">
	<tt>000 – 999</tt>: variable size instructions
	</li><li class="li-itemize"><tt>1000 – 1999</tt>: variable size instructions with segment prefix for 1st operand
	</li><li class="li-itemize"><tt>10000 – 10999</tt>: variable size instructions with segment prefix for 2nd operand
	</li><li class="li-itemize"><tt>11000 – 11999</tt>: variable size instructions with segment prefixes for both operands
	</li><li class="li-itemize"><tt>2000 – 2999</tt>: fixed size instructions
	</li><li class="li-itemize"><tt>3000 – 3999</tt>: fixed size instructions with segment prefix for 1st operand
	</li><li class="li-itemize"><tt>12000 – 12999</tt>: fixed size instructions with segment prefix for 2nd operand
	</li><li class="li-itemize"><tt>13000 – 13999</tt>: fixed size instructions with segment prefixes for both operands
</li></ul><p>The instruction may be followed by several extra bytes that
 specify segment prefix, constant values, etc. The constant values are 
always the last bytes in the instruction data. Here’s an example of a 
wide variety of different instructions:
</p><pre class="verbatim">STEF            48
INC EAX         20, 1
MOV EAX,10      14, 1, 10
ADD EAX,ESP     10, 70001
DIV EBX,ES:ECX  10013, 290002, 4
ADD R0,#R2      10, 20822048
MOV #100,#500   14, 250025, 100, 500
MOV EAX:#50,GS  1014, 130025, 9, 50
</pre>
<h2 class="section"><p>
The RM byte consists of two parts - the RM selector for the first and the second operand: <i>RM</i> = <i>RM</i><sub>1</sub> + 10000 · <i>RM</i><sub>2</sub>.</p><p>For example RM bytes from the example in the previous chapter could be decoded like this:
</p><pre class="verbatim">                RM        RM1   RM2
STEF            n/a       n/a   n/a
INC EAX         1         1     n/a
MOV EAX,10      1         1     0
ADD EAX,ESP     70001     1     7
DIV EBX,ES:ECX  290002    2     29
ADD R0,#R2      20822048  2048  2082
MOV #100,#500   250025    25    25
MOV EAX:#50,GS  130025    25    13
</pre><p>These RM selectors are supported right now:



</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Selector</td><td align="center" nowrap="nowrap" valign="top">Operand</td><td align="left" valign="top">Source/target</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>0</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>123</tt></td><td align="left" valign="top">Constant value</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>1</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>EAX</tt></td><td align="left" valign="top">Register <tt>EAX</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>EBX</tt></td><td align="left" valign="top">Register <tt>EBX</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>3</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ECX</tt></td><td align="left" valign="top">Register <tt>ECX</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>4</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>EDX</tt></td><td align="left" valign="top">Register <tt>EDX</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>5</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ESI</tt></td><td align="left" valign="top">Register <tt>ESI</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>6</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>EDI</tt></td><td align="left" valign="top">Register <tt>EDI</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>7</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ESP</tt></td><td align="left" valign="top">Register <tt>ESP</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>8</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>EBP</tt></td><td align="left" valign="top">Register <tt>EBP</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>9</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>CS</tt></td><td align="left" valign="top">Register <tt>CS</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>10</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>SS</tt></td><td align="left" valign="top">Register <tt>SS</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>11</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>DS</tt></td><td align="left" valign="top">Register <tt>DS</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>12</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES</tt></td><td align="left" valign="top">Register <tt>ES</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>13</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>GS</tt></td><td align="left" valign="top">Register <tt>GS</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>14</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>FS</tt></td><td align="left" valign="top">Register <tt>FS</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>15</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>KS</tt></td><td align="left" valign="top">Register <tt>KS</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>16</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>LS</tt></td><td align="left" valign="top">Register <tt>LS</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>17</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#EAX</tt>, <tt>ES:#EAX</tt></td><td align="left" valign="top">Memory cell <tt>EAX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>18</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#EBX</tt>, <tt>ES:#EBX</tt></td><td align="left" valign="top">Memory cell <tt>EBX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>19</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#ECX</tt>, <tt>ES:#ECX</tt></td><td align="left" valign="top">Memory cell <tt>ECX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>20</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#EDX</tt>, <tt>ES:#EDX</tt></td><td align="left" valign="top">Memory cell <tt>EDX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>21</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#ESI</tt>, <tt>ES:#ESI</tt></td><td align="left" valign="top">Memory cell <tt>ESI + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>22</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#EDI</tt>, <tt>ES:#EDI</tt></td><td align="left" valign="top">Memory cell <tt>EDI + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>23</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#ESP</tt>, <tt>ES:#ESP</tt></td><td align="left" valign="top">Memory cell <tt>ESP + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>24</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#EBP</tt>, <tt>ES:#EBP</tt></td><td align="left" valign="top">Memory cell <tt>EBP + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>25</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#123</tt>, <tt>ES:#123</tt></td><td align="left" valign="top">Memory cell by constant value</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>26</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:EAX</tt></td><td align="left" valign="top">Register <tt>EAX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>27</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:EBX</tt></td><td align="left" valign="top">Register <tt>EBX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>28</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:ECX</tt></td><td align="left" valign="top">Register <tt>ECX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>29</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:EDX</tt></td><td align="left" valign="top">Register <tt>EDX + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>30</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:ESI</tt></td><td align="left" valign="top">Register <tt>ESI + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>31</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:EDI</tt></td><td align="left" valign="top">Register <tt>EDI + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>32</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:ESP</tt></td><td align="left" valign="top">Register <tt>ESP + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>33</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:EBP</tt></td><td align="left" valign="top">Register <tt>EBP + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>34</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>EAX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>35</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>EBX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>36</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>ECX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>37</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>EDX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>38</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>ESI + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>39</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>EDI + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>40</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>ESP + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>41</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>EBP + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>42</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>EAX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>43</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>EBX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>44</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>ECX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>45</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>EDX + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>46</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>ESI + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>47</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>EDI + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>48</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>ESP + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>49</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Register <tt>EBP + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>50</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:123</tt></td><td align="left" valign="top">Constant value plus segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>1000</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>PORT0</tt></td><td align="left" valign="top">Port 0</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>1001</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>PORT1</tt></td><td align="left" valign="top">Port 1</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="left" valign="top">....</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2023</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>PORT1023</tt></td><td align="left" valign="top">Port 1023</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>2048</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>R0</tt></td><td align="left" valign="top">Extended register <tt>R0</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="left" valign="top">....</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2079</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>R31</tt></td><td align="left" valign="top">Extended register <tt>R31</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>2080</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#R0</tt>, <tt>ES:#R0</tt></td><td align="left" valign="top">Memory cell <tt>R0 + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="left" valign="top">....</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2111</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>#R31</tt>, <tt>ES:#R31</tt></td><td align="left" valign="top">Memory cell <tt>R31 + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>2112</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:R0</tt></td><td align="left" valign="top">Extended register <tt>R0 + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="left" valign="top">....</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2143</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>ES:R31</tt></td><td align="left" valign="top">Extended register <tt>R31 + segment</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>2144</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>R0 + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="left" valign="top">....</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2175</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Memory cell <tt>R31 + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>2176</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Extended register <tt>R0 + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>....</tt></td><td align="left" valign="top">....</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2207</tt></td><td align="center" nowrap="nowrap" valign="top">No syntax</td><td align="left" valign="top">Extended register <tt>R31 + constant</tt></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote>
<h2 class="section"><p>
Segment offset is specified by a byte that follows the RM byte. For 
example, here is how the same instruction is encoded with different 
segment prefixes:
</p><pre class="verbatim">MOV EAX,EBX        14,20001
MOV LS:EAX,EBX     1014,20027,8
MOV EAX,LS:EBX     10014,280001,8
MOV LS:EAX,LS:EBX  11014,280027,8,8
MOV R0:EAX,EBX     1014,20027,17
MOV EAX,R0:EBX     10014,280001,17
MOV R0:EAX,R0:EBX  11014,280027,17,17
</pre><p>There can be the following segment prefixes. The negative-value
 prefixes are obsolete now, and are only preserved for backwards 
compatibility:
</p><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap">Value</td><td align="center" nowrap="nowrap">Register</td><td align="center" nowrap="nowrap">Value</td><td align="center" nowrap="nowrap">Register</td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-02</tt></td><td align="center" nowrap="nowrap"><tt>CS</tt></td><td align="center" nowrap="nowrap"><tt>01</tt></td><td align="center" nowrap="nowrap"><tt>CS</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-03</tt></td><td align="center" nowrap="nowrap"><tt>SS</tt></td><td align="center" nowrap="nowrap"><tt>02</tt></td><td align="center" nowrap="nowrap"><tt>SS</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-04</tt></td><td align="center" nowrap="nowrap"><tt>DS</tt></td><td align="center" nowrap="nowrap"><tt>03</tt></td><td align="center" nowrap="nowrap"><tt>DS</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-05</tt></td><td align="center" nowrap="nowrap"><tt>ES</tt></td><td align="center" nowrap="nowrap"><tt>04</tt></td><td align="center" nowrap="nowrap"><tt>ES</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-06</tt></td><td align="center" nowrap="nowrap"><tt>GS</tt></td><td align="center" nowrap="nowrap"><tt>05</tt></td><td align="center" nowrap="nowrap"><tt>GS</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-07</tt></td><td align="center" nowrap="nowrap"><tt>FS</tt></td><td align="center" nowrap="nowrap"><tt>06</tt></td><td align="center" nowrap="nowrap"><tt>FS</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-08</tt></td><td align="center" nowrap="nowrap"><tt>KS</tt></td><td align="center" nowrap="nowrap"><tt>07</tt></td><td align="center" nowrap="nowrap"><tt>KS</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-09</tt></td><td align="center" nowrap="nowrap"><tt>LS</tt></td><td align="center" nowrap="nowrap"><tt>08</tt></td><td align="center" nowrap="nowrap"><tt>LS</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-10</tt></td><td align="center" nowrap="nowrap"><tt>EAX</tt></td><td align="center" nowrap="nowrap"><tt>09</tt></td><td align="center" nowrap="nowrap"><tt>EAX</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-11</tt></td><td align="center" nowrap="nowrap"><tt>EBX</tt></td><td align="center" nowrap="nowrap"><tt>10</tt></td><td align="center" nowrap="nowrap"><tt>EBX</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-12</tt></td><td align="center" nowrap="nowrap"><tt>ECX</tt></td><td align="center" nowrap="nowrap"><tt>11</tt></td><td align="center" nowrap="nowrap"><tt>ECX</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-13</tt></td><td align="center" nowrap="nowrap"><tt>EDX</tt></td><td align="center" nowrap="nowrap"><tt>12</tt></td><td align="center" nowrap="nowrap"><tt>EDX</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-14</tt></td><td align="center" nowrap="nowrap"><tt>ESI</tt></td><td align="center" nowrap="nowrap"><tt>13</tt></td><td align="center" nowrap="nowrap"><tt>ESI</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-15</tt></td><td align="center" nowrap="nowrap"><tt>EDI</tt></td><td align="center" nowrap="nowrap"><tt>14</tt></td><td align="center" nowrap="nowrap"><tt>EDI</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-16</tt></td><td align="center" nowrap="nowrap"><tt>ESP</tt></td><td align="center" nowrap="nowrap"><tt>15</tt></td><td align="center" nowrap="nowrap"><tt>ESP</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>-17</tt></td><td align="center" nowrap="nowrap"><tt>EBP</tt></td><td align="center" nowrap="nowrap"><tt>16</tt></td><td align="center" nowrap="nowrap"><tt>EBP</tt></td></tr>
<tr><td align="center" nowrap="nowrap"><tt>17</tt></td><td align="center" nowrap="nowrap"><tt>R0</tt></td><td align="center" nowrap="nowrap">&nbsp;</td><td align="center" nowrap="nowrap">&nbsp;</td></tr>
<tr><td align="center" nowrap="nowrap"><tt>...</tt></td><td align="center" nowrap="nowrap"><tt>...</tt></td><td align="center" nowrap="nowrap">&nbsp;</td><td align="center" nowrap="nowrap">&nbsp;</td></tr>
<tr><td align="center" nowrap="nowrap"><tt>47</tt></td><td align="center" nowrap="nowrap"><tt>R32</tt></td><td align="center" nowrap="nowrap">&nbsp;</td><td align="center" nowrap="nowrap">&nbsp;</td></tr>
</tbody></table>
<h2 class="section"><p> <a name="localexec"></a>
The Zyelios CPU supports two machine code formats: fixed-length and 
variable-length. The CPU automatically determines which type is in use 
in order to retain binary compatibility. Several simple rules are 
employed for this detection.</p><p>							</p><p>Example of instructions in the default mode:
</p><pre class="verbatim">STEF            48
INC EAX         20, 1
MOV EAX,10      14, 1, 10
ADD EAX,ESP     10, 70001
DIV EBX,ES:ECX  10013, 290002, 4
ADD R0,#R2      10, 20822048
MOV #100,#500   14, 250025, 100, 500
MOV EAX:#50,GS  1014, 130025, 9, 50
</pre><p>Example of instructions encoded in fixed-size mode:
</p><pre class="verbatim">STEF            2048,0,-4,-4,0,0
INC EAX         2020,1,-4,-4,0,0
MOV EAX,10      2014,1,-4,-4,0,10
ADD EAX,ESP     2010,70001,-4,-4,0,0
DIV EBX,ES:ECX  12013,290002,-4,4,0,0
ADD R0,#R2      2010,20822048,-4,-4,0,0
MOV #100,#500   2014,250025,-4,-4,100,500
MOV EAX:#50,GS  3014,130025,9,-4,50,0
</pre><p>Same instructions in the ZCPU compatibility mode:
</p><pre class="verbatim">STEF            48, 0
INC EAX         20, 1
MOV EAX,10      14, 1, 10
ADD EAX,ESP     10, 70001
DIV EBX,ES:ECX  10013, 290002, 4
ADD R0,#R2      10, 20822048
MOV #100,#500   14, 250025, 100, 500
MOV EAX:#50,GS  1014, 130025, 9, 50
</pre>
<h1 class="chapter"><p>
The processor has several internal registers which are used to store the
 internal processor state or control advanced processor features. It is 
possible to read or write most of these registers using <tt>CPUSET</tt> and <tt>CPUGET</tt>.</p><p>For example:</p><pre class="verbatim">CPUGET EAX,24 //Read register 24 into EAX 
              //24 is the interrupt descriptor table pointer
CPUSET 9,EBX //Set register 9 (stack size) to EBX

CPUGET EAX,1000 //Invalid register will set EAX to 0
</pre><p>The registers <tt>XEIP</tt>, <tt>CPAGE</tt>, <tt>PPAGE</tt>, <tt>SerialNo</tt>, <tt>CODEBYTES</tt>, <tt>TimerDT</tt>, <tt>RAMSize</tt> are read-only - it is not possible to change their value by any means.</p><p>Changing value of the <tt>IP</tt> or the <tt>CS</tt> register is possible, and will be handled as a far jump.</p><p>See the section <a href="#advfeatures">2</a> for description of how some of the registers are used.</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Mnemonic</td><td align="center" nowrap="nowrap" valign="top">Number</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>IP</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>00</tt></td><td align="left" valign="top">Instruction pointer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>EAX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>01</tt></td><td align="left" valign="top">General purpose register A</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>EBX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>02</tt></td><td align="left" valign="top">General purpose register B</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ECX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>03</tt></td><td align="left" valign="top">General purpose register C</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>EDX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>04</tt></td><td align="left" valign="top">General purpose register D</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ESI</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>05</tt></td><td align="left" valign="top">Source index</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>EDI</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>06</tt></td><td align="left" valign="top">Destanation index</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ESP</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>07</tt></td><td align="left" valign="top">Stack pointer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>EBP</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>08</tt></td><td align="left" valign="top">Base pointer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ESZ</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>09</tt></td><td align="left" valign="top">Stack size</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>CS</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>16</tt></td><td align="left" valign="top">Code segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>SS</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>17</tt></td><td align="left" valign="top">Stack segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DS</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>18</tt></td><td align="left" valign="top">Data segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ES</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>19</tt></td><td align="left" valign="top">Extra segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>GS</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>20</tt></td><td align="left" valign="top">User segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>FS</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>21</tt></td><td align="left" valign="top">User segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>KS</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>22</tt></td><td align="left" valign="top">Key segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>LS</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>23</tt></td><td align="left" valign="top">Library segment</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>IDTR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>24</tt></td><td align="left" valign="top">Interrupt descriptor table pointer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CMPR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>25</tt></td><td align="left" valign="top">Comparsion result register</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>XEIP</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>26</tt></td><td align="left" valign="top">Pointer to start of currently executed instruction</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>LADD</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>27</tt></td><td align="left" valign="top">Current interrupt code</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>LINT</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>28</tt></td><td align="left" valign="top">Current interrupt number</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TMR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>29</tt></td><td align="left" valign="top">Instruction/cycle counter</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TIMER</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>30</tt></td><td align="left" valign="top">Internal precise timer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CPAGE</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>31</tt></td><td align="left" valign="top">Current page number</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>IF</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>32</tt></td><td align="left" valign="top">Interrupts enabled flag</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>PF</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>33</tt></td><td align="left" valign="top">Protected mode flag</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>EF</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>34</tt></td><td align="left" valign="top">Extended mode flag</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>NIF</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>35</tt></td><td align="left" valign="top">Next cycle interrupt enabled flag state</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>MF</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>36</tt></td><td align="left" valign="top">Extended memory mapping flag</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>PTBL</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>37</tt></td><td align="left" valign="top">Page table offset</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>PTBE</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>38</tt></td><td align="left" valign="top">Page table number of entries</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>PCAP</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>39</tt></td><td align="left" valign="top">Processor paging system capability</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>RQCAP</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>40</tt></td><td align="left" valign="top">Processor delayed memory request capability</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>PPAGE</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>41</tt></td><td align="left" valign="top">Previous page ID</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>MEMRQ</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>42</tt></td><td align="left" valign="top">Type of the memory request</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>RAMSize</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>43</tt></td><td align="left" valign="top">Amount of internal memory</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>External</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>44</tt></td><td align="left" valign="top">External I/O operation</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>BusLock</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>45</tt></td><td align="left" valign="top">Is bus locked for read/write</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Idle</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>46</tt></td><td align="left" valign="top">Should CPU skip some cycles</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>INTR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>47</tt></td><td align="left" valign="top">Handling an interrupt</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>SerialNo</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>48</tt></td><td align="left" valign="top">Processor serial number</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CODEBYTES</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>49</tt></td><td align="left" valign="top">Amount of bytes executed so far</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>BPREC</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>50</tt></td><td align="left" valign="top">Binary precision level</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>IPREC</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>51</tt></td><td align="left" valign="top">Integer precision level</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>NIDT</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>52</tt></td><td align="left" valign="top">Number of interrupt descriptor table entries</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>BlockStart</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>53</tt></td><td align="left" valign="top">Start offset of the block</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>BlockSize</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>54</tt></td><td align="left" valign="top">Block size</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>VMODE</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>55</tt></td><td align="left" valign="top">Vector mode (2: 2D, 3: 3D)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>XTRL</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>56</tt></td><td align="left" valign="top">Runlevel for external memory access</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>HaltPort</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>57</tt></td><td align="left" valign="top">Halt until this port changes value</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>HWDEBUG</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>58</tt></td><td align="left" valign="top">Hardware debug mode active</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DBGSTATE</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>59</tt></td><td align="left" valign="top">Hardware debug mode state</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DBGADDR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>60</tt></td><td align="left" valign="top">Hardware debug mode address/parameter</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CRL</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>61</tt></td><td align="left" valign="top">Current runlevel</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TimerDT</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>62</tt></td><td align="left" valign="top">Current timer discrete step</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>MEMADDR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>63</tt></td><td align="left" valign="top">Address reqested by the memory operation</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>TimerMode</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>64</tt></td><td align="left" valign="top">Timer mode (off, instructions, seconds)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TimerRate</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65</tt></td><td align="left" valign="top">Timer rate</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TimerPrevTime</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>66</tt></td><td align="left" valign="top">Previous timer fire time</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TimerAddress</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>67</tt></td><td align="left" valign="top">Number of external interrupt to call when timer fires</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>	

</p>
<h1 class="chapter"><p> <a name="opcodelist"></a>
</p>
<h2 class="section"><p>
This section describes the primary set of opcodes available in the ZCPU.
 Not all of these are present in ZGPU or ZSPU though. The following 
primary set instructions are not available in those architectures: <tt>SPG</tt>, <tt>CPG</tt>, <tt>HALT</tt>, <tt>IRET</tt>, <tt>STI</tt>, <tt>CLI</tt>, <tt>STEF</tt>, <tt>CLEF</tt>, <tt>EXTINT</tt>, <tt>ERPG</tt>, <tt>WRPG</tt>, <tt>RDPG</tt>, <tt>LIDTR</tt>, <tt>EXTRET</tt>, <tt>STM</tt>, <tt>CLM</tt>, <tt>SPP</tt>, <tt>CPP</tt>, <tt>SRL</tt>, <tt>GRL</tt>, <tt>SMAP</tt>, <tt>GMAP</tt>.</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>STOP</tt><br>
<b>Encoding:</b> <tt>000</tt>    </p><p><br>
<br>
<br>


Triggers interrupt #2 (equivalent to <tt>INT 2</tt>). Will stop the processor execution if extended mode is not enabled.</p><p>Used
 by the processor to detect end of program/invalid jump error, because 
this instruction is usually the result of invalid jump. Acts as <tt>NOP</tt> if interrupts are disabled.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Interrupt(2,0)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JNE/JNZ</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>001</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Jumps to the specified address if in previous comparsion two values were not equal to each other.</p><p>Can also be used to check if result of the previous bit operation was not zero:
</p><pre class="verbatim">BIT EAX,2
JNZ LABEL
</pre><p>This code will jump to a label if the second bit is set to <tt>1</tt>.</p><p>



 

May trigger error <tt>14</tt> (execution access violation) if 
instruction execution moves into a restricted memory area when extended 
mode is enabled. see: <a href="#paging">??</a> for information about memory protection and paging.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CMPR &lt;&gt; 0 then
  Jump(X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JMP</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>002</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Unconditional jump to the specified address.</p><p>



 

May trigger error <tt>14</tt> (execution access violation) if 
instruction execution moves into a restricted memory area when extended 
mode is enabled. see: <a href="#paging">??</a> for information about memory protection and paging.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Jump(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JG/JNLE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>003</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Jumps to target address if the previous comparsion resulted in greater, or not less or equal result.</p><p>



 

May trigger error <tt>14</tt> (execution access violation) if 
instruction execution moves into a restricted memory area when extended 
mode is enabled. see: <a href="#paging">??</a> for information about memory protection and paging.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CMPR &gt; 0 then
  Jump(X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JGE/JNL</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>004</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Jumps to target address if the previous comparsion resulted in greater or equal, or not less result.</p><p>



 

May trigger error <tt>14</tt> (execution access violation) if 
instruction execution moves into a restricted memory area when extended 
mode is enabled. see: <a href="#paging">??</a> for information about memory protection and paging.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CMPR &gt;= 0 then
  Jump(X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JL/JNGE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>005</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Jumps to target address if the previous comparsion resulted in less, or not greater or equal result.</p><p>



 

May trigger error <tt>14</tt> (execution access violation) if 
instruction execution moves into a restricted memory area when extended 
mode is enabled. see: <a href="#paging">??</a> for information about memory protection and paging.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CMPR &lt; 0 then
  Jump(X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JLE/JNG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>006</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Jumps to target address if the previous comparsion resulted in less or equal, or not greater result.</p><p>



 

May trigger error <tt>14</tt> (execution access violation) if 
instruction execution moves into a restricted memory area when extended 
mode is enabled. see: <a href="#paging">??</a> for information about memory protection and paging.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CMPR &lt;= 0 then
  Jump(X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JE/JZ</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>007</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Jumps to the specified address if in previous comparsion two values were equal to each other.</p><p>Can also be used to check if result of the previous bit operation was zero:
</p><pre class="verbatim">BIT EAX,2
JZ LABEL
</pre><p>This code will jump to a label if the second bit is set to <tt>0</tt>.</p><p>



 

May trigger error <tt>14</tt> (execution access violation) if 
instruction execution moves into a restricted memory area when extended 
mode is enabled. see: <a href="#paging">??</a> for information about memory protection and paging.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CMPR &lt;&gt; 0 then
  Jump(X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CPUID</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>008</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


The <tt>CPUID</tt> instruction will write various information about the processor itself into the <tt>EAX</tt> register. This can be used to check for the processor capabilities.</p><p>The first parameter passed into the instruction defines what kind of the information is required:</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Operand</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">0</td><td align="left" valign="top">Processor version (current version: 10.00, reported as <tt>1000</tt>)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">1</td><td align="left" valign="top">Amount of internal RAM</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">2</td><td align="left" valign="top">Processor type</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">3</td><td align="left" valign="top">Amount of internal ROM</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>The result will be written into the <tt>EAX</tt> register. Processor type can be one of the following:



</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top"><tt>EAX</tt></td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">0</td><td align="left" valign="top">ZCPU</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">1</td><td align="left" valign="top">ZGPU beta version</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">2</td><td align="left" valign="top">ZSPU</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">3</td><td align="left" valign="top">ZGPU</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p><b>Pseudocode:</b>
</p><pre class="verbatim">EAX = CPUID[X]
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>PUSH</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>009</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Pushes a value to the processor stack (see: <a href="#stack">??</a> for more information on the processor stack). Will check for interrupt overflow by comparing the new stack pointer to zero.</p><p>Uses the <tt>ESP</tt> register as the stack pointer, and the <tt>ESZ</tt> register as the stack size pointer.</p><p>Example of use:
</p><pre class="verbatim">PUSH 10
PUSH 20

POP EAX //EAX is now 20
</pre><p>


May trigger error <tt>6</tt> (stack overflow/underflow) if the stack pointer goes outside the allowable limits.</p><p>

 
 





May trigger error <tt>7</tt> (memory read/write fault) if the instruction was not able to perform a memory write/read operation due to an error.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">MEMORY[ESP+SS] = X
ESP = ESP - 1

if ESP &lt; 0 then
  ESP = 0
  Interrupt(6,ESP)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>ADD</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>010</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Adds two values together, and writes the result to the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X + Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>SUB</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>011</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Subtracts second operand from the first one, and writes the result to the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X - Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MUL</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>012</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Muliplies two values together, and writes the result to the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X * Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DIV</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>013</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Divides the first operand by the second operand, and writes the result 
to the first operand. Checks for the division by zero error.</p><p>

May trigger error <tt>3</tt> (division by zero) if the second operand was equal to zero.</p><p>Will not trigger division by zero error if interrupt flag register <tt>IF</tt> is set to 0.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if Y &lt;&gt; 0 then
  X = X / Y
else
  Interrupt(3,0)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MOV</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>014</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Copies the contents of the second operand to the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CMP</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>015</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Compares the two operands together, and remembers the result of this comparsion.</p><p>This instruction is used in conjunction with the conditional branching instructions (see <a href="#branching">??</a>), for example:
</p><pre class="verbatim">CMP EAX,EBX
JG  LABEL1 //Jump if EAX &gt;  EBX
JLE LABEL2 //Jump if EAX &lt;= EBX
JE  LABEL3 //Jump if EAX  = EBX
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">CMPR = X - Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MIN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>018</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds the smaller of the two values, and writes it to the first operand. For example:
</p><pre class="verbatim">MOV EAX,100
MOV EBX,200
MIN EBX,EAX //Sets EBX to 100
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">if X &gt; Y then
  X = Y
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MAX</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>019</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds the bigger of the two values, and writes it to the first operand. For example:
</p><pre class="verbatim">MOV EAX,100
MOV EBX,200
MAX EAX,EBX //Sets EAX to 200
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">if X &lt; Y then
  X = Y
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>INC</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>020</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Increments the target operand by one. For example:
</p><pre class="verbatim">MOV EAX,100
INC EAX //EAX is now 101
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X + 1
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DEC</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>021</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Decrements the target operand by one. For example:
</p><pre class="verbatim">MOV EAX,100
DEC EAX //EAX is now 99
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X - 1
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>NEG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>022</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Negates the target operand (changes its sign). For example:
</p><pre class="verbatim">MOV EAX,123
NEG EAX //EAX is now -123

MOV EBX,0
NEG EBX //EBX is now -0, signed zero
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = -X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>RAND</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>023</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Generates a random value between 0.0 and 1.0. The random seed is automatically generated by the processor hardware.</p><p>Range inclusive of 0.0 and 1.0.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = RANDOM(0.0,1.0)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LOOP</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>024</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Performs a conditional jump to a certain label as long as ECX does not 
equal zero. Is usually used for creating loops in programs:
</p><pre class="verbatim">MOV ECX,100;
LABEL:
  &lt;...&gt;
LOOP ECX; //Repeats 100 times
</pre><p>Will only terminate when ECX is equal to zero.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if ECX &lt;&gt; 0 then
  ECX = ECX - 1
  IP = X
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LOOPA</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>025</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Performs a conditional jump to a certain label as long as EAX does not 
equal zero. Is usually used for creating loops in programs:
</p><pre class="verbatim">MOV EAX,100;
LABEL:
  &lt;...&gt;
LOOP EAX; //Repeats 100 times
</pre><p>Will only terminate when EAX is equal to zero. Similar to the <tt>LOOP</tt> instruction.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if EAX &lt;&gt; 0 then
  EAX = EAX - 1
  IP = X
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LOOPB</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>026</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Performs a conditional jump to a certain label as long as EBX does not 
equal zero. Is usually used for creating loops in programs:
</p><pre class="verbatim">MOV EBX,100;
LABEL:
  &lt;...&gt;
LOOP EBX; //Repeats 100 times
</pre><p>Will only terminate when EBX is equal to zero. Similar to the <tt>LOOP</tt> instruction.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if EBX &lt;&gt; 0 then
  EBX = EBX - 1
  IP = X
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LOOPD</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>027</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Performs a conditional jump to a certain label as long as EDX does not 
equal zero. Is usually used for creating loops in programs:
</p><pre class="verbatim">MOV EDX,100;
LABEL:
  &lt;...&gt;
LOOP EDX; //Repeats 100 times
</pre><p>Will only terminate when EDX is equal to zero. Similar to the <tt>LOOP</tt> instruction.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if EDX &lt;&gt; 0 then
  EDX = EDX - 1
  IP = X
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>SPG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>028</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Makes the specific page read-only. It will clear the write flag of the 
page specified by the operand, and also set the read flag of the page 
specified by the operand. see: <a href="#paging">??</a> for more information on the paging system.</p><p>Example of use:
</p><pre class="verbatim">SPG 1 //Set addresses 128..255 read-only
SPG 2 //Set addresses 256..511 read-only

CPG 1 //Make the 128..255 range writeable again
</pre><p>




May trigger error <tt>11</tt> (page acccess violation) if the 
instruction attempts to access a page, and the target page runlevel is 
greater than the current page runlevel.</p><p>
This instruction is privileged, meaning it can only be executed from the code page which has runlevel of 0.</p><p>In case of an error it will pass the target page number as an interrupt parameter.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CurrentPage.Runlevel &lt; Page[X].Runlevel then
  Page[X].Read = 1
  Page[X].Write = 0
else
  Interrupt(11,X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CPG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>029</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Makes the specific page readable and writeable. It will set the write 
flag of the page specified by the operand, and also set the read flag of
 the page specified by the operand. see: <a href="#paging">??</a> for more information on the paging system.</p><p>Example of use:
</p><pre class="verbatim">SPG 1 //Set addresses 128..255 read-only
SPG 2 //Set addresses 256..511 read-only

CPG 1 //Make the 128..255 range writeable again
</pre><p>




May trigger error <tt>11</tt> (page acccess violation) if the 
instruction attempts to access a page, and the target page runlevel is 
greater than the current page runlevel.</p><p>
This instruction is privileged, meaning it can only be executed from the code page which has runlevel of 0.</p><p>In case of an error it will pass the target page number as an interrupt parameter.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if CurrentPage.Runlevel &lt; Page[X].Runlevel then
  Page[X].Read = 1
  Page[X].Write = 1
else
  Interrupt(11,X)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>POP</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>030</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Pops a value off the processor stack (see: <a href="#stack">??</a> 
for more information on the processor stack). Will check for underflow 
by comparing the new stack pointer to the stack size register.</p><p>Uses the <tt>ESP</tt> register as the stack pointer, and the <tt>ESZ</tt> register as the stack size pointer.</p><p>Example of use:
</p><pre class="verbatim">PUSH 10
PUSH 20

POP EAX //EAX is now 20
</pre><p>


May trigger error <tt>6</tt> (stack overflow/underflow) if the stack pointer goes outside the allowable limits.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">ESP = ESP + 1
if ESP &gt; ESZ then
  ESP = ESZ
  Interrupt(6,ESP)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CALL</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>031</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Calls a subroutine of the program. The subroutine will return to this point of execution by executing the <tt>RET</tt> instruction.</p><p>This instruction pushes the current instruction pointer to stack, and will restore it upon executing the <tt>RET</tt> instruction. Any damage to the stack data might cause subroutine to fail to return to the original calling point.</p><p>The opcode may trigger stack-related errors.</p><p>For example:
</p><pre class="verbatim">CALL SUBROUTINE0;
CALL SUBROUTINE1;

SUBROUTINE0:
  &lt;...&gt;
RET

SUBROUTINE1:
  &lt;...&gt;
  CALL SUBROUTINE0;
RET
</pre><p>


May trigger error <tt>6</tt> (stack overflow/underflow) if the stack pointer goes outside the allowable limits.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Push(IP)
if NoInterrupts then
  IP = X
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BNOT</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>032</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Toggles all bits in the number. The number of bits affected by the operation depend on the current setting of the <tt>BPREC</tt> register (binary precision).</p><p>For example:
</p><pre class="verbatim">CPUSET 50,8 //Set 8-bit precision

MOV EAX,1
BNOT EAX //EAX is now 254
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = NOT X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FINT</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>033</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Rounds down the value. Will round down to the lower integer:
</p><pre class="verbatim">MOV EAX,1.9
FINT EAX //EAX = 1.0

MOV EAX,4.21
FINT EAX //EAX = 4.0

MOV EAX,1520.101
FINT EAX //EAX = 1520.0
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = FLOOR(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FRND</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>034</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Rounds the value to the nearest integer:
</p><pre class="verbatim">MOV EAX,1.9
FRND EAX //EAX = 2.0

MOV EAX,4.21
FRND EAX //EAX = 4.0

MOV EAX,1520.101
FRND EAX //EAX = 1520.0
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = ROUND(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FFRAC</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>035</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Returns the fractional value of the operand:
</p><pre class="verbatim">MOV EAX,1.9
FRND EAX //EAX = 0.9

MOV EAX,4.21
FRND EAX //EAX = 0.21

MOV EAX,1520.101
FRND EAX //EAX = 0.101
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = FRAC(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FINV</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>036</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Finds the inverse of the operand. Checks for the division by zero error.</p><p>

May trigger error <tt>3</tt> (division by zero) if the second operand was equal to zero.</p><p>Will not trigger division by zero error if interrupt flag register <tt>IF</tt> is set to 0.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if X &lt;&gt; 0 then
  X = 1 / X
else
  Interrupt(3,1)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FSHL</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>038</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Performs an arithmetic shift-left by multiplying the input number by two. The result might be a floating-point value:
</p><pre class="verbatim">MOV EAX,100
FSHR EAX //EAX = 200

MOV EAX,8
FSHR EAX //EAX = 16

MOV EAX,4.2
FSHR EAX //EAX = 8.2
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X * 2
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FSHR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>039</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Performs an arithmetic shift-right by dividing the input number by two. The result might be a floating-point value:
</p><pre class="verbatim">MOV EAX,100
FSHR EAX //EAX = 50

MOV EAX,8
FSHR EAX //EAX = 4

MOV EAX,4.2
FSHR EAX //EAX = 2.1
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X / 2
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>RET</tt><br>
<b>Encoding:</b> <tt>040</tt>    </p><p><br>
<br>
<br>


Returns from a subroutine previous called by <tt>CALL</tt> instruction. This instruction will pop a value off the stack, and use it as a return address.</p><p>It can be used for creating subroutines:
</p><pre class="verbatim">CALL SUBROUTINE0;
CALL SUBROUTINE1;

SUBROUTINE0:
  &lt;...&gt;
RET

SUBROUTINE1:
  &lt;...&gt;
  CALL SUBROUTINE0;
RET
</pre><p>


May trigger error <tt>6</tt> (stack overflow/underflow) if the stack pointer goes outside the allowable limits.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">IP = POP()
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>IRET</tt><br>
<b>Encoding:</b> <tt>041</tt>    </p><p><br>
<br>
<br>


Returns from an interrupt call. This instruction is very similar to the <tt>RET</tt> instruction, except it restores both the code segment <tt>CS</tt> and the instruction pointer <tt>IP</tt>. It will pop both values off the stack.</p><p>The
 code segment that will be restored correspond to the code segment that 
the execution was in when the interrupt occured. It is <em>not</em> affected by the <tt>IF</tt> flag (interrupt flag).</p><p>For example, a typical interrupt body would be:
</p><pre class="verbatim">INTERRUPT_HANDLER:
  &lt;...&gt;
IRET;
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">if EF = 0 then
  IP = Pop()
end
if EF = 1 then
  CS = Pop()
  IP = Pop()
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>STI</tt><br>
<b>Encoding:</b> <tt>042</tt>    </p><p><br>
<br>
<br>


Set interrupt flag <tt>IF</tt> to 1 <em>after the next instruction</em>. This will enable triggering the interrupts (without the <tt>IF</tt> flag interrupts are ignored).</p><p>The delay of one instruction is so it would be possible to combine <tt>STI</tt> instruction with an <tt>IRET</tt> or <tt>EXTRET</tt>
 instruction to provide an atomic interrupt handler (preventing any 
other interrupts from happening during this interrupt). It’s most 
efficiently used to prevent external interrupts from happening.</p><p>For example:
</p><pre class="verbatim">INTERRUPT_HANDLER:
  CLI;
  &lt;...&gt;
  STI;
EXTRET;
</pre><p>
This instruction is privileged, meaning it can only be executed from the code page which has runlevel of 0.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">NextIF = 1
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CLI</tt><br>
<b>Encoding:</b> <tt>043</tt>    </p><p><br>
<br>
<br>


Clears the interrupt flag <tt>IF</tt>. This will prevent any interrupts 
from being triggered, and the errors raised by the processor will be 
ignored. The interrupts can be turned back on using the <tt>STI</tt> instruction.</p><p>
This instruction is privileged, meaning it can only be executed from the code page which has runlevel of 0.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">IF = 0
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>RETF</tt><br>
<b>Encoding:</b> <tt>047</tt>    </p><p><br>
<br>
<br>


Performs a return from a far subroutine call via the <tt>CALLF</tt> instruction. Works similarly to the <tt>IRET</tt> instruction, but does not check for the extended mode.</p><p>Will set code segment and instruction pointer to values popped off the stack.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">CS = Pop()
IP = Pop()
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>STEF</tt><br>
<b>Encoding:</b> <tt>048</tt>    </p><p><br>
<br>
<br>


Enable the extended mode of the processor. This mode will enable the 
interrupt table support, and permission checks for the paging system.</p><p>The paging system is independant of the extended mode, and can function with or without the extended mode enabled.</p><p>It’s possible to disable the extended mode by using the <tt>CLEF</tt> instruction.</p><p>
This instruction is privileged, meaning it can only be executed from the code page which has runlevel of 0.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">EF = 1
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CLEF</tt><br>
<b>Encoding:</b> <tt>049</tt>    </p><p><br>
<br>
<br>


Disables the extended mode which was enabled by the <tt>STEF</tt> instruction. This will disable interrupt table, and disable the permission checks in the paging system.</p><p>The paging system is independant of the extended mode, and can function with or without the extended mode enabled.</p><p>
This instruction is privileged, meaning it can only be executed from the code page which has runlevel of 0.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">EF = 0
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>AND</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>050</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Performs a logical AND operation on the two operands, and writes the 
result back to the first operand. The result will be 1 if both operands 
are greater or equal to 1.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X AND Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>OR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>051</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Performs a logical OR operation on the two operands, and writes the 
result back to the first operand. The result will be 1 if either of the 
operands is greater or equal to 1.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X OR Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>XOR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>052</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Performs a logical XOR operation on the two operands, and writes the 
result back to the first operand. The result will be 1 if just one of 
operands is greater or equal to 1 (but not two of them at once).</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X XOR Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FSIN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>053</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds sine of the second operand, and writes it into the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = Sin(Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FCOS</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>054</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds cosine of the second operand, and writes it into the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = Cos(Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FTAN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>055</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds tangent of the second operand, and writes it into the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = Tan(Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FASIN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>056</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds arcsine of the second operand, and writes it into the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = ArcSin(Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FACOS</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>057</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds arccosine of the second operand, and writes it into the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = ArcCos(Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FATAN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>058</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds arctangent of the second operand, and writes it into the first operand.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = ArcTan(Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MOD</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>059</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Finds a remainder after the first operand was divided by the second 
operand, and returns the result to the first operand. If the input is a 
floating-point value, then it will return the value of <i>X</i> &#8722; <i>n</i> * <i>Y</i>, where <i>n</i> is the quotient of <i>X</i> / <i>Y</i>, rounded toward zero to an integer.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = X FMOD Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BIT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>060</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Tests whether specific bit is set in the given number, and writes the result to the <tt>CMPR</tt> register. It’s possible to check the result of this operation using the conditional branching opcodes (see:s <a href="#branchbit">??</a>, <a href="#bitwiseops">??</a>):
</p><pre class="verbatim">BIT EAX,4 //Test 5th bit of EAX
JZ  LABEL1 //Jump if 5th bit is 0
JNZ LABEL1 //Jump if 5th bit is 1
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">CMPR = Yth bit of X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>SBIT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>061</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Sets specific bit of the first operand (see: <a href="#bitwiseops">??</a>):
</p><pre class="verbatim">MOV EAX,105 //1101001
SBIT EAX,1
//EAX = 107   1101011
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">Yth bit of X = 1
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CBIT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>062</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Clears specific bit of the first operand (see: <a href="#bitwiseops">??</a>):
</p><pre class="verbatim">MOV EAX,107 //1101011
CBIT EAX,6
//EAX = 43    0101011
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">Yth bit of X = 0
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>TBIT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>063</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Toggles specific bit of the first operand (see: <a href="#bitwiseops">??</a>):
</p><pre class="verbatim">MOV EAX,43 //0101011
TBIT EAX,0
//EAX = 42   0101010
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">Yth bit of X = 1 - Yth bit of X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BAND</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>064</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BOR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>065</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BXOR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>066</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BSHL</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>067</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BSHR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>068</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JMPF</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>069</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>EXTINT</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>070</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CNE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>071</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CNZ</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>071</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>073</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CNLE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>073</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CGE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>074</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CNL</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>074</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CL</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>075</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CNGE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>075</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CLE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>076</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CNG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>076</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>077</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CZ</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>077</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MCOPY</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>078</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MCOPY</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>078</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MXCHG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>079</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MXCHG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>079</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FPWR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>080</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>XCHG</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>081</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FLN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>082</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FLOG10</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>083</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>IN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>084</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>OUT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>085</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FABS</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>086</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FSGN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>087</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FEXP</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>088</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CALLF</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>089</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FPI</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>090</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>091</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>INT</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>092</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>TPG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>093</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>FCEIL</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>094</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>ERPG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>095</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>WRPG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>096</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>RDPG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>097</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>TIMER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>098</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LIDTR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>099</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JNER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>101</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JNZR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>101</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JMPR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>102</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JGR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>103</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JNLER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>103</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JGER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>104</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JNLR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>104</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JLR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>105</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JNGER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>105</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JLER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>106</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JNGR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>106</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>107</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>JZR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>107</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LNEG</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>108</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>EXTRET</tt><br>
<b>Encoding:</b> <tt>110</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>IDLE</tt><br>
<b>Encoding:</b> <tt>111</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>NOP</tt><br>
<b>Encoding:</b> <tt>112</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>PUSHA</tt><br>
<b>Encoding:</b> <tt>114</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>POPA</tt><br>
<b>Encoding:</b> <tt>115</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>STD2</tt><br>
<b>Encoding:</b> <tt>116</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LEAVE</tt><br>
<b>Encoding:</b> <tt>117</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>STM</tt><br>
<b>Encoding:</b> <tt>118</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CLM</tt><br>
<b>Encoding:</b> <tt>119</tt>    </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CPUGET</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>120</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CPUSET</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>121</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>SPP</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>122</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CPP</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>123</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>SRL</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>124</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>GRL</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>125</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LEA</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>126</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>BLOCK</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>127</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CMPAND</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>128</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CMPOR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>129</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MSHIFT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>130</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>SMAP</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>131</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>GMAP</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>132</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>RSTACK</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>133</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>SSTACK</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>134</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>ENTER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>135</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VADD</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>250</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VSUB</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>251</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VMUL</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>252</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VDOT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>253</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VCROSS</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>254</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VMOV</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>255</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VNORM</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>256</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VCOLORNORM</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>257</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>LOOPXY</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>259</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p><p>IF EDX &gt; 0 THEN<br>
IP = X<br>
IF ECX &gt; 0 THEN<br>
ECX = ECX - 1<br>
ELSE<br>
EDX = EDX - 1<br>
ECX = Y<br>
END<br>
END</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MADD</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>260</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MSUB</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>261</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MMUL</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>262</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MROTATE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>263</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MSCALE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>264</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MPERSPECTIVE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>265</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MTRANSLATE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>266</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MLOOKAT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>267</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MMOV</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>268</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VLEN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>269</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MIDENT</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>270</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VMODE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>273</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VDIV</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>295</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>VTRANSFORM</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>296</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h1 class="chapter">
<h2 class="section"><p>
HL-ZASM is a high-level assembler compiler and a programming language. 
It provides support for all the basic C high-level structures, while 
retaining compatibility with ZASM2 assembly code.</p>
<h2 class="section"><p>
There are certain characters and keywords that are reserved in the 
HL-ZASM compiler, and cannot be used as, for example, variable names. A 
variable name/function name/identifier can be any alphanumeric 
character, underscore (<tt>_</tt>). In some cases the dot (<tt>.</tt>) symbol can be part of a label name.</p><p>The following keywords are reserved: 
<tt>GOTO</tt>, <tt>FOR</tt>, <tt>IF</tt>, <tt>ELSE</tt>, <tt>WHILE</tt>, <tt>DO</tt>, <tt>SWITCH</tt>, <tt>CASE</tt>,
<tt>CONST</tt>, <tt>RETURN</tt>, <tt>BREAK</tt>, <tt>CONTINUE</tt>, <tt>EXPORT</tt>, <tt>FORWARD</tt>,
<tt>DB</tt>, <tt>ALLOC</tt>, <tt>SCALAR</tt>, <tt>VECTOR1F</tt>, <tt>VECTOR2F</tt>, <tt>UV</tt>, <tt>VECTOR3F</tt>,
<tt>VECTOR4F</tt>, <tt>COLOR</tt>, <tt>VEC1F</tt>, <tt>VEC2F</tt>, <tt>VEC3F</tt>, <tt>VEC4F</tt>, <tt>MATRIX</tt>,
<tt>STRING</tt>, <tt>DB</tt>, <tt>DEFINE</tt>, <tt>CODE</tt>, <tt>DATA</tt>, <tt>ORG</tt>, <tt>OFFSET</tt>,
<tt>VOID</tt>, <tt>FLOAT</tt>, <tt>CHAR</tt>, <tt>INT48</tt>, <tt>VECTOR</tt>, <tt>PRESERVE</tt>, <tt>ZAP</tt>.</p><p>The exact meaning and use of these keywords is detailed in the following chapters.</p>
<h2 class="section">
<h3 class="subsection"><p>
HL-ZASM supports the following common assembly syntax (Intel-like):
</p><pre class="verbatim">mov eax,123; //Moving constant into register
mov eax,ebx; //Moving register into register

add eax,123; //2-operand instruction
jmp 123; //1-operand instruction on constant
jmp eax; //1-operand instruction on register
</pre><p>The two operands always follow the instruction. The first one 
is always the destanation operand, and the second one is the source 
operand.</p>
<h3 class="subsection"><p>
It is possible to use both the traditional ZASM memory access symbol (<tt>#</tt>) or the more common square brackets (<tt>[]</tt>). Both are considered valid.</p><p>The CPU also supports segment prefixes to offset memory reads (see: <a href="#segments">??</a>
 for more information on segments). It is possible to use any 
general-purpose or segment register as a segment prefix to any common 
operand.</p><p>HL-ZASM allows for an ’inverted’ syntax, which is when a 
segment prefix follows the operand itself (for example ’es:eax’ instead 
of ’eax:es’).</p><p>When using common syntax for reading a value from 
memory, a segment prefix must be included inside the brackets. It is 
possible to use the plus sign (<tt>+</tt>) instead of a colon (<tt>:</tt>), but the common memory access syntax must be used.</p><p>It
 is also possible to use a constant value as a segment prefix for a 
register via inverted syntax support. It is currently not possible to 
access a memory cell using a constant offset by a constant, but this 
will be fixed later.</p><p>The following syntax for using memory access and segments is supported:
</p><pre class="verbatim">//ZASM2-style reading from memory
mov eax,#100;
mov eax,#eax;
mov eax,es:#100;
mov eax,es:#eax;
mov eax,eax:#100;
//mov eax,eax:#es; //Invalid: cannot use segment register as pointer

//Common-style reading from memory
mov eax,[100];
mov eax,[eax];
mov eax,[es:eax];
mov eax,[es+eax];
//mov eax,[eax:es]; //Invalid: cannot use segment register as pointer
//mov eax,[eax+es]; //Invalid: cannot use segment register as pointer

//Using constants with segments
mov eax,es:100;
mov eax,eax:100;
mov eax,100:es;
mov eax,100:eax;
//mov eax,100:200; //Invalid

//Using registers with segments
mov eax,ebx:ecx;
mov eax,es:ebx;
mov eax,ebx:es; //Invalid, but translated into the valid 'es:ebx'
//mov eax,fs:es; //Invalid, as no valid syntax is possible
</pre>
<h3 class="subsection"><p>
It is possible to use constant expressions, hexadecimal values and label values in HL-ZASM:
</p><pre class="verbatim">//Constant integers
mov eax,255;   //EAX = 255
mov eax,0255;  //EAX = 255
mov eax,0x1FF; //EAX = 511

//Negative integers
mov eax,-255;   //EAX = -255
mov eax,-0x1FF; //EAX = -511

//Floating point numbers and expressions
mov eax,1e4;         //EAX = 10000
mov eax,1.53e-3;     //EAX = 0.00153
mov eax,1.284;       //EAX = 1.248
mov eax,2.592+3.583; //EAX = 6.175
mov eax,1e2+15;      //EAX = 115
//mov eax,1e-5+0.034;//Does not parse (bug)
mov eax,0xFF+100;    //EAX = 355

//Complex expressions
define labelname,512;
mov eax,10+15;         //EAX = 25
mov eax,10*(15+17*24); //EAX = 4230
mov eax,10+labelname*53-10*(17-labelname); //EAX = 32096
</pre>
<h3 class="subsection"><p>
Labels are used to branch to specific portions of code. Each label name 
is actually a number with a name assigned to it. That means that 
variable names and label names all have valid constant values, and can 
be used in expressions as parameters for various macros:
</p><pre class="verbatim">labelname:
  jmp labelname;
  mov eax,labelname+3;

labelName: //case sensitive
  jmp labelName;
</pre><p>The <tt>define</tt> macro allow a label name to be assigned to any constant expression:
</p><pre class="verbatim">define defVar1,120;
define defVar2,50+defVar1;
//define defVar3,labelname2*10; //Does not parse, bug

labelname2:
  mov eax,defVar1; //120
  mov eax,defVar2; //170
//mov eax,defVar3; //170
</pre><p>The <tt>db</tt> macro is used to write specific values to memory, bypassing any preprocessing. They will be written into the code segment:
</p><pre class="verbatim">db 100; //Outputs 100
db 0xFF; //Ouputs 255
db labelname2+10;
db 'This is a string',0;
db 15,28,595,'string',35,29;
</pre><p>The <tt>alloc</tt> macro allocates space and allows it to be 
accessed by name, if one is given. It will be located at the current 
position in memory (if data and code are located in the same segment), 
or in a separate data segment, depending on the compiler preferences. 
The first parameter must either be a valid ident or a constant 
expression that does not start with an ident:
</p><pre class="verbatim">alloc var1,100,72; //alloc label,size,value, same as 'var1: db 72,72,72,...'
alloc var2,100;    //alloc label,value, same as 'var2: db 100'
alloc var3;        //alloc label, same as 'var3: db 0'
alloc 120;         //alloc size, same as 'db 0,0,0,0,0....'

define allocsize,120;
alloc 0+allocsize; //must not start with an ident name
</pre><p>There are also special macros for defining vector variables and string variables. The basic syntax is <tt>VECTOR_MACRO NAME,DEFAULT_VALUE</tt>. These are the examples of all available vector macros:
</p><pre class="verbatim">scalar name,...; //For example "scalar x,10"
vector1f name,...;
vector2f name,...;
vector3f name,...;
vector4f name,...;
vec1f name,...;
vec2f name,...;
vec3f name,...;
vec4f name,...;
uv name,...; 
color name,...; 
matrix name; //No default initializer
</pre><p>It’s possible to get pointer to each of the members of the vector variable:
</p><pre class="verbatim">vector3f vec1;
mov #vec1.x,10;
mov #vec1.y,20;
*(vec1.z) = 30;

uv texcoord1;
mov #texcoord1.u,10;
mov #texcoord1.v,20;

color col1;
mov #col1.r,10;
mov #col1.g,20;
mov #col1.b,30;
mov #col1.a,40;
</pre><p>Matrix and vector variables can be used along with the vector extension of the ZCPU:
</p><pre class="verbatim">matrix m1;
matrix m2;
vector4f rot,0,0,1,45;

mident m1; //Load identity matrix
mrotate m2,rot; //Load rotation matrix

mmul m1,m2; //Multiply two matrices
</pre><p>There’s also an additional macro which is not directly 
connected to creating variables, but it allows to change the current 
write pointer of the program (the location in memory at which program is
 being written). The macro is called <tt>ORG</tt>:
</p><pre class="verbatim">//Write pointer 0
alloc 64;
//Write pointer is now 64
alloc 1;
//Write pointer is now 65

ORG 1000;
//Write pointer is now 1000
</pre><p>This macro can be used for slightly more advanced management of the code generation.</p><p>There are also two special helper macros available that can be used to simplify variable declaration in the simple program: the <tt>DATA</tt> and the <tt>CODE</tt> macros. They are used like this:
</p><pre class="verbatim">DATA; //Data section
  alloc var1;
  alloc var2;
  ......
  subroutine1:
    ....
  ret
  ....
CODE; //Main code section
  call subroutine1;
  call subroutine2;
  ......
</pre><p>These macros are expanded into the following code:
</p><pre class="verbatim">//DATA
jmp _code;

//CODE
_code:
</pre>
<h2 class="section"><p>
HL-ZASM has a built-in expression generator. It is possible to generate 
complex expressions that can involve function calls, registers, 
variables in a similar way as they are generated in the C code.</p><p>Here are the several examples of various expressions:
</p><pre class="verbatim">EAX = 0 //Same as "mov eax,0"
EAX += EBX //Same as "add EAX,EBX"

main()
print("text",999)
R17 = solve("sol1",50,R5)
R2 = R0 + R1*128
c = *ptr++;

R0 = (noise(x-1, y) + noise(x+1, y) + noise(x, y-1) + noise(x, y+1)) /  8
Offset = 65536+32+MAX_DEVICES+udhBusOffset[busIndex*2]
</pre><p>Extra care must be taken while using the expression generator, since it will use the 6 general purpose registers (<tt>EAX</tt> .. <tt>EDI</tt>) as temporary storage for evaulating the expressions.</p><p>There
 is support for parsing constant expressions, which are reduced to a 
single constant value during compile time. It is possible to use the 
following syntax features in the expression parser:



</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Syntax</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>-X</tt>, <tt>+X</tt></td><td align="left" valign="top">Specify value sign, or negate the value</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>&amp;globalvar</tt></td><td align="left" valign="top">Pointer to a global variable (always constant)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>&amp;stackvar</tt></td><td align="left" valign="top">Pointer to a stack variable (always dynamic)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>&amp;globalvar[..]</tt></td><td align="left" valign="top">Pointer to an element of a global array</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>&amp;stackvar[..]</tt></td><td align="left" valign="top">Pointer to an element of a stack-based array</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>1234</tt></td><td align="left" valign="top">Constant value</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>"string"</tt></td><td align="left" valign="top">Pointer to a constant string, can be only used inside functions</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>’c’</tt></td><td align="left" valign="top">Single character</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>pointervar</tt></td><td align="left" valign="top">Constant pointer (or a label)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>EAX</tt></td><td align="left" valign="top">Register</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>func(...)</tt></td><td align="left" valign="top">Function call</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>var[...]</tt></td><td align="left" valign="top">Array access</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>*var</tt></td><td align="left" valign="top">Read variable by pointer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>expr + expr</tt></td><td align="left" valign="top">Addition</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr - expr</tt></td><td align="left" valign="top">Subtraction</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr * expr</tt></td><td align="left" valign="top">Product</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr / expr</tt></td><td align="left" valign="top">Division</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr ^^expr</tt></td><td align="left" valign="top">Raising to power</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr &amp;expr</tt></td><td align="left" valign="top">Binary AND</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr |expr</tt></td><td align="left" valign="top">Binary OR</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr ^expr</tt></td><td align="left" valign="top">Binary XOR</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr &amp;&amp;expr</tt></td><td align="left" valign="top">Logic AND</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr ||expr</tt></td><td align="left" valign="top">Logic OR</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>expr = expr</tt></td><td align="left" valign="top">Assign (returns value of left side AFTER assigning)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr &gt; expr</tt></td><td align="left" valign="top">Greater than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr &gt;= expr</tt></td><td align="left" valign="top">Greater or equal than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr == expr</tt></td><td align="left" valign="top">Equal</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr &lt;= expr</tt></td><td align="left" valign="top">Less or equal than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr &lt; expr</tt></td><td align="left" valign="top">Less than</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>expr++</tt></td><td align="left" valign="top">Increment (returns value BEFORE incrementing)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>expr--</tt></td><td align="left" valign="top">Decrement (returns value BEFORE decrementing)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>++expr</tt></td><td align="left" valign="top">Increment (returns value AFTER incrementing)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>--expr</tt></td><td align="left" valign="top">Decrement (returns value AFTER decrementing)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>Expression generator supports expressions inside opcodes as well.</p>
<h2 class="section"><p> <a name="vardef"></a>
It’s possible to declare variables in HL-ZASM the same way they are 
declared in the C programming language. It must be noted, however, that 
there is a difference between variables declared with this way, and 
variables declared using ZASM2 macros. It will be detailed a bit more on
 this problem further down.</p><p>Variables may be declared either in 
global space (data segment), or local space (stack segment/stack frame).
 The variables declared in the global space are created at compile-time,
 while the stack-based variables are allocated runtime.</p><p><em>Take note that variable declarations and variable definitions are two different things</em>. Variables are declared as shown below, but they can be defined using ZASM2 macros. Consider the following code:
</p><pre class="verbatim">float x;
mov x,10;  //Set variable X to 10
mov #x,10; //Same as '*(x) = 10'

scalar y;
mov y,10; //Does nothing, same as 'mov 123,10'
mov #y,10; //Sets variable Y to 10
</pre><p>There are three types supported by the compiler right now: <tt>float</tt> (64-bit floating point variable), <tt>char</tt> (64-bit floating point character code), <tt>void</tt>
 (undeclared type/no assigned behaviour). Unlike the usual compilers, 
all three types work the same way, and are essentially the same thing:
</p><pre class="verbatim">float x;
float y,z;
char* w;
char** u; //Pointer to a pointer

//In all of these examples 'a' is a pointer to a character
char * a;
char* a;
char *a;
char b,*a;
</pre><p>It’s possible to use <tt>*</tt> symbol to create pointers to 
variables. There is no difference on whether there are any whitespaces 
between the asterisk and the variable name (the asterisk belongs to the 
variable name).</p><p>Arrays of constant size may be declared as variables. If array is located in global scope, <em>all members will usually default to zero, although this is might not be the case if program is dynamically loaded by the OS</em>. If the array is declared in local scope, the contents of it may be undeclared. :
</p><pre class="verbatim">float arr[256];

arr[100] = 123;
R0 = arr[R1];
</pre><p>There is no way to declare 2-dimensional arrays right now, but there will be support for that feature at some point.</p><p>It’s
 possible to use initializers for the arrays and the variables. It’s 
only possible to use constant expressions as initializers for the global
 scope variables and arrays (there is no limit on what expressions may 
be used in the stack-based mode):
</p><pre class="verbatim">//Global scope
float x = 10;
float garr1[4] = { 0, 5, 7, 2 };
float garr2[8] = { 1, 2 }; //Missing entries filled with zeroes
float garr3[8] = { 1, 2, 0, 0, 0, 0, 0, 0 }; //Same as garr2

//Local scope
void func(float x,y) {
  float z = x + y * 128;
  float larr1[4] = { x, y, 0, 0 };
  float larr2[16] = { x, 0, y }; //Missing entries filled with zeroes
}
</pre><p>There is also support for creating variables, which are stored 
in the processors registers. To do this their type must be prepended 
with the <tt>register</tt> keyword. Local variables in registers work 
much faster than the stack-based local variables, but they cannot be an 
array type (they can be a pointer though):
</p><pre class="verbatim">void strfunc(char *str) {
  register char *ptr = str;  
  *ptr++ = 'A';
}
</pre><p>There is a limit on how much local register variables there can be.</p>
<h2 class="section"><p>
It’s possible to use C-style function declaration syntax, although only one style is currently supported:
</p><pre class="verbatim">return_type function_name(param_type1 name1, name2, param_type2 name3) {
  ....
  code
  ....
}
</pre><p>Parameters are defined the same way the variables are defined, see: <a href="#vardef">??</a>. It’s possible to use constant-size arrays as variables into function, but <em>there is no way to actually pass them into the function right now</em>. It’s also possible to use sizeless array as a parameter (see examples).</p><p>Examples of declaring functions:
</p><pre class="verbatim">void main() { .. }
float func1() { .. }
float func2(float x, y, float z) { .. }

char strcmp(char* str1, char* str2) { .. }
float strlen(char str[]) { .. } //'char str[]' is same as 'char* str'

//no way to actually pass an array like this:
void dowork(char str[256]) { .. } 
</pre><p>There are two kinds of function declarations - normal 
declarations, and forward declarations. Normal function declarations can
 be anywhere in the code, and there’s no restriction on using them from 
any other part of the program. Forward function declarations must always
 precede the function use (or they must be declared beforehand without 
the function body).</p><p>The forward function declarations allow to 
perform strict arguments check, and they allow overriding the function 
to have different parameter lists while having the same name. A function
 can be forward-declared by using the <tt>FORWARD</tt> keyword before the function type:
</p><pre class="verbatim">//Forward declarations before use
forward void func(); //First function
forward void func(float x); //Second function
forward void func(float x, *y);

func(); //Calls first function
func(10); //Calls second function

func2(); //COMPILE ERROR: function 'func2' is not declared

//Actual function bodies
forward void func() { //First function
  ...
}
forward void func(float x) { //Second function
  ...
}
forward void func(float x, *y) {
  ...
}
forward void func2() {
  ...
}
</pre><p>Unlike the forward function declarations, the normal functions 
can be used from anywhere in the code, but they do not provide strict 
argument type checks:
</p><pre class="verbatim">void func1() { .. }

func1();
func2(); //Works even thought it's not yet declared

void func2() { .. }
</pre><p>There’s also an additional keyword that can be used when defining functions - <tt>EXPORT</tt>. If this keyword is used, the function name will be preserved in the generated library (see: <a href="#libgen">??</a>
 for more informations on how to generate libraries). The compiler will 
also add a declaration for this function automatically in the generated 
library file:
</p><pre class="verbatim">export void func1() { .. }
void func2() { .. } //Function name will be mangled in the resulting file
</pre>
<h2 class="section">
<h3 class="subsection"><p>
HL-ZASM uses the <tt>cdecl</tt> calling convention. The function result 
is passed via the EAX register. If the function is not forward-declared,
 or if it has variable argument count, then the ECX register must be set
 to the parameter count:
</p><pre class="verbatim">R0 = func(a,b,c);

//Same as:
push c;
push b;
push a;
mov ecx,3; //Optional if forward-declared
call func;
add esp,3; //Must clean up stack
mov r0,eax; //Return result

main();

//Same as:
mov ecx,0;
call func;
</pre><p>The function will modify EAX, ECX, EBP registers (along with 
the ESP register), and may modify all other registers unless they are 
marked as preserved (see <a href="#preserve">??</a>).</p>
<h3 class="subsection"><p>
The HL-ZASM uses the ZCPU stack frame management instructions (<tt>ENTER</tt>, <tt>LEAVE</tt>) for creating a stack frame for the function. It will pass number of local variables into the <tt>ENTER</tt> instruction, so it will create a stack frame with pre-allocated space for local variables.</p><p>The function would generate such code:
</p><pre class="verbatim">void func(float x,y) {
  float z,w;
  ...
}

//Generates:
func:
  enter 2;
    ....
  leave;
  ret
</pre><p>All the access to variables on stack is done via the <tt>RSTACK</tt>, <tt>SSTACK</tt> instructions. The compiler will use <tt>EBP:X</tt> as the stack offset, where <tt>EBP</tt> is the stack frame base register, and <tt>X</tt> is the offset of the target value on stack. For example:
</p><pre class="verbatim">void func(float x,y) {
  float z,w;
}

//These values would be laying on stack
//[ 3] Y
//[ 2] X
//[ 1] Return address
//[ 0] Saved value of EBP (at function call)
//[-1] Z
//[-1] Z

//Therefore this would be valid:
rstack R0,EBP:2  //R0 = X
rstack R1,EBP:3  //R1 = Y
rstack R2,EBP:-1 //R2 = Z
rstack R3,EBP:-2 //R3 = W
</pre><p>Therefore it’s possible to generate a stack trace using the following code:
</p><pre class="verbatim">void stack_trace() {
  char* returnAddress,savedEBP;
  
  R0 = EBP; //'Current' EBP
  while ((R0 &gt; 0) &amp;&amp; (R0 &lt; 65535)) {
    rstack returnAddress,R0:1;
    rstack savedEBP,R0:0;    
    
    add_to_trace(returnAddress);    
    R0 = savedEBP;
  }
}
</pre>
<h3 class="subsection"><p> <a name="preserve"></a>
If the current program makes use of any ZCPU registers, it must mark 
them as preserved so the expression generator does not use those 
registers for purpose of calculating expressions.</p><p>The compiler 
will give out warning when unpreserved registers are being used. Right 
now only EAX-EDI registers must be marked as preserved (since only those
 are used for expression generator):
</p><pre class="verbatim">void func(float x,y) {
  preserve EAX, EBX;
  
  //Expression generator will never change EAX or EBX registers
  EAX = 123;
  EBX = x*10 + y;
}
</pre>
<h2 class="section"><p>
The HL-ZASM compiler supports common C control structures, although right now the support is limited.</p><p>The conditional branching can be done via the <tt>if</tt> construct. The <tt>else</tt> clause, and the <tt>else if</tt> are supported. It’s possible to branch into a single expression, or into an entire block of code too:
</p><pre class="verbatim">//Can use blocks
if (expression) {
  ....
} else if (expression) {
  ....
} else {
  ....
}

//Can avoid using blocks:
if (expression) expression;
if (expression) expression1 else expression2;
</pre><p>HL-ZASM supports <tt>for</tt> loops. The syntax is:
</p><pre class="verbatim">for (initializer; condition; step) { ... }
</pre><p>where <tt>initializer</tt> is the expression that will be executed to setup the loop, <tt>condition</tt> is the condition that is tested on each step, and <tt>step</tt> is the expression executed after each step. For example:
</p><pre class="verbatim">float x;
for (x = 0; x &lt; 128; x++) { .. } //Loop for X from 0 to 127
for (x = 128; x &gt; 0; x--) { .. } //Loop for X from 128 to 1
for (;;) { .. } //Infinite loop
</pre><p>It’s possible to use the <tt>while</tt> loop (but no support for <tt>do - while</tt> loops yet):
</p><pre class="verbatim">while (expression) { ... }
while ((x &lt; y) &amp;&amp; (x &gt; 0)) { ... }
while (1) { ... } //Infinite loop
</pre><p>The <tt>break</tt> keyword can be used to end the currently executed loop, for example:
</p><pre class="verbatim">while(1) {
  if (condition) {
    break;
  }
  ....
}
</pre><p>It’s possible to use the <tt>continue</tt> keyword to go on to the next step in the loop. For example:
</p><pre class="verbatim">float x;
for (x = 0; x &lt; 128; x++) {
  if (x == 50) { //Skip iteration 50
    continue;
  }
}
</pre><p>It’s also possible to define labels, and then jump to those 
labels by defining them the same way they are defined in ZASM2, and 
using <tt>GOTO</tt>:
</p><pre class="verbatim">....
  goto label1; //Jumps to label1
....
  label1:
</pre><p>When using the <tt>GOTO</tt> it’s also possible to pass a complex expression into it:
</p><pre class="verbatim">goto function_entrypoints[10];
</pre>
<h2 class="section"><p>
The HL-ZASM preprocessor supports C-style preprocessor macros. 
Preprocessor macros are always last on the current line (it is not 
possible to write two preprocessor macros on same line).</p>
<h3 class="subsection"><p> <a name="crtmacro"></a>
By default programs compiled with HL-ZASM have no attached runtime 
library, and would require rewriting all the basic routines. It is 
possible to link to a runtime library of a choice though. The default 
runtime library is called <tt>ZCRT</tt>, and it allows to boot up the ZCPU without any additional software.</p><p>The
 CRT library can be picked with the following preprocessor macro. It 
must be located in the first line of code, before any other code is 
generated, otherwise it will not work correctly (macro is 
case-insensitive):
</p><pre class="verbatim">#pragma CRT ZCRT
</pre><p>This macro will add CRT folder as one of the search paths, and include the main CRT file:
</p><pre class="verbatim">#pragma SearchPath lib\zcrt\
#include &lt;zcrt\main.txt&gt;
</pre><p>This makes it possible to use the default libraries that belong to that runtime library. see: <a href="#zcrtlib">??</a> for more information on the <tt>ZCRT</tt> library.</p>
<h3 class="subsection"><p>
It is possible to use the C style definition preprocessor macros (it is 
not possible to define preprocessor functions yet though). It supports 
the <tt>#define</tt>, <tt>#ifdef</tt>, <tt>#elseif</tt>, <tt>#else</tt>, <tt>#endif</tt> and the <tt>#undef</tt> macros:
</p><pre class="verbatim">#define DEF1
#define DEF2 1234

#ifdef DEF1
  func(DEF2) //same as func(1234)
  ...
#elseif DEF2
  ....
#else
  ...
#endif

#undef DEF1
</pre>
<h3 class="subsection"><p>
The preprocessor supports including external files using the <tt>#include</tt> macro:
</p><pre class="verbatim">#include "filename"
#include &lt;filename&gt;
</pre><p>The <tt>#include "filename"</tt> macro will include file from 
the current working directory. This is the same directory the main 
(first) compiled source file is located in. The other version of this 
macro includes file relative to the base directory (<tt>CPUChip</tt>).</p><p>If file is not found, it will also be searched on one of the search paths.</p><p>The preprocessor also supports the ZASM2 file include syntax:
</p><pre class="verbatim">##include## filename
same as
#include &lt;filename&gt;
</pre>
<h3 class="subsection"><p>
There are several special compiler commands available through the <tt>#pragma</tt> macro.</p><p>The <tt>#pragma set</tt> macro allows user to modify settings of the compiler. Example of the syntax (everything is case-sensitive):
</p><pre class="verbatim">#pragma set OutputResolveListing true
</pre><p>There are the following settings available:



</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Name</td><td align="center" nowrap="nowrap" valign="top">Default</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">CurrentLanguage</td><td align="center" nowrap="nowrap" valign="top">HLZASM</td><td align="left" valign="top">Current compiler language. Can be HLZASM or ZASM2</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">CurrentPlatform</td><td align="center" nowrap="nowrap" valign="top">CPU</td><td align="left" valign="top">Target platform. Defines the feature set, cannot be modified</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">MagicValue</td><td align="center" nowrap="nowrap" valign="top">-700500</td><td align="left" valign="top">The magic value is used in place of an erroneous constant value</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OptimizeLevel</td><td align="center" nowrap="nowrap" valign="top">0</td><td align="left" valign="top">Optimizer level. 0 is none, 1 is low, 2 is high. Not supported right now.</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
OutputCodeTree</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output code tree</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputResolveListing</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output code listing for resolve stage</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputFinalListing</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output code listing for final stage</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputTokenListing</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output tokenized sourcecode</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputBinaryListing</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output final binary dump as listing</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputDebugListing</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output the debug data as listing</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputToFile</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output listings to files instead of to the console</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputOffsetsInListing</td><td align="center" nowrap="nowrap" valign="top">true</td><td align="left" valign="top">Output binary offsets in listings</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">OutputLabelsInListing</td><td align="center" nowrap="nowrap" valign="top">true</td><td align="left" valign="top">Output label names in final listing</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">GenerateComments</td><td align="center" nowrap="nowrap" valign="top">true</td><td align="left" valign="top">Generate extra comments in output listing</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
FixedSizeOutput</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Output fixed-size instructions (can be toggled at any time)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">SeparateDataSegment</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Puts all variables into separate data segment Not supported right now.</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">GenerateLibrary</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Generate a precompiled library. see: <a href="#libgen">??</a></td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">AlwaysEnterLeave</td><td align="center" nowrap="nowrap" valign="top">false</td><td align="left" valign="top">Always generate the enter/leave blocks in functions</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">NoUnreferencedLeaves</td><td align="center" nowrap="nowrap" valign="top">true</td><td align="left" valign="top">Do not compile functions and variables which are not used by the program</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>The <tt>#pragma language</tt> macro can be used in place of setting the language via changing the compiler variables:
</p><pre class="verbatim">#pragma language zasm
#pragma set CurrentLanguage ZASM2
</pre><p>The <tt>#pragma crt</tt> macro can be used to attach a C runtime library. see: <a href="#crtmacro">??</a> for more information.</p><p>The <tt>#pragma cpuname</tt> macro is used to assign a specific name to the target processor:
</p><pre class="verbatim">#pragma CPUName ACPI Power Controller
</pre>
<h3 class="subsection"><p>
There are several preprocessor definitions and special labels available for use by the programmer:



</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Bit</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__PTR__</tt></td><td align="left" valign="top">Current write pointer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__LINE__</tt></td><td align="left" valign="top">Current line number</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__FILE__</tt></td><td align="left" valign="top">Current file name (a string)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__DATE_YEAR__</tt></td><td align="left" valign="top">Current year (at compile time)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__DATE_MONTH__</tt></td><td align="left" valign="top">Current month (at compile time)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__DATE_DAY__</tt></td><td align="left" valign="top">Current day (at compile time)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__DATE_HOUR__</tt></td><td align="left" valign="top">Current hour (at compile time)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__DATE_MINUTE__</tt></td><td align="left" valign="top">Current minute (at compile time)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__DATE_SECOND__</tt></td><td align="left" valign="top">Current second (at compile time)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>__PROGRAMSIZE__</tt></td><td align="left" valign="top">Total size of the program in bytes</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>programsize</tt></td><td align="left" valign="top">Total size of the program in bytes (ZASM2 compatibility macro)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote>
<h2 class="section">
<h3 class="subsection"><p> <a name="libgen"></a>
no chapter
</p>
<h3 class="subsection"><p> <a name="optimizer"></a>
no chapter
</p>
<h3 class="subsection"><p> <a name="zcrtlib"></a>
no chapter but lots of incredible fun</p>
<h2 class="section">
<h3 class="subsection">
<h4 class="subsubsection"><p>
Previously unknown label, variable, or function call was never declared in the current scope.</p>
<h4 class="subsubsection"><p>
Variable or function with this name was already defined previously in the scope. Error message will point to initial definition.</p>
<h4 class="subsubsection"><p>
Expression generator expects identifier to follow (variable/function name, etc).</p>
<h4 class="subsubsection"><p>
There was something unexpected in the source code at that position. Can also indicate invalid expression syntax.</p>
<h4 class="subsubsection"><p>
Unable to get pointer of the given identifier.</p>
<h4 class="subsubsection"><p>
The ZCPU does not support the given instruction operand. Can indicate 
that segment prefix is used for segment register access, or for port 
access.</p>
<h4 class="subsubsection"><p>
Given opcode is not supported by the current architecture.</p>
<h4 class="subsubsection"><p>
It’s only possible to define arrays which have constant size. There is no support for declaring variable-sized arrays.</p>
<h4 class="subsubsection"><p>
There is no support for having complex expressions as variable initializers right now.</p>
<h4 class="subsubsection"><p>
Compiler does not support preserving registers in global scope right now.</p>
<h4 class="subsubsection"><p>
A constant value is expected, and it must not rely on values of any unknown variables or labels.</p>
<h4 class="subsubsection"><p>
Invalid syntax is being used for some specific language structure.</p>
<h4 class="subsubsection"><p>
This error indicates one of the following things:
</p><ul class="itemize"><li class="li-itemize">
	There are no more free registers to use due to too much local register variables allocated.
	</li><li class="li-itemize">The expression being generated was too complex (there are not enough unallocated registers).
	</li><li class="li-itemize">Internal compiler error.
</li></ul>
<h4 class="subsubsection"><p>
Invalid runtime library name/library is not found.</p>
<h4 class="subsubsection"><p>
File was not found in the specified folder, and it was not found on one of the search paths.</p>
<h4 class="subsubsection"><p>
Internal compiler error (is not an error that can be worked around).</p>
<h1 class="chapter">
<h2 class="section">
<h3 class="subsection"><p>
ZGPU is a vector graphics processor, which runs a certain set of 
instructions to display an image on screen. It has two basic modes of 
operation - frame-based mode, in which the processor core will execute a
 certain subprogram each time the new frame must be drawn to screen, and
 asynchonous mode, which allows to run ZGPU instructions without being 
tied to screen refreshes.</p><p>Even thought ZGPU works with vector 
graphics the final result is being rasterized into one of two buffers. 
These two buffers are called the <em>front</em> buffer, and the <em>texture</em>
 buffer. Both buffers are 512x512 pixels in size, and can be used by the
 programmer. There is support for a natively vertex mode for drawing 
graphics, but it has certain limitations.</p><p>By default the ZGPU runs the frame-based mode, which makes use of the <em>front</em> buffer to store data, which will then</p>
<h3 class="subsection"><p>be
 displayed on screen. When running in asynchonous mode the graphics are 
drawn to one of the two buffers, and are then being output to screen.</p>
<h3 class="subsection"><p>
Most of the features in the ZGPU are controlled via internal registers (see <a href="#gpuregs">??</a>
 for a complete list of all the registers). They are located in the 
register memory, which starts at addesses 63488 and ends at 65535.</p><p>The
 memory area between addresses 65536 and 131071 (inclusive) is reserved 
as an additional external memory bus. It is very slow, but it allows GPU
 to communicate with other devices. If several GPU’s are running at the 
same time, the access to these memory areas will be concurrent, and so 
additional synchronization is required to prevent race conditions or 
collisions of any sort.</p><p>The simpliest program GPU can execute is the following (it makes use of the frame-based mode of execution):
</p><pre class="verbatim">dtest; //Output test pattern to screen
dexit; //Finish execution
</pre><p>It’s possible to setup asynchonous rendering instead of frame-based rendering:
</p><pre class="verbatim">//Setup entrypoints
dentrypoint 0,DrawThread; 
dentrypoint 4,AsyncThread;

//Disable hardware clear so drawing thread does not wipe
//the image on screen
mov #regHWClear,0;
//Set asynchronous thread frequency (speed)
mov #regAsyncFreq,200000;
//Run the thread
mov #regAsyncClk,1; 
dexit;

DrawThread: //Do nothing
dexit;

AsyncThread:
  dbegin;
    dtest;
  dend;
  
  dvsync; //Add frame synchonization
jmp AsyncThread;
</pre><p>ZGPU makes use of the vector extension (see: <a href="#vectorext">??</a>) which allows it to work with matrices and vectors:
</p><pre class="verbatim">//Generate rotation, translation matrices
mrotate mRotateMatrix,vRotate;
mtranslate mTranslateMatrix,vTranslate;

//Create model matrix
mmov mModelMatrix,mRotateMatrix;
mmul mModelMatrix,mTranslateMatrix;
</pre><p>The ZGPU supports 2D and 3D graphics , which must be drawn as polygons:
</p><pre class="verbatim">dvxdata_2f polydata,4; //4 vertices
dvxdata_3f cubedata,12; //12 triangles

....

polydata:
db  0,  0;
db 10,  0;
db 10, 10;
db  0, 10;

cubedata:
db -1,-1,-1; //Triangle 1
db  1,-1,-1;
db  1, 1,-1;

db -1,-1,-1; //Triangle 2
db  1, 1,-1;
db -1, 1,-1;

...
</pre><p>Polygons can be drawn in both normal mode, and indexed mode. They can also be drawn solid-colored, textured, or wireframe:
</p><pre class="verbatim">//Load array of vertices
mov #regVertexArray,cube_varray; 
dvxdata_3f cube_idxarray,12; //Draw all faces
dvxdata_3f_wf cube_idxarray,6; //Draw faces 1-3 as wireframe

//Load array of vertices with texture coords
mov #regVertexArray,cube_varray_tex; 
dvxdata_3f_tex cube_idxarray,12; //Draw all faces, textured

cube_varray:
  db -1,-1,-1; //0
  db -1,-1, 1; //1
  db -1, 1,-1; //2
  db -1, 1, 1; //3
  db  1,-1,-1; //4
  db  1,-1, 1; //5
  db  1, 1,-1; //6
  db  1, 1, 1; //7
  
cube_idx:
  db 0,4,6;  db 0,6,2; //Face 1
  db 5,1,7;  db 1,3,7; //Face 2
  db 4,0,5;  db 0,1,5; //Face 3
  db 2,6,7;  db 3,2,7; //Face 4
  db 0,2,3;  db 1,0,3; //Face 5
  db 6,4,7;  db 4,5,7; //Face 6
</pre><p>It supports vertex buffer, which serves as temporary storage 
for 2D/3D data before it’s rendered on screen. This allows to provide 
depth-sorting within the buffer, and other features:
</p><pre class="verbatim">//Enable vertex buffer features
denable 0; //Vertex buffer
denable 1; //ZSorting
denable 2; //Lighting

//Add commands to vertex buffer
dcolor cube_color;
dvxdata_3f cube_data,12;

//Flush vertex buffer
dvxflush;

//Disable vertex buffer and its features
ddisable 0;
</pre><p>There is support for texturing using both custom textures, and textures available externally:
</p><pre class="verbatim">mov #regVertexMode,1; //Enable vertex mode
mov #regTexSize,128; //Texture size
denable 5; //Enable custom texture mapping
dcolor white; //Set color to white

dtexture 2; //Pick texture #2
drectwh rect_pos,rect_size;

...
ddisable 5; //Disable custom texture mapping

dxtexture texture_name; //Pick texture
drectwh rect_pos,rect_size;

....
string texture_name,"brick/brickfloor001a";
</pre><p>ZGPU supports various 2D transformations to move shapes on screen:
</p><pre class="verbatim">dmove target_pos; //move to position
drotatescale 1.23,2; //Rotate by 1.23 radians, and scale up twice
drect rect_pos1,rect_pos2; //Draw rectangle around 0,0 point

....
vector2f target_pos,256,256; //Screen center

vector2f rect_pos1,-50,-50; //Two endpoints for rectangle
vector2f rect_pos2, 50, 50;
</pre><p>There is also support for performing similar transformations on
 the textures, independantly of the previous transformations (rotation 
is performed around texture centerpoint usually):
</p><pre class="verbatim">denable 5; //Enable custom texturing
mov #regTexRotation,1.23; //Rotate texture by 1.23 radians
mov #regTexOffsetV,0.2; //Offset V coordinates by 0.2
dvxtexpoly horizon_polygon,4;
</pre>
<h2 class="section">
<h3 class="subsection"><p>
The basic graphics output in GPU makes use of the few control instructions (such as <tt>DCOLOR</tt>, which changes the current drawing color), and the few drawing instructions (for example <tt>DRECT</tt>, <tt>DLINE</tt>, etc).</p><p>The
 basic graphics output only requires use of the frame-based drawing 
mode. The GPU will clear the screen to black each frame, and set the 
current color to black too. To draw something the color must first be 
set to wanted color, and then some drawing instructions must be 
executed:
</p><pre class="verbatim">dcolor white;
drect rect_point1,rect_point2;
dexit; //Program must be correctly terminated

//Compiler macros for data:
color white,255,255,255;

vec2f rect_point1,50,50;
vec2f rect_point2,100,150;
</pre><p>These are all the basic drawing instruction that can be used:



</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Instruction</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DRECT</tt></td><td align="left" valign="top">Draw a rectangle between two endpoints</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DRECTWH</tt></td><td align="left" valign="top">Draw a rectangle at some point (first operand), with some size (second operand)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DORECT</tt></td><td align="left" valign="top">Similar to <tt>DRECT</tt>, but draws a rectangle outline</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DORECTWH</tt></td><td align="left" valign="top">Similar to <tt>DRECTWH</tt>, but draws a rectangle outline</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DCIRCLE</tt></td><td align="left" valign="top">Draw a circle at some point (first operand), with some radius (second operand)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DLINE</tt></td><td align="left" valign="top">Draws a line between two points. Width specified with the <tt>DSETWIDTH</tt> instruction</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>DVXPOLY</tt></td><td align="left" valign="top">Draw a custom polygon</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>It’s possible to specify quality at which the circle is drawn:
</p><pre class="verbatim">dcolor white;
mov #regCircleQuality,8; //8 vertices in the circle
dcircle pos,256; //Draw a circle in middle of the screen,
                 //and covering the entire screen
dexit;

//Compiler macros for data:
color white,255,255,255;
vec2f pos,256,256;
</pre><p>It’s also possible to draw 2D polygons (each polygon may have up to 128 vertices in it):
</p><pre class="verbatim">dcolor white;
dvxpoly polygon_data,4;
dexit;

//Compiler macros for data:
color white,255,255,255;

polygon_data: //Polygon for a distorted rectangle
  db 50,50;
  db 190,50;
  db 120,190;
  db 50,120;
</pre><p>It’s possible to use all of these instructions to draw textured data (see: <a href="#gputexturing">??</a>)</p>
<h3 class="subsection"><p>
Asynchonous thread runs in parallel to the main frame-based rendering 
thread, but it is not synchronized to frame boundaries (while the normal
 frame-based mode will restart execution each time it must render a new 
frame). It’s possible to use both at the same time, or use just one of 
two.</p><p>Asynchonous thread is not active by default, but it can be started up using the following code:
</p><pre class="verbatim">//Setup entrypoints
dentrypoint 0,DrawThread; 
dentrypoint 4,AsyncThread;

//Set asynchronous thread frequency (speed)
mov #regAsyncFreq,200000;
//Run the thread
mov #regAsyncClk,1; 
dexit;

DrawThread: //Do nothing
dexit;

AsyncThread:
  ...
jmp AsyncThread;
</pre><p>Asychronous thread frequency may be set up to 1,200,000. If 
asynchonous thread encounters an error, and there is no specified error 
handler, it will simply shut down (and reset <tt>AsyncClk</tt> register back to 0).</p><p>It’s
 possible to perform rendering in asynchonous thread in two ways. There 
are built-in opcodes which allow to draw to texture buffer, and then 
copy that image back into the front buffer. They require the hardware 
clear feature to be disabled though:
</p><pre class="verbatim">mov #regHWClear,0;
....

AsyncThread:
  dbegin; //Start drawing
    ... //Drawing code of any length
  dend; //Copy the image to front buffer
  
  dvsync; //If rendering is too fast, it can be synchronized with frame
          //generation, making it less resource intensive
jmp AsyncThread;
</pre><p>It’s also possible to manually switch buffers for drawing. see: <a href="#gpubuffers">??</a> for more information on that.</p>
<h3 class="subsection"><p>
If any error is encountered during the GPU execution, it will be handled in one of the possible ways:
</p><ul class="itemize"><li class="li-itemize">
	In frame-based mode with no entrypoint for the error handler set the 
GPU will display an error screen, detailing the error code and the error
 address.
	</li><li class="li-itemize">In frame-based mode with entrypoint set for
 the error handler the GPU will jump to the error handler. There must be
 no error occuring in the error handler itself, or the GPU will be stuck
 in an infinite loop until the frame ends.
	</li><li class="li-itemize">In asynchonous mode with no error handler an error will cause the thread to halt.
	</li><li class="li-itemize">In asynchonous mode with an error handler 
defined the thread will jump over to that error handler. Just as with 
the frame-based mode, and error inside the error handler will cause an 
infinite loop.
</li></ul><p>Entrypoint for error handler in the frame-based mode is <tt>3</tt>, and entrypoint for the asynchonous thread error handler is <tt>5</tt>. The error code will be passed in the <tt>LINT</tt> internal register, and the error parameter is passed in the <tt>LADD</tt> register. Here’s an example of how to setup an error handler in both threads:
</p><pre class="verbatim">//Setup entrypoints
dentrypoint 0,DrawThread;
dentrypoint 3,DrawError;
dentrypoint 4,AsyncThread;
dentrypoint 5,AsyncError;

....

DrawError:
  cpuget R0,28; //Read error parameter
  cpuget R1,27; //Read error code
  ....
dexit;

AsyncError: //Similar to DrawError
  cpuget R0,28; //Read error parameter
  cpuget R1,27; //Read error code
  ....
Stop: dvsync; jmp Stop; //Stop with infinite loop
</pre>
<h3 class="subsection"><p>
GPU provides several coordinate transformations. This allows programmer 
to control how the screen coordinates, which are generated by the 
drawing instructions, are mapped to screen coordiantes. The GPU native 
screen size is always 512x512 pixels (size of the rasterizer 
buffer/front buffer).</p><p>Coordinate transformation pipe (routine) can be selected using the <tt>DCPIPE</tt> opcode:
</p><pre class="verbatim">dcpipe 2; //Select transformation pipe 2
</pre><p>These coordinate transformation pipes are supported:



</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Index</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>0</tt></td><td align="left" valign="top">Coordinates are unchanged</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>1</tt></td><td align="left" valign="top">Screen height/width specified by <tt>Width</tt> and <tt>Height</tt> registers</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>2</tt></td><td align="left" valign="top">Coordinates must be in 0..1 range</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>3</tt></td><td align="left" valign="top">Coordinates must be in -1..1 range</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>4</tt></td><td align="left" valign="top">All drawing is offset so point (0,0) is the screen center</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote><p>Before
 the coordinates are mapped to the screen ones the GPU also performs 
additional transformations based on the values of several register. This
 allows for scaling, rotating, offseting the result of drawing 
instructions:
</p><pre class="verbatim">dmove offset; //Move by vector 'offset'
drotatescale 1.23,2; //Scale up twice, rotate by 1.23 radians
drect ...; //Draw something

drotatescale 0,1; //Reset rotation, scale
dmove 0; //Reset offset
</pre><p>Rotation is clockwise, argument is specified in radians. It’s 
possible to scale on each axis separately, see the list of internal 
registers at page <a href="#gpuregs">??</a>.</p>
<h3 class="subsection"><p>
The GPU can also perform transformations on separate vertices which are 
being drawn via the drawing instructions. This is usually used to 
provide 3D graphics support.</p>
<h3 class="subsection"><p>
no chapter</p>
<h3 class="subsection"><p>
no chapter</p>
<h3 class="subsection"><p>
no chapter</p>
<h3 class="subsection"><p>
no chapter</p>
<h3 class="subsection"><p>
no chapter
paramlist</p>
<h3 class="subsection"><p>
no chapter</p>
<h3 class="subsection"><p>
no chapter</p>
<h3 class="subsection"><p> <a name="gpubuffers"></a>
no chapter</p>
<h3 class="subsection"><p> <a name="gputexturing"></a>
no chapter</p>
<h3 class="subsection"><p>
no chapter</p>
<h3 class="subsection"><p>
no chapter
DDFRAME, DDTERRAIN</p>
<h2 class="section"><p> <a name="gpuregs"></a>
The internal registers of the ZGPU are mapped to the memory, and are 
available as memory locations. They can be read and written to at any 
time, and they control various aspects of the ZGPU operation.</p><p>All of these registers are available in the HL-ZASM compiler by prepending <tt>reg</tt> prefix to the registers name.</p><p>Memory offsets <tt>63488</tt>..<tt>64511</tt> are mapped to the IOBus (external ports). The memory offsets <tt>65536</tt>..<tt>131071</tt>
 are mapped to the MemBus, allowing for access to external devices from 
the GPU. There is support for both reading and writing this memory, 
although at very low speed.</p><p>


</p><blockquote class="table"><div class="center"><hr size="2" width="80%"></div><div class="center"><table border="1" cellpadding="1" cellspacing="0"><tbody><tr><td align="center" nowrap="nowrap" valign="top">Name</td><td align="center" nowrap="nowrap" valign="top">Address</td><td align="left" valign="top">Description</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Clk</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65535</tt></td><td align="left" valign="top">Current GPU power state (if set to 0, the GPU will be shut down)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Reset</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65534</tt></td><td align="left" valign="top">Reset the GPU state</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>HWClear</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65533</tt></td><td align="left" valign="top">Enables or disables the hardware clear (front buffer filling to black)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>VertexMode</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65532</tt></td><td align="left" valign="top">Enables or disables the vertex mode (raw vertex output instead of rasterizing)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Halt</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65531</tt></td><td align="left" valign="top">Halts the current GPU execution, and preserves image in the front buffer</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>RAMReset</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65530</tt></td><td align="left" valign="top">Clears the GPU RAM</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>AsyncReset</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65529</tt></td><td align="left" valign="top">Reset the asynchonous thread state</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>AsyncClk</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65528</tt></td><td align="left" valign="top">Asynchronous thread execution state</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>AsyncFreq</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65527</tt></td><td align="left" valign="top">Asynchronous thread frequency</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Index</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65526</tt></td><td align="left" valign="top">GPU index, can be between 0 and 31</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"> 
<tt>HScale</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65525</tt></td><td align="left" valign="top">Horizontal image scale (for rasterized output)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>VScale</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65524</tt></td><td align="left" valign="top">Vertical image scale (for rasterized output)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>HWScale</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65523</tt></td><td align="left" valign="top">Hardware image scale</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Rotation</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65522</tt></td><td align="left" valign="top">Rotation of the rasterized image. 0 for 0 deg, 1 for 90 deg, 2 for 180 deg, 3 for 270 deg</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexSize</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65521</tt></td><td align="left" valign="top">Subtexture size</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexDataPtr</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65520</tt></td><td align="left" valign="top">Pointer to texture data for load by the GPU</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexDataSz</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65519</tt></td><td align="left" valign="top">Size of the texture data for load by the GPU</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>RasterQ</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65518</tt></td><td align="left" valign="top">Rasterizer quality</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexBuffer</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65517</tt></td><td align="left" valign="top">Buffer used for the texturing (0: front buffer, 1: texture buffer)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">
<tt>Width</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65515</tt></td><td align="left" valign="top">Screen width (resolution)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Height</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65514</tt></td><td align="left" valign="top">Screen height (resolution)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Ratio</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65513</tt></td><td align="left" valign="top">Current screen ratio (physical)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ParamList</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65512</tt></td><td align="left" valign="top">Pointer to list of parameters for the <tt>DWRITEFMT</tt> instruction, or 0 if unused</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"> 
<tt>CursorX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65505</tt></td><td align="left" valign="top">X coordinate of the cursor (0..1)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CursorY</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65504</tt></td><td align="left" valign="top">Y coordinate of the cursor (0..1)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Cursor</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65503</tt></td><td align="left" valign="top">Should the cursor be drawn on screen</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CursorButtons</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65502</tt></td><td align="left" valign="top">State of the cursor buttons</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"> 
<tt>BrightnessW</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65495</tt></td><td align="left" valign="top">Total screen brightness</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>BrightnessR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65494</tt></td><td align="left" valign="top">R component brightness</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>BrightnessG</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65493</tt></td><td align="left" valign="top">G component brightness</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>BrightnessB</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65492</tt></td><td align="left" valign="top">B component brightness</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ContrastW</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65491</tt></td><td align="left" valign="top">Total screen contrast</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ContrastR</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65490</tt></td><td align="left" valign="top">R component contrast</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ContrastG</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65489</tt></td><td align="left" valign="top">G component contrast</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ContrastB</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65488</tt></td><td align="left" valign="top">B component contrast</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"> 
<tt>CircleQuality</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65485</tt></td><td align="left" valign="top">Circle output quality (number of vertices). Can be between 3 and 128</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>OffsetX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65484</tt></td><td align="left" valign="top">X offset for screen coordinates of all drawn graphics</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>OffsetY</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65483</tt></td><td align="left" valign="top">Y offset for screen coordinates of all drawn graphics</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Rotation</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65482</tt></td><td align="left" valign="top">Rotation in radians for screen coordinates of all drawn graphics</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>Scale</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65481</tt></td><td align="left" valign="top">Scale (1 is normal scale) for screen coordinates of all drawn graphics</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CenterX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65480</tt></td><td align="left" valign="top">X coordinate of centerpoint of rotation (see <tt>Rotation</tt> register)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CenterY</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65479</tt></td><td align="left" valign="top">Y coordinate of centerpoint of rotation (see <tt>Rotation</tt> register)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CircleStart</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65478</tt></td><td align="left" valign="top">Circle start angle (in radians)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CircleEnd</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65477</tt></td><td align="left" valign="top">Circle end angle (in radians)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>LineWidth</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65476</tt></td><td align="left" valign="top">Line width</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ScaleX</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65475</tt></td><td align="left" valign="top">X component of the scale for screen coordinates of all drawn graphics</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ScaleY</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65474</tt></td><td align="left" valign="top">Y component of the scale for screen coordinates of all drawn graphics</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>FontHalign</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65473</tt></td><td align="left" valign="top">Font horizontal align mode</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>ZOffset</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65472</tt></td><td align="left" valign="top">Extra Z offset for all coordinates passed into vertex pipe</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>FontValign</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65471</tt></td><td align="left" valign="top">Font vertical align mode</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CullDistance</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65470</tt></td><td align="left" valign="top">Culling distance</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>CullMode</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65469</tt></td><td align="left" valign="top">Face culling mode (0: front, 1: back)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>LightMode</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65468</tt></td><td align="left" valign="top">Lighting mode (0: two-side, 1: front, -1: back)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>VertexArray</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65467</tt></td><td align="left" valign="top">Pointer to array of vertices for indexed rendering</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexRotation</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65466</tt></td><td align="left" valign="top">Texture rotation in radians</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexScale</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65465</tt></td><td align="left" valign="top">Texture scale (1 is normal)</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexCenterU</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65464</tt></td><td align="left" valign="top">U component of centerpoint of texture rotation</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexCenterV</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65463</tt></td><td align="left" valign="top">V component of centerpoint of texture rotation</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexOffsetU</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65462</tt></td><td align="left" valign="top">U offset for the texture output</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top"><tt>TexOffsetV</tt></td><td align="center" nowrap="nowrap" valign="top"><tt>65461</tt></td><td align="left" valign="top">V offset for the texture output</td></tr>
<tr><td align="center" nowrap="nowrap" valign="top">&nbsp;</td></tr>
</tbody></table>

</div><div class="center"><hr size="2" width="80%"></div></blockquote>
<h2 class="section">
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DTEST</tt><br>
<b>Encoding:</b> <tt>200</tt>    </p><p><br>
<br>
<br>
 

This opcode generates a test pattern image on the GPU screen, somewhat 
similar to the PAL TV test pattern. It ignores any coordinate or texture
 transformations, and ignores all previous color commands/settings.</p><p>The rightmost left black bar will be left transparent.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">W = ScreenWidth
H = ScreenHeight
    
for bar=0,6 do
  SetColor(TEST_PATTERN_COLOR[bar])
  Rectangle(W*0.125*bar,0,W*0.125,H*0.80)
end
  
for gray=0,7 do
  SetColor(31*gray,31*gray,31*gray,255)
  Rectangle(W*0.125*gray,H*0.80,W*0.125,H*0.20)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DEXIT/DVSYNC</tt><br>
<b>Encoding:</b> <tt>201</tt>    </p><p><br>
<br>
<br>


Finishes drawing the current frame (used only in the frame-based mode). 
This must be the last instruction in any program that makes use of the 
frame-based mode.</p><p>The execution may be terminated before this instruction if amount of cycles spent drawing the current frame exceeds total limit</p><p>It’s implementation is exactly same as that of the <tt>IDLE</tt> instruction (while in the frame-based mode).</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">INTR = 1
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DCLR</tt><br>
<b>Encoding:</b> <tt>202</tt>    </p><p><br>
<br>
<br>


Clears screen/current buffer by filling it with black background.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetColor(0,0,0,0)
Rectangle(0,0,ScreenWidth,ScreenHeight)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DCLRTEX</tt><br>
<b>Encoding:</b> <tt>203</tt>    </p><p><br>
<br>
<br>


Clears screen/current buffer by filling it with a texture.</p><p>If vertex texturing is enabled, it will use the texture specified by the <tt>DTEXTURE</tt> opcode. Otherwise it will use the texture specified by the <tt>DXTEXTURE</tt> opcode.</p><p>If no texture was defined, it will fill buffer with solid black color.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">BindState()
SetColor(0,0,0,255)
Rectangle(0,0,ScreenWidth,ScreenHeight)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXFLUSH</tt><br>
<b>Encoding:</b> <tt>204</tt>    </p><p><br>
<br>
<br>


Draws all the pending polygons in the vertex buffer to screen, and clears the buffer.</p><p>This instruction is used with vertex buffer enabled. It will perform Z-sorting, clipping, etc, and draw the output to screen.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">FlushBuffer()
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXCLEAR</tt><br>
<b>Encoding:</b> <tt>205</tt>    </p><p><br>
<br>
<br>


Clears any pending polygons from the vertex buffer.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">ClearBuffer()
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSETBUF_VX</tt><br>
<b>Encoding:</b> <tt>206</tt>    </p><p><br>
<br>
<br>


Sets the current drawing target to the raw vertex output. This opcode 
can only be used when vertex mode is active, and it is the default 
target for the vertex mode.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetRendertarget(2)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSETBUF_SPR</tt><br>
<b>Encoding:</b> <tt>207</tt>    </p><p><br>
<br>
<br>


Sets current drawing target to the texture buffer. Also known as <tt>DBACKBUF</tt>.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetRenderTarget(1)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSETBUF_FBO</tt><br>
<b>Encoding:</b> <tt>208</tt>    </p><p><br>
<br>
<br>


Sets current drawing target to the front/main buffer. Also known as <tt>DFRONTBUF</tt>.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetRenderTarget(0)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSWAP</tt><br>
<b>Encoding:</b> <tt>209</tt>    </p><p><br>
<br>
<br>


Copies contents of the texture buffer into the front buffer.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Copy(RenderTarget(1),RenderTarget(0))
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXPIPE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>210</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Selects the current vertex pipe/vertex transformation mode. This 
controls the transformation that brings world-space coordinates into 
screen coordinates. <tt>X</tt> can be one of the following pipes:
</p><ul class="itemize"><li class="li-itemize">
	<tt>0</tt>: X, Y coordinates are used as the screen coordinates
	</li><li class="li-itemize"><tt>1</tt>: Y, Z coordinates are used as the screen coordinates
	</li><li class="li-itemize"><tt>2</tt>: X, Z coordinates are used as the screen coordinates
	</li><li class="li-itemize"><tt>3</tt>: Uses basic 3D perspective projection (Z: depth)
	</li><li class="li-itemize"><tt>4</tt>: Transforms X, Y coordinates with the current model matrix
	</li><li class="li-itemize"><tt>5</tt>: Performs 3D transformation with projection and model matrices
</li></ul><p><b>Pseudocode:</b>
</p><pre class="verbatim">VertexPipe = X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DCPIPE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>211</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Selects the current coordinate pipe/coordinate transformation mode. This
 controls the transformation that converts the screen coordinates into 
true coordinates, which are correctly mapped to the buffer. <tt>X</tt> can be one of the following pipes:
</p><ul class="itemize"><li class="li-itemize">
	<tt>0</tt>: No transformation
	</li><li class="li-itemize"><tt>1</tt>: Mapped to screen using the <tt>Width</tt> and <tt>Height</tt> registers.
	</li><li class="li-itemize"><tt>2</tt>: Coordinates are transformed from 0..1 range.
	</li><li class="li-itemize"><tt>3</tt>: Coordinates are transformed from -1..1 range.
	</li><li class="li-itemize"><tt>4</tt>: Coordinates are relative to the screen center (and not the top-left corner).
</li></ul><p><b>Pseudocode:</b>
</p><pre class="verbatim">CoordinatePipe = X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DENABLE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>212</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Enables one of the internal GPU modes/switches. <tt>X</tt> can be one of the following:
</p><ul class="itemize"><li class="li-itemize">
<tt>0</tt>: Vertex buffer
	</li><li class="li-itemize"><tt>1</tt>: Z-Sorting for the triangles in the vertex buffer.
	</li><li class="li-itemize"><tt>2</tt>: Flat face lighting using the internal lighting system
	</li><li class="li-itemize"><tt>3</tt>: Front/back face culling
	</li><li class="li-itemize"><tt>4</tt>: Distance-based culling
	</li><li class="li-itemize"><tt>5</tt>: Texturing using the internal GPU buffers
</li></ul><p>For example:
</p><pre class="verbatim">//Prepare 3D drawing
mov #regCullingDistance,4.0; //Setup culling distance
denable 0; //Vertex buffer
denable 1; //ZSorting
denable 2; //Lighting
denable 3; //Face culling
denable 4; //Distance-based culling
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">MODE_SWITCH[X] = 1
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DDISABLE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>213</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Disables one of the internal GPU modes/switches. <tt>X</tt> can be one of the following:
</p><ul class="itemize"><li class="li-itemize">
<tt>0</tt>: Vertex buffer
	</li><li class="li-itemize"><tt>1</tt>: Z-Sorting for the triangles in the vertex buffer.
	</li><li class="li-itemize"><tt>2</tt>: Flat face lighting using the internal lighting system
	</li><li class="li-itemize"><tt>3</tt>: Front/back face culling
	</li><li class="li-itemize"><tt>4</tt>: Distance-based culling
	</li><li class="li-itemize"><tt>5</tt>: Texturing using the internal GPU buffers
</li></ul><p>For example:
</p><pre class="verbatim">//Finish 3D drawing
ddisable 0; //Vertex buffer
ddisable 1; //ZSorting
ddisable 2; //Lighting
ddisable 3; //Face culling
ddisable 4; //Distance-based culling
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">MODE_SWITCH[X] = 0
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DCLRSCR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>214</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Clears screen with the specified color.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetColor(X)
Rectangle(0,0,ScreenWidth,ScreenHeight)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DCOLOR</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>215</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Sets the current drawing color.</p><p>If the vertex buffer is enabled, it will change the color of all the following polygons in the buffer (until the next <tt>DCOLOR</tt> command, or end of buffer).</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetColor(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DTEXTURE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>216</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Sets a texture out of one of the internal buffers. The buffer texture data is taken from is specified by the <tt>TexBuffer</tt> register.</p><p>By
 default it will take the entire buffer as the texture, but it is 
possible to specify smaller subtextures of the buffer. For example, it’s
 possible to use four 256x256 textures, or 16 128x128 textures. If it is
 done so, the <tt>X</tt> parameter will specify which subtexture must be used.</p><p>Example:
</p><pre class="verbatim">mov #regTexBuffer,0; //Select front buffer
mov #regTexSize,128; //128x128 subtextures
dtexture 2; //Bind subtexture #2
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetBufferTexture(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSETFONT</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>217</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Set the current font for all operations which output text. There are 8 fonts available:
</p><ul class="itemize"><li class="li-itemize">
	<tt>0</tt>: Letter Gothic (Lucida Console)
	</li><li class="li-itemize"><tt>1</tt>: Courier New
	</li><li class="li-itemize"><tt>2</tt>: Trebuchet
	</li><li class="li-itemize"><tt>3</tt>: Arial
	</li><li class="li-itemize"><tt>4</tt>: Times New Roman
	</li><li class="li-itemize"><tt>5</tt>: Coolvetica
	</li><li class="li-itemize"><tt>6</tt>: Akbar
	</li><li class="li-itemize"><tt>7</tt>: CSD
</li></ul><p>
<b>Pseudocode:</b>
</p><pre class="verbatim">Font = X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSETSIZE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>218</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Set the current font size for all operations which output text. Size can be any integer value between 4 and 200.</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DMOVE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>219</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Set the offset for 2D drawing. This instruction will offset all screen 
coordinates of next rendering instructions by the given vector.</p><p><tt>X</tt> must be a pointer to vector, or it can be 0. If <tt>X</tt> is equal to zero then offset will be removed.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Registers[OffsetX] = X.x
Registers[OffsetY] = X.y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXDATA_2F</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>220</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draw a single 2D polygon with up to 128 vertices. Also known as <tt>DVXPOLY</tt>.</p><p>If vertex array mode is not used, <tt>X</tt> points to an array of polygon vertex coordinates, and <tt>Y</tt> specifies the total count of vertices.</p><p>In vertex array mode, <tt>X</tt> points to an array of indexes into the vertex array, and <tt>Y</tt> specifies the total count of vertices.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">VDATA = Registers[VertexArray]
for IDX=1,MIN(128,Y) do
  if VDATA &gt; 0 then
    VIDX = ReadCell(X+IDX-1)
    VD[IDX] = {
      x = ReadCell(VDATA+VIDX*2+0),
      y = ReadCell(VDATA+VIDX*2+1)}
  else
    VD[IDX] = {
      x = ReadCell(X+(IDX-1)*2+0),
      y = ReadCell(X+(IDX-1)*2+1)}
  end
  ComputeTextureUV(VD[IDX],VD[IDX].x/512,VD[IDX].y/512)
end
DrawToBuffer(VD)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXDATA_2F_TEX</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>221</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draw a single textured 2D polygon with up to 128 vertices. Also known as <tt>DVXTEXPOLY</tt>.</p><p>If vertex array mode is not used, <tt>X</tt> points to an array of polygon vertex coordinates and texture coordinates, and <tt>Y</tt> specifies the total count of vertices.</p><p>In vertex array mode, <tt>X</tt> points to an array of indexes into the vertex array, and <tt>Y</tt> specifies the total count of vertices.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">VDATA = Registers[VertexArray]
for IDX=1,MIN(128,Y) do
  if VDATA &gt; 0 then
    VIDX = ReadCell(X+IDX-1)
    VD[IDX] = {
      x = ReadCell(VDATA+VIDX*4+0),
      y = ReadCell(VDATA+VIDX*4+1)}
    ComputeTextureUV(VD[IDX],
      ReadCell(VDATA+VIDX*4+2),
      ReadCell(VDATA+VIDX*4+3))
  else
    VD[IDX] = {
      x = ReadCell(X+(IDX-1)*4+0),
      y = ReadCell(X+(IDX-1)*4+1)}      
    ComputeTextureUV(VD[IDX],
      ReadCell(X+(IDX-1)*4+2),
      ReadCell(X+(IDX-1)*4+3))
  end
end
DrawToBuffer(VD)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXDATA_3F</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>222</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draw a single 3D polygon with up to 128 triangles.</p><p>If vertex array mode is not used, <tt>X</tt> points to an array of triangle vertex coordinates, and <tt>Y</tt> specifies the total count of triangles.</p><p>In vertex array mode, <tt>X</tt> points to an array of indexes into the vertex array, and <tt>Y</tt> specifies the total count of triangles.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">VDATA = Registers[VertexArray]
for IDX=1,MIN(128,Y) do
  if VDATA &gt; 0 then
    VIDX1 = ReadCell(X+(IDX-1)*3+0)
    VIDX2 = ReadCell(X+(IDX-1)*3+1)
    VIDX3 = ReadCell(X+(IDX-1)*3+2)
    VD[1] = {
      x = ReadCell(VDATA+VIDX1*3+0),
      y = ReadCell(VDATA+VIDX1*3+1),
      z = ReadCell(VDATA+VIDX1*3+2)}
    VD[2] = {
      x = ReadCell(VDATA+VIDX2*3+0),
      y = ReadCell(VDATA+VIDX2*3+1),
      z = ReadCell(VDATA+VIDX2*3+2)}
    VD[3] = {
      x = ReadCell(VDATA+VIDX3*3+0),
      y = ReadCell(VDATA+VIDX3*3+1),
      z = ReadCell(VDATA+VIDX3*3+2)}
  else
    VD[1] = {
      x = ReadCell(X+(IDX-1)*9+0),
      y = ReadCell(X+(IDX-1)*9+1),
      z = ReadCell(X+(IDX-1)*9+2)}
    VD[2] = {
      x = ReadCell(X+(IDX-1)*9+3),
      y = ReadCell(X+(IDX-1)*9+4),
      z = ReadCell(X+(IDX-1)*9+5)}
    VD[3] = {
      x = ReadCell(X+(IDX-1)*9+6),
      y = ReadCell(X+(IDX-1)*9+7),
      z = ReadCell(X+(IDX-1)*9+8)}
  end
    
  ComputeTextureUV(VD[1],0,0)
  ComputeTextureUV(VD[2],1,0)
  ComputeTextureUV(VD[3],1,1)
   
  DrawToBuffer(VD)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXDATA_3F_TEX</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>223</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draw a single textured 3D polygon with up to 128 triangles.</p><p>If vertex array mode is not used, <tt>X</tt> points to an array of triangle vertex coordinates and texture coordinates, and <tt>Y</tt> specifies the total count of triangles.</p><p>In vertex array mode, <tt>X</tt> points to an array of indexes into the vertex array, and <tt>Y</tt> specifies the total count of triangles.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">VDATA = Registers[VertexArray]
for IDX=1,MIN(128,Y) do
    if VDATA &gt; 0 then
      $L VIDX1 = ReadCell(X+(IDX-1)*3+0)
      $L VIDX2 = ReadCell(X+(IDX-1)*3+1)
      $L VIDX3 = ReadCell(X+(IDX-1)*3+2)
      VD[1] = {
        x = ReadCell(VDATA+VIDX1*5+0),
        y = ReadCell(VDATA+VIDX1*5+1),
        z = ReadCell(VDATA+VIDX1*5+2),
      }
      VD[2] = {
        x = ReadCell(VDATA+VIDX2*5+0),
        y = ReadCell(VDATA+VIDX2*5+1),
        z = ReadCell(VDATA+VIDX2*5+2),
      }
      VD[3] = {
        x = ReadCell(VDATA+VIDX3*5+0),
        y = ReadCell(VDATA+VIDX3*5+1),
        z = ReadCell(VDATA+VIDX3*5+2),
      }
      
      ComputeTextureUV(VD[1],
        ReadCell(VDATA+VIDX1*5+3),
        ReadCell(VDATA+VIDX1*5+4))
      ComputeTextureUV(VD[2],
        ReadCell(VDATA+VIDX2*5+3),
        ReadCell(VDATA+VIDX2*5+4))
      ComputeTextureUV(VD[3],
        ReadCell(VDATA+VIDX3*5+3),
        ReadCell(VDATA+VIDX3*5+4))
    else
      VD[1] = {
        x = ReadCell(X+(IDX-1)*15+0),
        y = ReadCell(X+(IDX-1)*15+1),
        z = ReadCell(X+(IDX-1)*15+2),
      }
      VD[2] = {
        x = ReadCell(X+(IDX-1)*15+5),
        y = ReadCell(X+(IDX-1)*15+6),
        z = ReadCell(X+(IDX-1)*15+7),
      }
      VD[3] = {
        x = ReadCell(X+(IDX-1)*15+10),
        y = ReadCell(X+(IDX-1)*15+11),
        z = ReadCell(X+(IDX-1)*15+12),
      }
      
      ComputeTextureUV(VD[1],
        ReadCell(X+(IDX-1)*15+ 3),
        ReadCell(X+(IDX-1)*15+ 4))
      ComputeTextureUV(VD[2],
        ReadCell(X+(IDX-1)*15+ 8),
        ReadCell(X+(IDX-1)*15+ 9))
      ComputeTextureUV(VD[3],
        ReadCell(X+(IDX-1)*15+13),
        ReadCell(X+(IDX-1)*15+14))
    end
    
    self:Dyn_EmitInterruptCheck()
    DrawToBuffer(VD)
  end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DVXDATA_3F_WF</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>224</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draw a single wireframe 3D polygon with up to 128 triangles.</p><p>If vertex array mode is not used, <tt>X</tt> points to an array of triangle vertex coordinates and texture coordinates, and <tt>Y</tt> specifies the total count of triangles.</p><p>In vertex array mode, <tt>X</tt> points to an array of indexes into the vertex array, and <tt>Y</tt> specifies the total count of triangles.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">VDATA = Registers[VertexArray]
for IDX=1,MIN(128,Y) do
  if VDATA &gt; 0 then
    VIDX1 = ReadCell(X+(IDX-1)*3+0)
    VIDX2 = ReadCell(X+(IDX-1)*3+1)
    VIDX3 = ReadCell(X+(IDX-1)*3+2)
    VD[1] = {
      x = ReadCell(VDATA+VIDX1*3+0),
      y = ReadCell(VDATA+VIDX1*3+1),
      z = ReadCell(VDATA+VIDX1*3+2)}
    VD[2] = {
      x = ReadCell(VDATA+VIDX2*3+0),
      y = ReadCell(VDATA+VIDX2*3+1),
      z = ReadCell(VDATA+VIDX2*3+2)}
    VD[3] = {
      x = ReadCell(VDATA+VIDX3*3+0),
      y = ReadCell(VDATA+VIDX3*3+1),
      z = ReadCell(VDATA+VIDX3*3+2)}
  else
    VD[1] = {
      x = ReadCell(X+(IDX-1)*9+0),
      y = ReadCell(X+(IDX-1)*9+1),
      z = ReadCell(X+(IDX-1)*9+2)}
    VD[2] = {
      x = ReadCell(X+(IDX-1)*9+3),
      y = ReadCell(X+(IDX-1)*9+4),
      z = ReadCell(X+(IDX-1)*9+5)}
    VD[3] = {
      x = ReadCell(X+(IDX-1)*9+6),
      y = ReadCell(X+(IDX-1)*9+7),
      z = ReadCell(X+(IDX-1)*9+8)}
  end
    
  ComputeTextureUV(VD[1],0,0)
  ComputeTextureUV(VD[2],1,0)
  ComputeTextureUV(VD[3],1,1)
   
  DrawToBuffer(VD,WIREFRAME)
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DRECT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>225</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draws a single rectangle. <tt>X</tt> is a pointer to vector which specifies the top-left vertex, and <tt>Y</tt> is a pointer to vector which specifies the bottom-right vertex.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">  VD[1] = {
    x = ReadCell(X+0),
    y = ReadCell(X+1)}
  VD[2] = {
    x = ReadCell(Y+0),
    y = ReadCell(X+1)}
  VD[3] = {
    x = ReadCell(Y+0),
    y = ReadCell(Y+1)}
  VD[4] = {
    x = ReadCell(X+0),
    y = ReadCell(Y+1)}
  
  ComputeTextureUV(VD[1],0,0)
  ComputeTextureUV(VD[2],1,0)
  ComputeTextureUV(VD[3],1,1)
  ComputeTextureUV(VD[4],0,1)

  DrawToBuffer(VD)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DCIRCLE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>226</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draws a circle or a sector with specific radius and angles.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">  R = Y
  SIDES = clamp(ReadCell(65485),3,64)
  START = ReadCell(65478)
  END = ReadCell(65477)
  STEP = (END-START)/SIDES
  VEC = ReadVector2f(X)
  
  for IDX=1,SIDES do
    VD[1] = {
      x = VEC.x + R*sin(START+STEP*(IDX+0)),
      y = VEC.y + R*cos(START+STEP*(IDX+0))}
    VD[2] = {
      x = VEC.x,
      y = VEC.y}
    VD[3] = {
      x = VEC.x + R*sin(START+STEP*(IDX+1)),
      y = VEC.y + R*cos(START+STEP*(IDX+1))}
    
    ComputeTextureUV(VD[1],0,0)
    ComputeTextureUV(VD[2],1,0)
    ComputeTextureUV(VD[3],1,1)
    
    DrawToBuffer(VD)
  end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DLINE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>227</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draws a line between two points specified by the vectors <tt>X</tt> and <tt>Y</tt>.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">  DrawLine(ReadVector2f($1),ReadVector2f($2))
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DRECTWH</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>228</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draws a single rectangle. <tt>X</tt> is a pointer to vector which specifies the top-left corner coordinates, and <tt>Y</tt> is a pointer to vector which specifies the Rectangle size.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">  VD[1] = {
    x = ReadCell(X+0),
    y = ReadCell(X+1)}
  VD[2] = {
    x = ReadCell(X+0)+ReadCell(Y+0),
    y = ReadCell(X+1)}
  VD[3] = {
    x = ReadCell(X+0)+ReadCell(Y+0),
    y = ReadCell(X+1)+ReadCell(Y+1)}
  VD[4] = {
    x = ReadCell(X+0),
    y = ReadCell(X+1)+ReadCell(Y+1)}
  
  ComputeTextureUV(VD[1],0,0)
  ComputeTextureUV(VD[2],1,0)
  ComputeTextureUV(VD[3],1,1)
  ComputeTextureUV(VD[4],0,1)

  DrawToBuffer(VD)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DORECT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>229</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draws an outline of a rectangle. <tt>X</tt> is a pointer to vector which specifies the top-left vertex, and <tt>Y</tt> is a pointer to vector which specifies the bottom-right vertex.</p><p>The line width can be specified with the <tt>DSETWIDTH</tt> instruction.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">  VD[1] = {
    x = ReadCell(X+0),
    y = ReadCell(X+1)}
  VD[2] = {
    x = ReadCell(Y+0),
    y = ReadCell(X+1)}
  VD[3] = {
    x = ReadCell(Y+0),
    y = ReadCell(Y+1)}
  VD[4] = {
    x = ReadCell(X+0),
    y = ReadCell(Y+1)}

  DrawLine(VD[1],VD[2])
  DrawLine(VD[2],VD[3])
  DrawLine(VD[3],VD[4])
  DrawLine(VD[4],VD[1])
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DTRANSFORM2F</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>230</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Transforms a 2D vector using the projection and the modelview matrices.</p><p><b>Pseudocode:</b>
</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DTRANSFORM3F</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>231</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Transforms a 3D vector using the projection and the modelview matrices.</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSCRSIZE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>232</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Sets the current screen size.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Registers[Width] = X
Registers[Height] = Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DROTATESCALE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>233</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Rotates and scales coordinates of all following graphics instructions. 
The default centerpoint of rotation is (0,0) which can be changed using 
the <tt>CenterX</tt> and the <tt>CenterY</tt> registers.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Registers[Rotation] = X
Registers[Scale] = Y
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DORECTWH</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>234</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Draws an outline of a rectangle. <tt>X</tt> is a pointer to vector which specifies the top-left corner coordinates, and <tt>Y</tt> is a pointer to vector which specifies the Rectangle size.</p><p>The line width can be specified with the <tt>DSETWIDTH</tt> instruction.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">  VD[1] = {
    x = ReadCell(X+0),
    y = ReadCell(X+1)}
  VD[2] = {
    x = ReadCell(X+0)+ReadCell(Y+0),
    y = ReadCell(X+1)}
  VD[3] = {
    x = ReadCell(X+0)+ReadCell(Y+0),
    y = ReadCell(X+1)+ReadCell(Y+1)}
  VD[4] = {
    x = ReadCell(X+0),
    y = ReadCell(X+1)+ReadCell(Y+1)}
  
  DrawLine(VD[1],VD[2])
  DrawLine(VD[2],VD[3])
  DrawLine(VD[3],VD[4])
  DrawLine(VD[4],VD[1])
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DCULLMODE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>235</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Sets the current culling mode and lighting mode.</p><p><tt>X</tt> sets the culling mode:
</p><ul class="itemize"><li class="li-itemize">
	<tt>0</tt>: front face culling
	</li><li class="li-itemize"><tt>1</tt>: back face culling
</li></ul><p><tt>Y</tt> sets the lighting mode:
</p><ul class="itemize"><li class="li-itemize">
	<tt>0</tt>: double-side lighting
	</li><li class="li-itemize"><tt>1</tt>: front side lighting
	</li><li class="li-itemize"><tt>-1</tt>: back side lighting
</li></ul><p><b>Pseudocode:</b>
</p><pre class="verbatim">Register[CullMode] = X
Register[LightMode] = X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DPIXEL</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>238</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Outputs a single pixel to screen. <tt>X</tt> is a pointer to vector which specifies coordinates on screen (can be non-integer, which will cause anti-aliasing effect), and <tt>Y</tt> is a pointer to color of the pixel.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetPixel(X,Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DWRITE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>240</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Writes a null-terminated string to screen. <tt>X</tt> is a pointer to vector that specifies the position of string on screen, and <tt>Y</tt> is the pointer to the first character of the string.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">TEXT = VM:ReadString(Y)
FontWrite(X,TEXT)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DWRITEI</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>241</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Writes a integer value to screen. <tt>X</tt> is a pointer to vector that specifies the position of string on screen, and <tt>Y</tt> is the value that must be drawn on screen.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">FontWrite(X,Integer(Y))
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DWRITEF</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>242</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Writes a floating-point value to screen. <tt>X</tt> is a pointer to vector that specifies the position of string on screen, and <tt>Y</tt> is the value that must be drawn on screen.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">FontWrite(X,Y)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DENTRYPOINT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>243</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Sets one of the GPU entrypoints. Each entrypoint corresponds to a 
specific function, there are the following entrypoints available right 
now:</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSETLIGHT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>244</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Sets parameters of one of the 8 lights supported by the GPU. <tt>X</tt> is the light index (0..7), and <tt>Y</tt> points to the following data structure:
</p><pre class="verbatim">LightData:
  vector4f position,&lt;x&gt;,&lt;y&gt;,&lt;z&gt;,0;
  vector4f color,&lt;r&gt;,&lt;g&gt;,&lt;b&gt;,&lt;brightness&gt;;
</pre><p>Light brightness is usually set to 1, but can vary.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if (X &lt; 0) or (X &gt; 7) then
  Interrupt(19,0)
else
  Lights[X] = {
    Position = ReadVector4f(Y+0),
    Color    = ReadVector4f(Y+4)}
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DGETLIGHT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>245</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Reads light data for one of the 8 lights supported by the GPU. <tt>X</tt> is the light index (0..7), and <tt>Y</tt> points to the following data structure, which will be filled with light data:
</p><pre class="verbatim">LightData:
  vector4f position,&lt;x&gt;,&lt;y&gt;,&lt;z&gt;,0;
  vector4f color,&lt;r&gt;,&lt;g&gt;,&lt;b&gt;,&lt;brightness&gt;;
</pre><p><b>Pseudocode:</b>
</p><pre class="verbatim">N/A
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DWRITEFMT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>246</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Writes a formatted string to screen. <tt>X</tt> points to vector that specifies the position of string on screen, and <tt>Y</tt> is the string that must be drawn on screen.</p><p>Variables used in the string format must follow the string data. If <tt>ParamList</tt> register is set, then variables used in the string format start at that offset.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">N/A
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DWRITEFIX</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>247</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Writes a fixed-point value to screen. <tt>X</tt> is a pointer to vector that specifies the position of string on screen, and <tt>Y</tt> is the value that must be drawn on screen.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">N/A
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DTEXTWIDTH</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>248</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Returns the width of string using the current font, and writes it to <tt>X</tt>.</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DTEXTHEIGHT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>249</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Returns the height of string using the current font, and writes it to <tt>X</tt>.</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MLOADPROJ</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>271</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Loads given matrix into the GPU projection matrix. <tt>X</tt> points to the matrix.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">ProjectionMatrix = ReadMatrix(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MREAD</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>272</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Reads GPU model matrix. <tt>X</tt> points to the matrix into which model matrix will be written.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">WriteMatrix(X,ModelMatrix)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DT</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>274</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Returns time passed since last frame (works only in frame-based mode).</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = TimerDT
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSHADE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>276</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Shades the current color by specific amount. <tt>X</tt> is the shading 
value. A value between 0 and 1 will make the color darker, a value of 1 
will not change the current color, while value higher than 1 will make 
color brighter.</p><p>There is no normalization, so values outside of 0..1 range might generate weird colors.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Color.x = Color.x*X
Color.y = Color.y*X
Color.z = Color.z*X
SetColor(Color)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSETWIDTH</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>277</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Sets line width.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Register[LineWidth] = X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>MLOAD</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>278</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Loads given matrix into the GPU model matrix. <tt>X</tt> points to the matrix.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">ModelMatrix = ReadMatrix(X)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DSHADENORM</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>279</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Shades the current color by specific amount. <tt>X</tt> is the shading 
value. A value between 0 and 1 will make the color darker, a value of 1 
will not change the current color, while value higher than 1 will make 
color brighter.</p><p>The resulting color is normalized, so it’s possible to use values outside of the 0..1 range.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Color.x = Clamp(Color.x*X,0,255)
Color.y = Clamp(Color.y*X,0,255)
Color.z = Clamp(Color.z*X,0,255)
SetColor(Color)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DDFRAME</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>280</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Draws a framed rectangle. <tt>X</tt> points to the following data structure:
</p><pre class="verbatim">FrameData:
  vector2f position,&lt;x&gt;,&lt;y&gt;;
  vector2f size,&lt;w&gt;,&lt;h&gt;;
  vector4f info,&lt;shadow&gt;,&lt;highlight&gt;,&lt;face&gt;,&lt;border size&gt;;
</pre><p>The <tt>info</tt> entry stores pointers to colors that must be used in rendering.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">V1 = ReadVector2f(X+0)
V2 = ReadVector2f(X+2)
V3 = ReadVector4f(X+4)
  
CSHADOW    = ReadVector3f(V3.x)
CHIGHLIGHT = ReadVector3f(V3.y)
CFACE      = ReadVector3f(V3.z)

VD1[1] = {
  x = V3.w + V1.x,
  y = V3.w + V1.y}
VD1[2] = {
  x = V3.w + V1.x + V2.x,
  y = V3.w + V1.y}
VD1[3] = {
  x = V3.w + V1.x + V2.x,
  y = V3.w + V1.y + V2.y}
VD1[4] = {
  x = V3.w + V1.x,
  y = V3.w + V1.y + V2.y}

VD2[1] = {
  x = -V3.w + V1.x,
  y = --V3.w + V1.y}
VD2[2] = {
  x = -V3.w + V1.x + V2.x,
  y = -V3.w + V1.y}
VD2[3] = {
  x = -V3.w + V1.x + V2.x,
  y = -V3.w + V1.y + V2.y}
VD2[4] = {
  x = -V3.w + V1.x,
  y = -V3.w + V1.y + V2.y}

VD3[1] = {
  x = V1.x,
  y = V1.y}
VD3[2] = {
  x = V1.x + V2.x,
  y = V1.y}
VD3[3] = {
  x = V1.x + V2.x,
  y = V1.y + V2.y}
VD3[4] = {
  x = V1.x,
  y = V1.y + V2.y}

ComputeTextureUV(VD1[1],0,0)
ComputeTextureUV(VD1[2],1,0)
ComputeTextureUV(VD1[3],1,1)
ComputeTextureUV(VD1[4],0,1)
  
ComputeTextureUV(VD2[1],0,0)
ComputeTextureUV(VD2[2],1,0)
ComputeTextureUV(VD2[3],1,1)
ComputeTextureUV(VD2[4],0,1)
  
ComputeTextureUV(VD3[1],0,0)
ComputeTextureUV(VD3[2],1,0)
ComputeTextureUV(VD3[3],1,1)
ComputeTextureUV(VD3[4],0,1)

SetColor(CSHADOW)
DrawToBuffer(VD1)
SetColor(CHIGHLIGHT)
DrawToBuffer(VD2)
SetColor(CFACE)
DrawToBuffer(VD3)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DRASTER</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>283</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Set raster quality.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">Registers[RasterQ] = X
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DDTERRAIN</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>284</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Draw 3D terrain.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">W = ReadCell(X+0)
H = ReadCell(X+1)
R = clamp(floor(ReadCell(X+2)),0,16)
U = ReadCell(X+3)
V = ReadCell(X+4)

MinX = clamp(floor(W/2 + U - R),1,W-1)
MinY = clamp(floor(H/2 + V - R),1,H-1)
MaxX = clamp(floor(W/2 + U + R),1,W-1)
MaxY = clamp(floor(H/2 + V + R),1,H-1)

for X=MinX,MaxX do
  for Y=MinY,MaxY do
    XPOS = X - W/2 - U - 0.5
    YPOS = Y - H/2 - U - 0.5

    if (X &gt; 0) and (X &lt;= W-1) and (Y &gt; 0) and (Y &lt;= H-1) and (XPOS^2+YPOS^2 &lt;= R^2) then
      Z1 = ReadCell(X+16+(Y-1)*W+(X-1)
      Z2 = ReadCell(X+16+(Y-1)*W+(X-0)
      Z3 = ReadCell(X+16+(Y-0)*W+(X-0)
      Z4 = ReadCell(X+16+(Y-0)*W+(X-1)
      
      VD[1] = { x = XPOS,   y = YPOS,   y = Z1 }
      VD[2] = { x = XPOS+1, y = YPOS,   y = Z2 }
      VD[3] = { x = XPOS+1, y = YPOS+1, y = Z3}

      ComputeTextureUV(VD[1],0,0)
      ComputeTextureUV(VD[2],1,0)
      ComputeTextureUV(VD[3],1,1)
      DrawToBuffer(VD)
        
      VD[1] = { x = XPOS,   y = YPOS,   y = Z1}
      VD[2] = { x = XPOS,   y = YPOS+1, y = Z4}
      VD[3] = { x = XPOS+1, y = YPOS+1, y = Z3}

      ComputeTextureUV(VD[1],0,0)
      ComputeTextureUV(VD[2],0,1)
      ComputeTextureUV(VD[3],1,1)
      DrawToBuffer(VD)
    end
  end
end
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DMULDT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>294</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>


Multiplies <tt>Y</tt> by time-step and writes it into <tt>X</tt>. Used in frame-based mode to provide smooth animations.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">X = Y * TimerDT
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DBEGIN</tt><br>
<b>Encoding:</b> <tt>298</tt>    </p><p><br>
<br>
<br>


Starts asynchonous drawing. Used only in asynchronous thread.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">SetRenderTarget(1)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DEND</tt><br>
<b>Encoding:</b> <tt>299</tt>    </p><p><br>
<br>
<br>


Ends asynchonous drawing, and outputs the drawn image to screen.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">FlushBuffer()
Copy(1,0)
SetRenderTarget(2)
</pre>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>DXTEXTURE</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>303</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>


Binds a predefined texture. <tt>X</tt> points to the string that contains texture name. If <tt>X</tt> is equal to 0, texture will be unbound.</p><p><b>Pseudocode:</b>
</p><pre class="verbatim">if X &gt; 0 then
  NAME = VM:ReadString(X)
  SetTexture(NAME)
else
  SetTexture(0)
end
</pre>
<h1 class="chapter">
<h2 class="section"><p>
ZSPU is a programmable sequencer and sound synthesizer. It works with 
waveforms and channels. Each waveform is an unique sound, there can be 
up to 128 different waveforms loaded, while each channel corresponds to 
one of the output channels. It’s possible to play just one waveform 
through each channel, although it’s possible to use same waveform for 
many channels.</p><p>Each channel has separate pitch, volume settings, and supports hardware ADSR/LFO.</p>
<h2 class="section"><p>
no chapter</p>
<h2 class="section"><p>
no chapter</p>
<h2 class="section">
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHRESET</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>320</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHSTART</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>321</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHSTOP</tt> <tt>X</tt><br>
<b>Encoding:</b> <tt>322</tt> <tt>RM [Segment1]</tt>  <tt>[Constant1]</tt> </p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>WSET</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>330</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHWAVE</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>331</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHLOOP</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>332</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHVOLUME</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>333</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHPITCH</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>334</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHMODT</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>335</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHMODA</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>336</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHMODF</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>337</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>CHADSR</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>338</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<h3 class="subsection"><p><b>Mnemonic:</b> <tt>WLEN</tt> <tt>X</tt><tt>,Y</tt><br>
<b>Encoding:</b> <tt>339</tt> <tt>RM [Segment1]</tt> <tt>[Segment2]</tt> <tt>[Constant1]</tt> <tt>[Constant2]</tt></p><p><br>
<br>
<br>

</p><p><b>Pseudocode:</b>
</p>
<hr size="2"><blockquote class="quote"><em>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><font size="2"><sup>E</sup></font></em><em>V</em><em><font size="2"><sup>E</sup></font></em><em>A</em></a><em>.</em></blockquote>
</body>
</html>